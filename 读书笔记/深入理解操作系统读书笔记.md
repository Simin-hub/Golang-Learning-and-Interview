

# 深入理解操作系统读书笔记

## 第一章

### 如何从源文件到可执行文件

在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：

`linux>gcc -o hello hello.c`

![image-20220921160836101](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220921160836101.png)

- 预处理阶段。预处理器(cpp)根据以字符#开头的命令，修改原始的C程序。比如hello.c中第1行的`#include<stdio.h>`命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件扩展名。

- 编译阶段。编译器(cc1)将文本文件hello.i翻译成文本文件hello.s,它包含一个汇编语言程序。该程序包含函数main的定义，如下所示：

![image-20220921161146192](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220921161146192.png)

定义中2-7行的每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。

- 汇编阶段。接下来，汇编器(as)将hello.s翻译成**机器语言指令**，把这些指令打包成一种叫做**可重定位目标程序**(relocatable object program)的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它包含的17个字节是函数main的指令编码。如果我们在文本编辑器中打开hello.o文件，将看到一堆乱码。

- 链接阶段。请注意，hello程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的he11o.o程序中。**链接器(ld)就负责处理这种合并**。结果就得到hello文件，它是一个可执行目标文件(或者简称为可执行文件)，可以被加载到内存中，由系统执行。

### 系统硬件的组成

![image-20220921161559598](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220921161559598.png)

1. 总线

   贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字(word)。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节(32位)，要么是8个字节(64位)。

2. I/O设备

   **I/O(输入/输出)设备是系统与外部世界的联系通道**。系统包括四个I/O设备：作为用户输人的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器（简单地说就是磁盘）。最开始，可执行程序hello就存放在磁盘上。每个I/O设备都通过一个控制器或适配器与I/O总线相连。**控制器和适配器之间的区别主要在于它们的封装方式**。**控制器是I/O设备本身或者系统的主印制电路板**（通常称作主板)上的芯片组。而**适配器则是一块插在主板插槽上的卡**。无论如何，它们的功能都是在I/O总线和I/O设备之间传递信息。

3. 主存

   **主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据**。从物理上来说，**主存是由一组动态随机存取存储器(DRAM)芯片组成的**。从逻辑上来说，**存储器是一个线性的字节数组**，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。与C程序变量相对应的数据项的大小是根据类型变化的。比如，在运行Linux的x86-64机器上，short类型的数据需要2个字节，int和f1oat类型需要4个字节，而long和double类型需要8个字节。

4. 处理器（CPU）

   **中央处理单元(CPU),简称处理器，是解释（或执行）存储在主存中指令的引擎**。处理器的核心是一个大小为一个字的存储设备（或寄存器)，称为**程序计数器**(PC)。在任何时刻，**PC 都指向主存中的某条机器语言指令**（即含有该条指令的地址）。

   从系统通电开始，直到系统断电，**处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令**。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由**指令集架构**决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC,使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。

这样的简单操作并不多，它们围绕着主存、寄存器文件(register file)和算术/逻辑单元(ALU)进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。下面是一些简单操作的例子，

CPU在指令的要求下可能会执行这些操作。

- 加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。
- 存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。
- 操作：把两个寄存器的内容复制到ALU（算术/逻辑单元）,ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。
- 跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器(PC)中，以覆盖PC中原来的值。

### 如何运行hello程序

![image-20220921163109122](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220921163109122.png)

初始时，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输人字符串“./hello”后，shell程序将字符逐一读入寄存器，再把它存放到内存中。如上图

![image-20220921163429056](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220921163429056.png)

当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输人。然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串“hello,world\n”。

利用直接存储器存取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存。这个步骤如上图所示。

![image-20220921163702714](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220921163702714.png)

一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。这些指令将“hello,world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。这个步骤如上图所示。

### 缓存



![image-20220921164512284](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220921164512284.png)

层次结构

![image-20220921164451690](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220921164451690.png)

### 操作系统管理硬件

操作系统有两个基本功能：

（1)防止硬件被失控的应用程序滥用；

(2)向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。如下图所示，文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。

![image-20220921164806196](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220921164806196.png)

### 进程

**进程是操作系统对一个正在运行的程序的一种抽象**。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而**并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的**。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。**操作系统实现这种交错执行的机制称为上下文切换**。

**操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文**，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会**进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文**，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。下图展示了示例hello程序运行场景的基本理念。

![image-20220921165237216](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220921165237216.png)

#### 线程

尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，**每个线程都运行在进程的上下文中，并共享同样的代码和全局数据**。由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。

#### 虚拟内存

虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为**虚拟地址空间**。

在Linux中，**地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样**。地址空间的底部区域存放用户进程定义的代码和数据。请注意，图中的地址是从下往上增大的。

![image-20220921170237859](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220921170237859.png)

- **程序代码和数据**。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello。
- **堆**。代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像mal1oc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。第9章
- **共享库**。大约在地址空间的中间部分是一块**用来存放像C标准库和数学库这样的共享库的代码和数据的区域**。第7章介绍

- **栈**。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。在第3章中将学习编译器是如何使用栈的。
- **内核虚拟内存**。地址空间顶部的区域是**为内核保留的**。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。

## 第二章 信息的表示和处理

### 十六进制

在C语言中，**以0x或0X开头的数字常量被认为是十六进制的值**。字符‘A’一‘F’既可以是大写，也可以是小写。例如，我们可以将数字FA1D37B6写作0xFA1D37B,或者0xfa1d37b,甚至是大小写混合，比如，0xFa1D37b。在本书中，我们将使用C表示法来表示十六进制值。

### 字数据大小

每台计算机都有一个**字长(word size),** **指明指针数据的标称大小**(nominal size)。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，**对于一个字长为k位的机器而言，虚拟地址的范围为0~2^k^-1，程序最多访问2^k^个字节**。32位字长限制虚拟地址空间为4千兆字节（写作4GB).64位字长使得虚拟地址空间为16EB,大约是1.84×10^19^字节。

基本C语言数据类型大小

<img src="C:/Users/jiutian/AppData/Roaming/Typora/typora-user-images/image-20220921172731776.png" alt="image-20220921172731776" style="zoom:50%;" />

