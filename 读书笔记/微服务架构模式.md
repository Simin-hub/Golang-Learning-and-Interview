# 微服务架构模式读书笔记

## 第一章 逃离单体地狱

### 扩展立方体

![image-20221005210602589](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221005210602589.png)

扩展立方体定义了三种不同的扩展应用程序的方法：X轴扩展在多个相同实例之间实现请求的负载均衡；Z轴扩展根据请求的属性路由请求；Y轴扩展根据功能将应用程序拆分为服务。

这个模型描述了扩展一个应用程序的三种维度：X、Y和Z。

#### **X轴扩展：在多个实例之间实现请求的负载均衡**

X轴扩展是扩展单体应用程序的常用方法。下图展示了X轴扩展的工作原理。在负载均衡器之后运行应用程序的多个实例。负载均衡器在N个相同的实例之间分配请求。这是提高应用程序吞吐量和可用性的好方法。

![image-20221005212125948](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221005212125948.png)

#### **Z轴扩展：根据请求的属性路由请求**

Z轴扩展也需要运行单体应用程序的多个实例，但不同于X轴扩展，每个实例仅负责数据的一个子集。下图展示了Z轴扩展的工作原理。置于前端的路由器使用请求中的特定属性将请求路由到适当的实例。例如，应用程序可能会使用请求中包含的userId来路由请求。

在这个例子中，每个应用程序实例负责一部分用户。该路由器使用请求Authorization头部指定的userId来从N个相同的应用程序实例中选择一个。对于应用程序需要处理增加的事务和数据量时，Z轴扩展是一种很好的扩展方式。

![image-20221005213310383](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221005213310383.png)

#### **Y轴扩展：根据功能把应用拆分为服务**

X轴和Z轴扩展有效地提升了应用的吞吐量和可用性，然而这两种方式都没有解决日益增长的开发问题和应用复杂性。为了解决这些问题，我们需要采用Y轴扩展，也就是功能性分解。Y轴扩展把一个单体应用分成了一组服务，如图1-6示。

![image-20221006110610203](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006110610203.png)

服务本质上是一个麻雀虽小但五脏俱全的应用程序，它实现了一组相关的功能，例如订单管理、客户管理等。服务可以在需要的时候借助X轴或Z轴方式进行扩展。例如，订单服务可以被部署为一组负载均衡的服务实例。

我对微服务架构的概括性定义是：把应用程序功能性分解为一组服务的架构风格。请注意这个定义中并没有包含任何与规模有关的内容。重要的是，每一个服务都是由一组专注的、内聚的功能职责组成。我们稍后会详细讨论。

目前而言，我们先来看看为什么微服务架构是模块化的一种形式。

### 微服务

微服务架构使用服务作为模块化的单元。服务的API为它自身构筑了一个不可逾越的边界，你无法越过API去访问服务内部的类，这与采用Java包的单体应用完全不同。因此模块化的服务更容易随着时间推移而不断演化。微服务架构也带来其他的好处，例如服务可以独立进行部署和扩展。

微服务架构的一个关键特性是**每一个服务之间都是松耦合的，它们仅通过API进行通信**。实现这种松耦合的方式之一，是**每个服务都拥有自己的私有数据库**。对于一个线上商店来说，Order Service拥有一个包括ORDERS表的数据库，Customer Service服务拥有一个包含CUSTOMERS表的数据库。在开发阶段，开发者可以修改自己服务的数据库模式，而不必同其他服务的开发者协调。在运行时，服务实现了相互之间的独立。服务不会因为其他的服务锁住了数据库而进入堵塞的状态。

### 微服务架构与SOA的异同

某些针对微服务架构的批评声称它其实就是SOA,并没有新鲜的内容。在某些层面，它们的确有些相似。SOA和微服务架构都是特定的架构风格，它们都以一系列服务的方式来把一个系统组织在一起。但如果深入研究，你就会发现微服务和SOA之间巨大的差异，如表1-1所示。

![image-20221006111626749](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006111626749.png)

### 微服务的优缺点



### 模式和模式语言

**模式是针对特定上下文中发生的问题的可重用解决方案**。这个想法起源于现实世界中的建筑架构设计，并且已被证明针对软件架构设计同样行之有效。

常用的模式结构包括三个重要部分：

- 需求(Forces)。
- 结果上下文(Resulting context)。
- 相关模式(Related patterns)。

#### **需求：必须解决的问题**

需求部分**描述了必须解决的问题和围绕这个问题的特定上下文环境**。需求有时候是互相冲突的，所以不能指望把它们全部都解决（必须取舍）。哪一个需求更重要，取决于它的上下文。你必须**把需求按优先级进行排序**。例如，像代码必须易于理解和代码必须有好的性能，类似这样的两个需求在某些情况下就是冲突的。采用响应式风格编写的代码性能往往比那些同步代码的性能好很多，但是这些代码也更难以读懂。把所有的需求明确列出是非常有帮助的，因为它可以清晰展现哪些问题需要被（优先）解决。

#### **结果上下文：采用模式后可能带来的后果**

结果上下文部分**描述了采用这个模式的结果**，它包含三个部分：

- 好处：这个模式的好处和它解决了什么需求。
- 弊端：这个模式的弊端和它没有解决哪些需求。
- 问题：使用这个模式所引人的新问题。

结果上下文提供了更加完整、从不偏不倚的视角来描述的解决方案，这有助于更好的决策。

#### **相关模式：5种不同类型的关系**

相关模式部分**描述了这个模式和其他模式之间的关系**。

模式之间存在5种关系：

- 前导(Predecessor):**前导模式是催生这个模式的需求的模式**，例如，微服务架构模式是除单体架构模式以外整个模式语言中所有模式的前导模式。
- 后续（Successor):**后续模式是指用来解决当前模式引入的新问题的模式**，例如，如果你采纳了微服务架构模式，你需要一系列的后续模式来解决诸如服务发现、断路器等微服务带来的新问题。
- 替代(Alternative):**当前模式的替代模式，提供了另外的解决方案**，例如，单体架构和微服务架构就是互为替代的模式，它们都是应用的架构风格。你可以选择其一。
- 泛化（Generalization)：**针对一个问题的一般性解决方案**。例如，在第l2章中你会了解到“每主机单个服务”这个模式存在多种不同的技术实现。
- 特化（Specialization)：**针对特定模式的具体解决方案**。例如，在第l2章中你会了解到将服务部署为容器模式是针对“每主机单个服务”的具体解决方案。

### 微服务架构的模式语言概述

微服务架构的模式语言是一组模式，可帮助架构师使用微服务架构构建应用程序。图1-10显示了模式语言的结构。**模式语言首先帮助架构师决定是否使用微服务架构。它描述了单体架构和微服务架构，以及它们的好处和弊端**。然后，如果微服务架构非常适合当前的应用程序，那么模式语言可以帮助架构师通过解决各种架构和设计问题来有效地使用它。

![image-20221006113544827](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006113544827.png)

这套模式语言由若干组模式构成。在图1-10的左侧是应用程序架构模式组，包括单体架构模式和微服务架构模式。这些模式我们在本章中都已经有所讨论。其余的模式语言包括了一组如何解决采用微服务架构后引入的新问题的模式。

这些模式被分为三组：

- 基础设施相关模式组：这些模式解决通常是在开发环节跟基础设施有关的问题。
- 应用基础设施相关模式组：这些模式解决应用层面的基础设施相关问题。
- 应用相关模式组：这些模式解决开发人员面对的具体技术和架构问题。这些模式根据所解决问题的不同可进行更进一步的分组。我们先看看其中主要的几组模式。

#### **服务拆分的相关模式**

决定如何把系统分解为一组服务，这项工作从本质上来讲是一门艺术，但是即使这样，我们仍旧有一些策略可以遵循。我在服务拆分相关的模式中提出了一些策略，可以用于定义应用程序的架构。如图1-11所示。

![image-20221006114223621](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006114223621.png)

#### **通信的相关模式**

使用微服务架构构建的应用程序是分布式系统。因此，进程间通信（PC)是微服务架构的重要组成部分。架构师必须就服务彼此之间以及与外部世界进行通信做出各种架构和设计决策。

图1-12显示了通信模式，它们分为以下5组：

- 通信风格：使用哪一类进程间通信机制？
- 服务发现：客户端如何获得服务具体实例（如HTTP请求）的IP地址？
- 可靠性：在服务不可用的情况下，如何确保服务之间的可靠通信？
- 事务性消息：如何将消息发送、事件发布这样的动作与更新业务数据的数据库事务集成？
- 外部API:应用程序的客户端如何与服务进行通信？

![image-20221006135119932](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006135119932.png)

#### 实现事务管理的数据一致性相关模式

如之前提到的，为了确保松耦合，每个服务都必须拥有它自己的数据库。不幸的是，每个服务都有独立的数据库会引入一些大麻烦。例如，我会在第4章中解释为什么我们常用的两步式提交(two phase commit,2Pc)分布式事务机制在微服务架构之类场景下就不再适用。取而代之，应用程序需要使用Saga模式来确保数据的一致性。图1-13展示了数据一致性有关的模式。

![image-20221006140529219](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006140529219.png)

两步式提交(two phase commit)是指，当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引人一个作为协调者的组件来统一掌控所有节点（称作参与方）的操作结果，并最终指示这些节点是否要把操作结果进行真正的提交（比如将更新后的数据写人磁盘等等）的算法。

#### **在微服务架构中查询数据的相关模式**

服务和数据库一一对应还会带来另外一个挑战：**有些查询需要从多个服务的数据源获取数据**（传统应用采用SQL JOIN的方式完成）。服务的数据仅可以通过API的方式访问，所以我们不能直接针对服务的数据库执行分布式查询。图1-14展示了跟实现查询有关的一些模式。

![image-20221006140721369](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006140721369.png)

有些时候我们可以使用API组合模式，**逐一调用服务的API然后把所有的返回聚合在一起**。多数情况之下，你需要使用称之为**命令查询职责隔离(CQRS)的方式**，来维护一些重要和常用的查询数据视图。在第7章，我会深入探讨实现这些查询的方法。

#### 服务部署的相关模式

部署一个单体应用往往不是一件简单的事情，但总体上来说还是一个比较直观的操作，因为毕竟只有一个应用实体需要被部署。你需要考虑的只是如何在负载均衡器后面运行这个应用的多份实例。

然而，部署基于微服务的应用程序就要复杂得多。通常应用由各种异构的语言和框架开发的数十甚至上百个服务组成，有很多动态的部分需要被考虑。图1-15展示了跟部署有关的一些模式。

传统（手工）方式的应用程序部署，也就是把应用程序（如WAR文件）复制到服务器上，这样的做法不再适用于微服务架构了。你需要一个高度自动化部署的基础设施。理想情况下，你需要有一个部署平台，包括一个简单的界面（命令行或者图形用户界面都可以）来部署和管理这些服务。这些部署平台往往都是基于虚拟机、容器或者Serverless技术的。我在第12章会详细介绍这些部署方式的差异。

![image-20221006140905477](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006140905477.png)

#### 可观测性的相关模式

**应用运维的一项重要工作就是搞明白应用在运行时的一些行为，同时能够根据错误的请求或者高延迟等故障进行诊断排错**。理解和诊断一个单体应用并不是一项容易的工作，但毕竟它的请求和处理都是针对一个实例，以相对简单的方式完成的。每一个人站请求都通过负载均衡指派到了一个具体的应用实例，然后实例向数据库发起若干请求，最后返回结果。如果需要，你可以通过查阅该应用实例的日志文件的方式理解整个请求的过程。

与之相反，理解和诊断微服务架构下发生的问题往往是一项令人头疼的工作。在把最终结果返回给客户端之前，一项请求往往会在多个服务之间跳转，也就是说光看一个日志文件是解决不了问题的。有关高延迟的问题就更加令人抓狂，因为这会涉及多种可能的原因。

以下模式可用来设计具备可观测性的服务：

- 健康检查API:可以返回服务健康状态的API。
- 日志聚合：把服务产生的日志写入一个集中式的日志服务器，这个服务器可以提供日志搜索，也可以根据日志情况触发报警。
- 分布式追踪：为每一个外部请求分配一个唯一的D,用于在各个服务之间追踪外部请求。
- 异常跟踪：把程序异常发送到异常跟踪服务，这个服务会排除重复异常，给开发者发送告警并且跟踪每一个异常的解决。
- 应用指标：供维护使用的指标，例如计数器等，导出到指标服务器。
- 审计日志：记录用户的行为。

#### 实现服务自动化测试的相关模式

微服务架构让单一的服务测试变得容易，因为相比单体应用，每一个服务都变得更小了。但与此同时，重要的是测试不同的服务是否协同工作，同时避免使用复杂、缓慢和脆弱的端到端测试来测试多个服务。以下是通过单独测试服务来简化测试的模式：

- 消费端驱动的契约测试：验证服务满足客户端所期望的功能。
- 消费端契约测试：验证服务的客户端可以正常与服务通信。
- 服务组件测试：在隔离的环境中测试服务。

在第9章和第10章中，我们会介绍这些跟测试有关的模式。

#### 解决基础设施和边界问题的相关模式

**在微服务架构中，每个服务都必须实现许多跟基础设施相关的功能，包括可观测性模式和服务发现模式**。还必须实现外部化配置模式，该模式在运行时向服务提供数据库凭据等配置参数。在开发新服务时，从头开始重新实现这些功能是在太费时间了。一种更好的方法是在处理这些问题时应用微服务基底©模式，在这样的现有成熟的基底框架之上构建服务。第11章将详细描述这些模式。

#### 安全相关的模式

在微服务架构中，用户身份验证的工作通常由API Gateway完成。然后，它必须将有关用户的信息（例如身份和角色）传递给它调用的服务。常见的解决方案是应用访问令牌模式。API Gateway将访问令牌（例如JWT,即JSON Web令牌）传递给服务，这些服务可以验证令牌并获取有关用户的信息。第11章将更详细地讨论访问令牌模式。不必惊讶，这些模式的目的就是解决采用新架构之后浮现的种种问题。为了成功地开发软件，你必须选择合适的架构。但架构不是你唯一需要关注的领域，你还必须思考流程和组织。

## 第二章 服务的拆分策略

微服务架构的关键挑战是将应用程序功能分解为服务。因此，架构设计的第一个也是最重要的工作就是服务的定义。

### 微服务架构

#### 软件架构

> 计算机系统的软件架构是构建这个系统所需要的一组结构，包括软件元素、它们之间的关系以及两者的属性。

这显然是一个非常抽象的定义。但其实质是**应用程序的架构是将软件分解为元素(element)和这些元素之间的关系(relation)**。由于以下两个原因，分解很重要：

- 它**促进了劳动和知识的分工**。它使具有特定专业知识的人们（或多个团队）能够就应用程序高效地协同工作。
- 它**定义了软件元素的交互方式**。将软件分解成元素以及定义这些元素之间的关系，决定了软件的能力。

#### 软件架构的 4+1 视图

![image-20221006142955334](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006142955334.png)

每个视图的目的如下：

- 逻辑视图：开发人员创建的软件元素。在面向对象的语言中，这些元素是类和包。它们之间的关系是类和包之间的关系，包括继承、关联和依赖。
- 实现视图：构建编译系统的输出。此视图由表示打包代码的模块和组件组成，组件是由一个或多个模块组成的可执行或可部署单元。在Java中，模块是JAR文件，组件通常是WAR文件或可执行JAR文件。它们之间的关系包括模块之间的依赖关系以及组件和模块之间的组合关系。
- 进程视图：运行时的组件。每个元素都是一个进程，进程之间的关系代表进程间通信。
- 部署视图：进程如何映射到机器。此视图中的元素由（物理或虚拟）计算机和进程组成。机器之间的关系代表网络。该视图还描述了进程和机器之间的关系。

除了这四个视图以外，**4+1中的+1是指场景，它负责把视图串联在一起。每个场景负责描述在一个视图中的多个架构元素如何协作，以完成一个请求**。例如，在逻辑视图中的场景，展现了类是如何协作的。同样，在进程视图中的场景，展现了进程是如何协作的。4+1视图是描述应用程序架构的绝佳方式。每一个视图都描述了架构的一个重要侧面。场景把视图中的元素如何协作串联在一起。现在我们来看看为什么架构是如此重要。

#### 架构的风格

##### 分层式架构风格

##### 六边形架构

##### 单体架构

单体架构是一种架构风格，它的实现视图是单个组件：单个可执行文件或WAR文件。这个定义并没有说明其他的视图。例如，单体应用程序可以具有六边形架构风格的逻辑视图。

##### 微服务架构

微服务架构也是一种架构风格。它的实现视图由多个组件构成：一组可执行文件或WAR文件。它的组件是服务，连接器是使这些服务能够协作的通信协议。每个服务都有自己的逻辑视图架构，通常也是六边形架构。

> 模式：微服务架构
>
> 将应用程序构建为松耦合、可独立部署的一组服务。

微服务架构强加的一个关键约束是服务松耦合。因此，服务之间的协作方式存在一定限制。为了解释这些限制，我将尝试定义什么是服务，解释松耦合意味着什么，并告诉你为什么这很重要。

**什么是服务**

**服务是一个单一的、可独立部署的软件组件，它实现了一些有用的功能**。图2-4显示了服务的外部视图，在此示例中是Order Service。服务具有API,为其客户端提供对功能的访问。有两种类型的操作：命令和查询。API由命令、查询和事件组成。命令如createorder()执行操作并更新数据。查询，如findOrderById()检索数据。服务还发布由其客户端使用的事件，例如OrderCreated。

**服务的API封装了其内部实现**。与单体架构不同，开发人员无法绕过服务的API直接访问服务内部的方法或数据。因此，微服务架构强制实现了应用程序的模块化。

微服务架构中的每项服务都有自己的架构，可能还有独特的技术栈。但是典型的服务往往都具有六边形架构。其API由与服务的业务逻辑交互的适配器实现。操作适配器调用业务逻辑，事件适配器对外发布业务逻辑产生的事件。

![image-20221006144816083](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006144816083.png)

一个基本要求是服务具有API并且可以独立部署。

### 为应用程序定义微服务架构

那么如何定义一个微服务架构呢？跟所有的软件开发过程一样，一开始我们需要拿到领域专家或者现有应用的需求文档。跟所有的软件开发一样，定义架构也是一项艺术而非技术。本节我们将介绍一种定义应用程序架构的三步式流程，如图2-5所示。世界上并没有一个机械化的流程可以遵循，然后指望这个流程输出一个合理的架构。我们只能介绍一个大概的方法，现实世界中，这是一个不断迭代和持续创新的过程。

![image-20221006150422417](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006150422417.png)

#### 识别系统操作

**定义应用程序架构的第一步是定义系统操作**。起点是应用程序的需求，包括用户故事及其相关的用户场景（请注意，这些与架构场景不同）。使用图2-6中所示的两步式流程识别和定义系统操作。这个流程的灵感来自Craig Larman的名著《Applying UML and Patterns》(PrenticeHall,2004)中介绍的面向对象设计过程（www.craiglarman.com/wiki/index.php?title--BookApplying_UML_and_Patterns))。**第一步创建由关键类组成的抽象领域模型，这些关键类提供用于描述系统操作的词汇表。第二步确定系统操作，并根据领域模型描述每个系统操作的行为**。

![image-20221006150939463](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006150939463.png)

**领域模型主要源自用户故事中提及的名词，系统操作主要来自用户故事中提及的动词**。你还可以使用名为事件风暴(Event Storming)的技术定义领域模型，我将在第5章中讨论。每个系统操作的行为都是根据它对一个或多个领域对象的影响以及它们之间的关系来描述的。**系统操作可以创建、更新或删除领域对象，以及创建或破坏它们之间的关系**。我们来看看如何定义抽象领域模型。之后，我将根据领域模型定义系统操作。

#### 应用服务的识别

##### 根据业务能力进行服务拆分

创建微服务架构的策略之一就是采用业务能力进行服务拆分。业务能力是一个来自于业务架构建模的术语。**业务能力是指一些能够为公司（或组织）产生价值的商业活动**。特定业务的业务能力取决于这个业务的类型。例如，保险公司业务能力通常包括承保、理赔管理、账务和合规等。在线商店的业务能力包括：订单管理、库存管理和发货，等等。

##### 根据子域进行服务拆分

**领域模型以解决具体问题的方式包含了一个领域内的知识**。它定义了当前领域相关团队的词汇表，DDD也称之为通用语言(Ubiquitous language)。领域模型会被紧密地映射到应用的设计和实现环节。在微服务架构的设计层面，DDD有两个特别重要的概念，子域和限界上下文。

DDD把领域模型的边界称为限界上下文(bounded context)。限界上下文包括实现这个模型的代码集合。当使用微服务架构时，**每一个限界上下文对应一个或者一组服务**。换一种说法，我们可以通过DDD的方式定义子域，并把子域对应为每一个服务，这样就完成了微服务架构的设计工作。图2-9展示了子域和服务之间的映射，每一个子域都有属于它们自己的领域模型。

![image-20221006152730170](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006152730170.png)

按子域分解和按业务能力分解是定义应用程序的微服务架构的两种主要模式。但是，也有一些有用的拆分指导原则源于面向对象的设计。我们来详细讨论这些原则。

##### 拆分原则

**单一职责原则**

类所承载的每一个职责都是对它进行修改的潜在原因。如果一个类承载了多个职责，并且互相之间的修改是独立的，那么这个类就会变得非常不稳定。遵照SRP原则，你所定义的每一个类都应该只有一个职责，因此也就只有一个理由对它进行修改。

**闭包原则**（CCP）

在包中包含的所有类应该是对同类的变化的一个集合，也就是说，如果对包做出修改，需要调整的类应该都在这个包之内。

这就意味着，**如果由于某些原因，两个类的修改必须耦合先后发生，那么就应该把它们放在同一个包内**。也许，这些类实现了一些特定的业务规则的不同方面。这样做的目标是当业务规则发生变化时，开发者只需要对一个交付包做出修改，而不是大规模地修改（和重新编译)整个应用。采用闭包原则，极大地改善了应用程序的可维护性。

在微服务架构下采用CCP原则，这样我们就能把根据同样原因进行变化的服务放在一个组件内。这样做可以控制服务的数量，当需求发生变化时，变更和部署也更加容易。理想情况下，一个变更只会影响一个团队和一个服务。CCP是解决分布式单体这种可怕的反模式的法宝。

##### 拆分单体应用为服务的难点

从表面上看，通过定义与业务能力或子域相对应的服务来创建微服务架构的策略看起来很简单。但是，你可能会遇到几个障碍：

- 网络延迟。
- 同步进程间通信导致可用性降低。
- 在服务之间维持数据一致性。
- 获取一致的数据视图。
- 上帝类阻碍了拆分。

#### 定义服务API

存在服务API操作有以下两个原因：首先，某些操作对应于系统操作。它们由外部客户端调用，也可能由其他服务调用。另次，存在一些其他操作用以支持服务之间的协作。这些操作仅由其他服务调用。

定义服务API的起点是将每个系统操作映射到服务。之后确定服务是否需要与其他服务协作以实现系统操作。如果需要协作，我们将确定其他服务必须提供哪些API才能支持协作。首先来看一下如何将系统操作分配给服务。

**把系统操作分配给服务**



**确定支持服务协作所需要的API**



## 第三章 微服务架构中的进程间通信

### 进程间通信

有很多进程间通信技术可供开发者选择。服务可以使用基于同步请求/响应的通信机制，例如HTTP REST或gRPC。另外，也可以使用异步的基于消息的通信机制，比如AMQP或STOMP。消息的格式也不尽相同。服务可以使用具备可读性的格式，比如基于文本的JSON或XML。也可以使用更加高效的、基于二进制的Avro或Protocol Buffers格式。

#### 交互方式

在为服务的API选择进程间通信机制之前，首先考虑服务与其客户端的交互方式是非常重要的。考虑交互方式将有助于你专注于需求，并避免陷入特定进程间通信技术的细节。

有多种客户端与服务的交互方式。如表3-1所示，它们可以分为两个维度。

**第一个维度关注的是一对一和一对多**。

- 一对一：每个客户端请求由一个服务实例来处理。
- 一对多：每个客户端请求由多个服务实例来处理。

**交互方式的第二个维度关注的是同步和异步**。

- 同步模式：客户端请求需要服务端实时响应，客户端等待响应时可能导致堵塞。
- 异步模式：客户端请求不会阻塞进程，服务端的响应可以是非实时的。

![image-20221006164143279](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006164143279.png)

一对一的交互方式有以下几种类型。

- 请求/响应：一个客户端向服务端发起请求，等待响应；客户端期望服务端很快就会发送响应。在一个基于线程的应用中，等待过程可能造成线程阻塞。这样的方式会导致服务的紧耦合。
- 异步请求/响应：客户端发送请求到服务端，服务端异步响应请求。客户端在等待响应时不会阻塞线程，因为服务端的响应不会马上就返回。
- 单向通知：客户端的请求发送到服务端，但是并不期望服务端做出任何响应。

一对多的交互方式有以下几种类型。

- 发布/订阅方式：客户端发布通知消息，被零个或者多个感兴趣的服务订阅。
- 发布/异步响应方式：客户端发布请求消息，然后等待从感兴趣的服务发回的响应。

#### 在微服务架构中定义API

API或接口是软件开发的中心。应用是由模块构成的，每个模块都有接口，这些接口定义了模块的客户端可以调用若干操作。一个设计良好的接口会在暴露有用功能同时隐藏实现的细节。因此，这些实现的细节可以被修改，而接口保持不变，这样就不会对客户端产生影响。

API和接口在微服务架构中同样重要。**服务的API是服务与其客户端之间的契约**(contract).。如第2章所述，服务的API由客户端结构可以调用的方法和服务发布的事件组成。方法具备名称、参数和返回类型。事件具有一个类型和一组字段，发布到消息通道。

#### API的演变



#### 消息的格式

进程间通信的本质是交换消息。消息通常包括数据，因此一个重要的设计决策就是这些数据的格式。消息格式的选择会对进程间通信的效率、API的可用性和可演化性产生影响。如果你正在使用一个类似HTTP的消息系统或者协议，那么你需要选择消息的格式。有些进程间通信机制，如我们马上就会讲到的gRPC,已经指定了消息格式。在这两种情况下，使用跨语言的消息格式尤为重要。即使我们今天使用同一种编程语言来开发微服务应用，那也很有可能在今后会扩展到其他的编程语言。我们不应该使用类似Java序列化这样跟编程语言强相关的消息格式。**消息的格式可以分为两大类：文本和二进制**。我们来逐一分析。

### 基于同步远程过程调用模式的通信

当使用基于远程过程调用（P)的进程间通信机制时，客户端向服务发送请求，服务处理该请求并发回响应。有些客户端可能会处在堵塞状态并等待响应，而其他客户端可能会有个响应式的非阻塞架构。但与使用消息机制时不同，客户端假定响应将及时到达。

图3-1显示了远程过程调用的工作原理。**客户端中的业务逻辑调用代理接口，这个接口由远程过程调用代理适配器类实现**。远程过程调用代理向服务发出请求。该请求由远程过程周用服务器适配器类处理，该类通过接口调用服务的业务逻辑。然后它将回复发送回远程过程调用代理，该代理将结果返回给客户端的业务逻辑。

![image-20221006165515261](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006165515261.png)

**代理接口通常封装底层通信协议**。有许多协议可供选择

#### 使用断路器模式处理局部故障

分布式系统中，当服务试图向另一个服务发送同步请求时，永远都面临着局部故障的风险。因为客户端和服务端是独立的进程，服务端很有可能无法在有限的时间内对客户端的请求做出响应。服务端可能因为故障或维护的原因而暂停。或者，服务端也可能因为过载而对请求的响应变得极其缓慢。

客户端等待响应被阻塞，这可能带来的麻烦就是在其他客户端甚至使用服务的第三方应用之间传导，并导致服务中断。

> 模式：断路器
>
> 这是一个远程过程调用的代理，在连续失败次数超过指定阈值后的一段时间内，这个代理会立即拒绝其他调用。

要通过合理地设计服务来防止在整个应用程序中故障的传导和扩散，这是至关重要的。解决这个问题分为两部分：

- 必须让远程过程调用代理（例如OrderServiceProxy)有正确处理无响应服务的能力。
- 需要决定如何从失败的远程服务中恢复。

首先，我们将看看如何编写健壮的远程过程调用代理。开发可靠的远程过程调用代理 

##### 开发可靠的远程过程调用代理



##### 从服务失效故障中恢复



#### 使用服务发现

服务实例启动和停止时，服务发现机制会更新服务注册表。当客户端调用服务时，服务发现机制会查询服务注册表以获取可用服务实例的列表，并将请求路由到其中一个服务实例。

实现服务发现有以下两种主要方式：

- 服务及其客户直接与服务注册表交互。
- 通过部署基础设施来处理服务发现。（我将在第12章中详细讨论这一点。）

##### 应用层服务发现模式

实现服务发现的一种方法是应用程序的服务及其客户端与服务注册表进行交互。图3-5显示了它的工作原理。服务实例使用服务注册表注册其网络位置。客户端首先通过查询服务注册表获取服务实例列表来调用服务，然后它向其中一个实例发送请求。

![image-20221006173711393](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006173711393.png)

这种服务发现方法是两种模式的组合。**第一种模式是自注册模式**。服务实例调用服务注册表的注册API来注册其网络位置。它还可以提供运行状况检查URL,在第11章中有更详细的描述。运行状况检查URL是一个API端点，服务注册表会定期调用该端点来验证服务实例是否正常且可用于处理请求。服务注册表还可能要求服务实例定期调用“心跳”API以防止其注册过期。

> 模式：自注册
>
> 服务实例向服务注册表注册自己。

第二种模式是**客户端发现模式**。当客户端想要调用服务时，它会查询服务注册表以获取服务实例的列表。为了提高性能，客户端可能会缓存服务实例。然后，服客户端使用负载平衡算法（例如循环或随机）来选择服务实例。然后它向选择的服务实例发出请求。

> 模式：客户端发现客户端从服务注册表检索可用服务实例的列表，并在它们之间进行负载平衡。

应用层服务发现的一个**好处是它可以处理多平台部署的问题**（服务发现机制与具体的部署平台无关)。例如，想象一下，你在Kubernetes上只部署了一些服务（将在第12章中讨论过)，其余服务在遗留环境中运行。在这种情况下，使用Eureka的应用层服务发现同时适用于两种环境，而基于Kubernetes的服务发现仅能用于部署在Kubernetes平台之上的部分服务。

应用层服务发现的一个**弊端是：你需要为你使用的每种编程语言（可能还有框架）提供服务发现库**。Spring Cloud只能帮助Spring开发人员。如果你正在使用其他Java框架或非JVM语言（如Node.js或GoLang),则必须找到其他一些服务发现框架。应用层服务发现的另一个弊端是开发者负责设置和管理服务注册表，这会分散一定的精力。因此，**最好使用部署基础设施提供的服务发现机制**。

##### 平台层服务发现模式

在第l2章中，你将了解许多现代部署平台（如Docker和Kubernetes)都具有内置的服务注册表和服务发现机制。部署平台为每个服务提供DNS名称、虚拟IP(VIP)地址和解析为VIP地址的DNS名称。客户端向DNS名称和VIP发出请求，部署平台自动将请求路由到其中一个可用服务实例。因此，**服务注册、服务发现和请求路由完全由部署平台处理**。图3-6显示了它的工作原理。

![image-20221006205828719](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006205828719.png)

部署平台包括一个服务注册表，用于跟踪已部署服务的P地址。在此示例中，客户端使用DNS名称order-service访问Order Service,该服务解析为虚拟P地址10.1.3.4。部署平台会自动在Order Service的三个实例之间对请求进行负载均衡。

这种方法是以下两种模式的组合。

- 第三方注册模式：由第三方负责（称为注册服务器，通常是部署平台的一部分）处理注册，而不是服务本身向服务注册表注册自己。
- 服务端发现模式：客户端不再需要查询服务注册表，而是向DNS名称发出请求，对该DNS名称的请求被解析到路由器，路由器查询服务注册表并对请求进行负载均衡。

> 模式：第三方注册
>
> 服务实例由第三方自动注册到服务注册表。

> 模式：服务端发现
>
> 客户端向路由器发出请求，路由器负责服务发现。

由平台提供服务发现机制的主要好处是**服务发现的所有方面都完全由部署平台处理**。服务和客户端都不包含任何服务发现代码。因此，无论使用哪种语言或框架，服务发现机制都可供所有服务和客户使用。

平台提供服务发现机制的一个**弊端是它仅限于支持使用该平台部署的服务**。例如，如前所述，在描述应用程序级别发现时，基于Kubernetes的发现仅适用于在Kubernetes上运行的服务。尽管存在此限制，我建议尽可能使用平台提供的服务发现。

现在我们已经学习了使用REST或gRPC的同步进程间通信，让我们来看看替代方案：基于异步消息模式的通信。

### 基于异步消息模式的通信

使用消息机制时，**服务之间的通信采用异步交换消息的方式完成**。基于消息机制的应用程序通常使用消息代理，它充当服务之间的中介。另一种选择是使用无代理架构，通过直接向服务发送消息来执行服务请求。服务客户端通过向服务发送消息来发出请求。如果希望服务实例回复，服务将通过向客户端发送单独的消息的方式来实现。由于通信是异步的，因此客户端不会堵塞和等待回复。相反，客户端都假定回复不会马上就收到。

> 模式：消息
>
> 客户端使用异步消息调用服务。

#### 什么是消息传递

**消息通过消息通道进行交换**。发送方（应用程序或服务）将消息写入通道，接收方（应用程序或服务）从通道读取消息。让我们先学习消息，然后学习通道。

##### 关于消息

**消息由消息头部和消息主体组成**（www,enterpriseintegrationpatterns.com/Message.html)。**消息头部是名称与值对的集合，描述正在发送的数据的元数据**。除了消息发送者提供的名称与值对之外，消息头部还包含其他信息，例如发件人或消息传递基础设施生成的唯一消息D,以及可选的返回地址，该地址指定发送回复的消息通道。**消息正文是以文本或二进制格式发送的数据**。

有以下几种不同类型的消息。

- 文档：仅包含数据的通用消息。接收者决定如何解释它。对命令式消息的回复是文档消息的一种使用场景。
- 命令：一条等同于RPC请求的消息。它指定要调用的操作及其参数。
- 事件：表示发送方这一端发生了重要的事件。事件通常是领域事件，表示领域对象(如Order或Customer)的状态更改。

##### 关于消息通道

如图3-7所示，消息通过消息通道进行交换(www.enterpriseintegrationpatterns.com/MessageChannel.html)。发送方中的业务逻辑调用发送端接口，该接口封装底层通信机制。发送端由消息发送适配器类实现，该消息发送适配器类通过消息通道向接收器发送消息。消息通道是消息传递基础设施的抽象。调用接收器中的消息处理程序适配器类来处理消息。它调用接收方业务逻辑实现的接收端接口。任意数量的发送方都可以向通道发送消息。类似地，任何数量的接收方都可以从通道接收消息。

![image-20221006211218330](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006211218330.png)

有以下两种类型的消息通道：点对点(www.enterpriseintegrationpatterns.com/PointToPointChannel..html)和发布-订阅(www.enterpriseintegrationpatterns..com/PublishSubscribeChannel.html)。

- 点对点通道向正在从通道读取的一个消费者传递消息。服务使用点对点通道来实现前面描述的一对一交互方式。例如，命令式消息通常通过点对点通道发送。
- 发布-订阅通道将一条消息发给所有订阅的接收方。服务使用发布-订阅通道来实现前面描述的一对多交互方式。例如，事件式消息通常通过发布-订阅通道发送。

#### 使用消息机制实现交互方式

消息机制的一个有价值的特性是它足够灵活，可以支持3.1.1节中描述的所有交互方式。一些交互方式通过消息机制直接实现。其他必须在消息机制之上实现。

##### 实现请求/响应和异步请求/响应

**当客户端和服务使用请求/响应或异步请求/响应进行交互时，客户端会发送请求，服务会发回回复**。两种交互方式之间的区别在于，对于请求/响应，客户端期望服务立即响应，而对于异步请求/响应，则没有这样的期望。消息机制本质上是异步的，因此只提供异步请求/响应。但客户端可能会堵塞，直到收到回复。

**客户端和服务端通过交换一对消息来实现异步请求/响应方式的交互**。如图3-8所示，客户端发送命令式消息，该消息指定要对服务执行的操作和参数，这些内容通过服务拥有的点对点消息通道传递。该服务处理请求，并将包含结果的回复消息发送到客户端拥有的点对点通道。

![image-20221008103948562](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008103948562.png)

##### 实现单向通知



##### 实现发布/订阅

消息机制内置了对发布/订阅交互方式的支持。客户端将消息发布到由多个接收方读取的发布/订阅通道。如第4章和第5章所述，服务使用发布/订阅来发布领域事件，领域事件代表领域对象的更改。发布领域事件的服务拥有自己的发布/订阅通道，通道的名称往往派生自领域类。例如，Order Service将Order事件发布到Order通道，DeliveryService将Delivery事件发布到Delivery通道。对特定领域对象的事件感兴趣的服务只需订阅相应的通道。

##### 实现发布/异步响应



#### 为基于消息机制的服务API创建API规范

服务的异步API包含供客户端调用的操作和由服务对外发布的事件。这些API的记录方式不尽相同。让我们从操作开始逐一分析。

可以使用以下两种不同交互方式之一调用服务的操作：

![image-20221008105303974](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008105303974.png)

- **请求/异步响应式API**：包括服务的命令消息通道、服务接受的命令式消息的具体类型和格式，以及服务发送的回复消息的类型和格式。
- **单向通知式API**：包括服务的命令消息通道，以及服务接受的命令式消息的具体类型和格式。

服务可以对异步请求/响应和单向通知使用相同的请求通道。

##### 记录事件

发布服务还可以使用发布/订阅的方式对外发布事件。此API风格的规范包括事件通道以及服务发布到通道的事件式消息的类型和格式。消息和消息通道模型是一种很好的抽象，也是设计服务异步API的好方法。但是，为了实现服务，你需要选择具体的消息传递技术并确定如何使用它们的能力来实现设计。让我们看一看所涉及的内容。

#### 使用消息代理

**基于消息传递的应用程序通常使用消息代理，即服务通信的基础设施服务**。但基于消息代理的架构并不是唯一的消息架构。你还可以使用基于无代理的消息传递架构，其中服务直接相互通信。这两种方法（如图3-10所示）具有不同的利弊，但通常基于代理的架构是一种更好的方法。

![image-20221008163052422](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008163052422.png)

##### 无代理消息

在无代理的架构中，服务可以直接交换消息。ZeroMQ(http:/zeromq.org)是一种流行的无代理消息技术。它既是规范，也是一组适用于不同编程语言的库。它支持各种传输协议，包括TCP、UNIX风格的套接字和多播。

##### 基于代理的消息

消息代理是所有消息的中介节点。发送方将消息写入消息代理，消息代理将消息发送给接收方。使用消息代理的一个重要好处是发送方不需要知道接收方的网络位置。另一个好处是消息代理缓冲消息，直到接收方能够处理它们。

有许多消息代理可供选择。流行的开源消息代理包括：

- Apache ActiveMQ (http://activemq.apache.org)
- RabbitMQ(https://www.rabbitmq.com)。
- Apache Kafka (http://kafka.apache.org).

还有基于云的消息服务，例如AWS Kinesis（https:/aws.amazon.com/kinesis)和AWS SQS (https://aws.amazon.com/sqs/).

#### 处理并发和消息顺序

**挑战之一是如何在保留消息顺序的同时，横向扩展多个接收方的实例**。为了同时处理消息，拥有多个实例是一个常见的要求。而且，即使单个服务实例也可能使用线程来同时处理多个消息。使用多个线程和服务实例来并发处理消息可以提高应用程序的吞吐量。但同时处理消息的挑战是**确保每个消息只被处理一次，并且是按照它们发送的顺序来处理的**。

例如，假设有3个相同的接收方实例从同一个点对点通道读取消息，发送方按顺序发布了Order Created、Order Updated和Order Cancelled这3个事件消息。简单的消息实现可能就会同时将每个消息给不同的接收方。若由于网络问题或JVM垃圾收集等原因导致延迟，消息可能没有按照它们发出时的顺序被处理，这将导致奇怪的行为。理论上，服务实例可能会在另一个服务处理Order Created消息之前处理Order Cancelled消息。

现代消息代理（如Apache Kafka和AWS Kinesis)使用的常见解决方案是使用分片（分区)通道。图3-11展示了这是如何工作的。该解决方案分为三个部分。

1. 分片通道由两个或多个分片组成，每个分片的行为类似于一个通道。
2. 发送方在消息头部指定分片键，通常是任意字符串或字节序列。
3. 消息代理使用分片键将消息分配给特定的分片。例如，它可以通过计算分片键的散列来选择分片。

![image-20221008164907771](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008164907771.png)

#### 处理重复消息

使用消息机制时必须解决的另一个挑战是**处理重复消息**。理想情况下，消息代理应该只传递一次消息，但保证有且仅有一次的消息传递通常成本很高。相反，大多数消息代理承诺至少成功传递一次消息。

当系统正常工作时，保证传递的消息代理只会传递一次消息。但是客户端、网络或消息代理的故障可能导致消息被多次传递。假设客户端在处理消息后、发送确认消息之前，它的数据库崩溃了，这时消息代理将再次发送未确认的消息，在数据库重新启动时向该客户端或客户端的另一个副本发送。

理想情况下，你应该使用消息代理，在重新传递消息时保留排序。想象一下，客户端处理Order Created事件，然后紧接着收到了同一Order的Order Cancelled事件，但这时候Order Created事件还没有得到确认。消息代理应重新投递Order Created和OrderCancelled事件。如果它仅重新发送Order Created,客户可以撤回Order的取消。处理重复消息有以下两种不同的方法。

- 编写幂等消息处理程序。
- 跟踪消息并丢弃重复项。

##### 编写幂等消息

处理器如果应用程序处理消息的逻辑是满足幂等的，那么重复的消息就是无害的。所谓应用程序的幂等性，是指即使这个应用被相同输入参数多次重复调用时，也不会产生额外的效果。例如，取消一个已经被取消的订单，就是一个幂等性操作。同样，创建一个已经存在的订单操作也必是这样。满足幂等的消息处理程序可以被放心地执行多次（而不会引起错误的结果)只要消息代理在重新传递消息时保持相同的消息顺序。

不幸的是，应用程序逻辑通常不是幂等的。或者你可能正在使用消息代理，该消息代理在重新传递消息时不会保留排序。重复或无序消息可能会导致错误。在这种情况下，你必须**编写跟踪消息并丢弃重复消息的消息处理程序**。

##### 跟踪消息并丢弃重复消息

例如，考虑一个授权消费者信用卡的消息处理程序。它必须为每个订单仅执行一次信用卡授权操作。这段应用程序逻辑在每次调用时都会产生不同的效果。如果重复消息导致消息处理程序多次执行该逻辑，则应用程序的行为将不正确。执行此类应用程序逻辑的消息处理程序必须通过检测和丢弃重复消息而成为幂等的。

一个简单的解决方案是消息接收方使用message id跟踪它已处理的消息并丢弃任何重复项。例如，它可以存储它在数据库表中使用的每条消息的message id.。图3-12显示了如何使用专用表执行此操作。

![image-20221008165646785](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008165646785.png)

当接收方处理消息时，它将消息的message id作为创建和更新业务实体的事务的一部分记录在数据库表中。在此示例中，接收方将包含message id的行插人PROCESSEDMESSAGES表。如果消息是重复的，则INSERT将失败，接收方可以选择丢弃该消息。

另一个选项是**消息处理程序在应用程序表**，而不是专用表中记录message id。当使用具有受限事务模型的NoSQL数据库时，此方法特别有用，因为NoSQL数据库通常不支持将针对两个表的更新作为数据库的事务。第7章将介绍这种方法的一个例子。

#### 事务性消息

**服务通常需要在更新数据库的事务中发布消息**。例如，在本书中，你将看到在创建或更新业务实体时发布领域事件的例子。**数据库更新和消息发送都必须在事务中进行**。否则，服务可能会更新数据库，然后在发送消息之前崩溃。如果服务不以原子方式执行这两个操作，则类似的故障可能使系统处于不一致状态。

##### 使用数据库表作为消息队列

我们假设你的应用程序正在使用关系型数据库。可靠地发布消息的直接方法是应用事务性发件箱模式。此模式使用数据库表作为临时消息队列。如图3-13所示，发送消息的服务有一个OUTBOX数据库表。作为创建、更新和删除业务对象的数据库事务的一部分，服务通过将消息插人到OUTBOX表中来发送消息。这样可以保证原子性，因为这是本地的ACID事务。

![image-20221008170224376](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008170224376.png)

OUTBOX表充当临时消息队列。MessageRelay是一个读取OUTBOX表并将消息发布到消息代理的组件。

> 模式：事务性发件箱
>
> 通过将事件或消息保存在数据库的OUTBOX表中，将其作为数据库事务的一部分发布。

##### 通过轮询模式发布事件

**如果应用程序使用关系型数据库**，则对外发布插人OUTBOX表的消息的一种非常简单的方法是让MessageRelay在表中轮询未发布的消息。它定期查询表：

> 模式：轮询发布
>
> 数据通过轮询数据库中的发件箱来发布消息。

轮询数据库是一种在小规模下运行良好的简单方法。其弊端是**经常轮询数据库可能造成昂贵的开销**（导致数据库性能下降）。此外，你是否可以将此方法与NoSQL数据库一起使用取决于NoSQL数据库支持的查询功能。这是因为应用程序必须查询业务实体，而不是查询OUTBOX表，这可能会无法有效地执行。由于这些弊端和限制，通常在某些情况下，更好的办法是使用更复杂和高性能的方法，来拖尾(tailing)数据库事务日志。

##### 使用事务日志拖尾模式发布事件

更加复杂的实现方式，是**让MessageRelay拖尾数据库的事务日志文件**（也称为提交日志)。每次应用程序提交到数据库的更新都对应着数据库事务日志中的一个条目。事务日志挖掘器可以读取事务日志，把每条跟消息有关的记录发送给消息代理。图3-14展示了这个方案的具体实现方式。

Transaction-Log-Miner读取事务日志条目。它将对应于插人消息的每个相关日志条目转换为消息，并将该消息发布到消息代理。此方法可用于发布写人关系型数据库中的OUTBOX表的消息或附加到NoSQL数据库中的记录的消息。

> 模式：事务日志拖尾
>
> 通过拖尾事务日志发布对数据库所做的更改。

![image-20221008170832856](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008170832856.png)

### 使用异步消息提高可用性

#### 同步消息会降低可用性



#### 消除同步交互

##### 使用异步交互模式

**理想的情况是，所有的交互都应该使用本章之前所描述的异步交互**。例如，让我们假设FTGO采用请求/异步响应的交互方式来创建订单。客户端可以通过向Order Service发送一个请求消息交换消息的方式创建订单。这个服务随即采用异步交换消息的方式跟其他服务通信完成订单的创建，并向客户端发回一个返回消息。图3-16展示了具体的设计。

![image-20221008210942790](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008210942790.png)

**客户端和服务端使用消息通道发送消息来实现异步通信**。这个交互过程中不存在堵塞等待响应的情况。

这样的架构非常有弹性，因为消息代理会一直缓存消息，直到有服务端接收并处理消息。然而，问题是**服务很多情况下都采用类似REST这样的同步通信协议的外部API,并且要求对请求立即做出响应**。

在这种情况下，我们可以采用复制数据的方式来提高可用性。我们看看如何实现。

##### 复制数据

**在请求处理环节中减少同步请求的另外一种办法，就是进行数据复制**。服务维护一个数据副本，这些数据是服务在处理请求时需要使用的。这些数据的源头会在数据变化时发出消息，服务订阅这些消息来确保数据副本的实时更新。例如，Order Service可以维护来自Consumer Service和Restaurant Service的数据副本。在这种情况下，Order Service可以在不与其他服务进行交互的情况下完成订单创建的请求。图3-17展示了具体的设计。

![image-20221008211339882](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008211339882.png)

Consumer Service和Restaurant Service在它们的数据发生变化时对外发布事件。Order Service服务订阅这些事件，并据此更新自己的数据副本。

在有些情况下，复制数据是一种有用的方式，第5章中还会有更具体的讨论，描述Order Service如何从Restaurant Service复制数据以验证菜单并定价。然而，**复制数据的一个弊端在于，有时候被复制的数据量巨大**，会导致效率低下。例如，让Order Service服务去维护一个Consumer Service的数据副本并不可行，因为数据量实在太大了。复制的另外一个弊端在于，复制数据并没有从根本上解决服务**如何更新其他服务所拥有的数据**这个问题。

解决该问题的一种方法是让服务暂缓与其他服务交互，直到它给客户端发送了响应。接下来我们将看看它是如何工作的。

##### 先返回响应，再完成处理

另外一种在请求处理环节消除同步通信的办法如下：

1. 仅使用本地的数据来完成请求的验证。

2. 更新数据库，包括向OUTBOX表插入消息。

3. 向客户端返回响应。

当处理请求时，服务并不需要与其他服务直接进行同步交互。取而代之的是，服务异步向其他的服务发送消息。这种方式确保了服务之间的松耦合。正如我们将在下一章看到的，这是通过Saga实现的。

例如，Order Service可以用这种方式创建一个未经验证(Pending)状态的订单，然后通过异步交互的方式直接跟其他服务通信来完成验证。图3-l8展示了createorder()被调用时发生的具体过程。

![image-20221008211827580](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008211827580.png)

事件的顺序是：

1.Order Service在PENDING状态下创建订单。

2.Order Service返回包含订单ID的响应给客户。

3.Order Service向Consumer Service发送ValidateConsumerInfo消息

4.Order Service向Restaurant Service发送ValidateorderDetails消息。

5.Consumer Service接收ValidateConsumerInfo消息，验证消费者是否可以下订单，并向Order Service发送ConsumerValidated消息。

6.Restaurant Service收到ValidateOrderDetails消息，验证菜单项是否有效以及餐馆是否可以交付订单的交付地址，并向Order Service发送OrderDetailsValidated消息。

7.order Service接收ConsumerValidated和OrderDetailsValidated,并将订单状态更改为VALIDATED。

8.…

Order Service可以按任意顺序接收ConsumerValidated和OrderDetailsValidated消息。它**通过更改订单状态来跟踪它首先收到的消息**。如果它首先收到ConsumerValidated,它会将订单状态更改为CONSUMER_VALIDATED;如果它首先收到OrderDetailsValidated消息，则会将其状态更改为ORDER_DETAILS_VALIDATED。Order Service在收到其他消息时将订单状态更改为VALIDATED.。

**订单验证后，Order Service完成订单创建过程的其余部分**，这些细节将在下一章中讨论。这种方法的优点在于，即使Consumer Service中断，Order Service仍然会创建订单并响应其客户。最终，Consumer Service将重新启动并处理任何排队的消息，并且验证订单。

**在完全处理请求之前响应服务的弊端是它使客户端更复杂**。例如，Order Service在返回响应时对新创建的订单的状态提供最低限度的保证。它会在验证订单并授权消费者的信用卡之前立即创建订单并返回。因此，为了使客户端知道订单是否已成功创建，要么必须定期轮询，要么Order Service必须向客户端发送通知消息。听起来很复杂，但是在许多情况下这是首选方法：特别是因为它还解决了我将在下一章中讨论的分布式事务管理问题。在第4章和第5章中，我将介绍Order Service如何使用这种方法。

## 第四章 使用Saga管理事务

ACID(原子性、一致性、隔离性和持久性)事务造成了一种错觉，让开发人员认为每个事务都具有对数据的独占访问权，这种错觉极大地简化了开发人员的工作。在微服务架构中，单个服务中的事务仍然可以使用ACID事务。然而，在对更新多个服务所拥有的数据的操作实现事务时，我们面临着新的挑战。**跨服务的操作必须使用所谓的Saga**（一种消息驱动的本地事务序列)来维护数据一致性，而不是ACID事务。**Saga的一个挑战在于只满足ACD(原子性、一致性和持久性)特性**，而缺乏传统ACD事务的隔离性。因此，应用程序必须使用所谓的对策(countermeasure),找到办法来防止或减少由于缺乏隔离而导致的并发异常。

分析协调Saga的两种不同方式：一种是协同式（choreography),Saga的参与方在没有集中控制器的情况下交换事件式消息；另外一种是编排式(orchestration),集中控制器告诉Saga参与方要执行的操作。我会讲解如何使用对策来防止或减少由于Saga之间缺乏隔离而导致的并发异常。最后，我会描述一个Saga的实现例子。让我们首先看一看在微服务架构中管理事务的挑战。

### 微服务架构下的事务管理

#### 微服务架构对分布式事务的需求



#### 分布式事务的挑战

**在多个服务、数据库和消息代理之间维持数据一致性的传统方式是采用分布式事务**。分布式事务管理的事实标准是X/Open Distributed Transaction Processing(DTP)Model(X/OpenXA,https::/en.wikipedia.org/wiki/X/Open XA)。**XA采用了两阶段提交(two phase commit,2PC)来保证事务中的有参与方同时完成提交，或者在失败时同时回滚**。应用程序的整个技术栈需要满足XA标准，包括符合XA要求的数据库、消息代理、数据库驱动、消息API,以及用来传播XA全局事务D的进程间通信机制。市面上绝大多数的SQL数据库和一部分消息代理满足XA标准。例如，Jave EE应用程序可以使用JTA来完成分布式事务。

#### 使用Saga模式维护数据一致性

Saga是一种在微服务架构中维护数据一致性的机制，它可以避免分布式事务所带来的问题。**一个Saga表示需要更新多个服务中数据的一个系统操作**。Saga由一连串的本地事务组成。每一个本地事务负责更新它所在服务的私有数据库，这些操作仍旧依赖于我们所熟悉的ACID事务框架和函数库。

> 模式：Saga
>
> 通过使用异步消息来协调一系列本地事务，从而维护多个服务之间的数据一致性。

系统操作启动了Saga的第一步。完成本地事务会触发下一个本地事务的执行。稍后在4.2节中，你将看到如何使用异步消息实现Saga步骤间的协调。异步消息的一个重要好处是它确保Saga的所有步骤都被执行，即使一个或多个Saga的参与方暂时不可用。

Saga在几个重要方面与ACID事务不同。正如我将在4.3节中详细描述的那样，它们缺少ACID事务的隔离性。此外，由于每个本地事务都提交了其更改，因此必须使用补偿事务回滚Saga。我将在本节后面详细讨论补偿事务。先来看一个例子。

##### 示例Saga：Create Order Saga

本章中使用的示例Saga是Create order Saga,如图4-2所示。Order Service使用此Saga实现createorder()操作。Saga的第一个本地事务由创建订单的外部请求启动。其他5个本地事务均由前一个完成触发。

![image-20221008213809361](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008213809361.png)

这个Saga包含了以下几个本地事务：

1. Order Service:创建一个处于APPROVAL PENDING状态的Order.

2. Consumer Service:验证当前订单中的消费者可以下单。

3. Kitchen Service:验证订单内容，并创建一个后厨工单Ticket,状态为CREATE PENDING

4. Accounting Service:对消费者提供的信用卡做授权操作。

5. Kitchen Service:把后厨工单Ticket的状态改为AWAITING ACCEPTANCE。

6. Order Service:把Order的状态改为APPROVED。

稍后在4.2节中，我将介绍参与Saga的服务如何使用异步消息进行通信。当本地事务完成时，服务会发布消息。然后，此消息将触发Sga中的下一个步骤。使用消息不仅可以确保Saga参与方之间的松散耦合，还可以保证Saga完成。这是因为如果消息的接收方暂时不可用，则消息代理会缓存消息，直到消息可以被投递为止。从表面上看，Saga似乎很简单，但使用它们有一些挑战。一个挑战是Saga之间缺乏隔离。4.3节将描述如何处理这个问题。另一个挑战是在发生错误时的回滚更改。我们来看看如何做到这一点。

##### Saga使用补偿事务来回滚所做出的改变

传统ACID事务的一个重要特性是：如果业务逻辑检测到违反业务规则，可以轻松回滚事务。通过执行ROLLBACK语句，数据库可以撤销（回滚）目前为止所做的所有更改。遗憾的是，Saga无法自动回滚，因为每个步骤都会将其更改提交到本地数据库。这意味着，如果Create order Saga的第4个步（信用卡授权)失败，则FTG0应用程序必须明确撤销前三个步骤所做的更改。你必须编写所谓的补偿事务。

假设一个Saga的第$$n+1$$个事务失败了。必须撤销前n个事务的影响。从概念上讲，每个步骤 $$T_i$$ :都有一个相应的补偿事务$$C_i$$,它可以撤销$$T_i$$:的影响。要撤销前n个步骤的影响，Saga必须以相反的顺序执行每个C。步骤顺序为$$T_1...T_n,C_n...C_1,$$如图4-3所示。在这个例子中，$$T_{n+1}$$失败，这需要撤销步骤$$T_1...T_n$$ 。

![image-20221008214652648](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008214652648.png)

Saga按照正常事务的反向顺序来执行补偿事务：$$C_n...C_1$$的顺序机制与$$T_i$$的顺序机制并无差别。$$C_i$$执行完成后必须触发$$C_{i-1}$$的执行。

### Saga的协调模式

Saga的实现包含协调Saga步骤的逻辑。当通过系统命令启动Saga时，协调逻辑必须选择并通知第一个Saga参与方执行本地事务。一旦该事务完成，Saga协调选择并调用下一个Saga参与方。这个过程一直持续到Saga执行完所有步骤。如果任何本地事务失败，则Saga必须以相反的顺序执行补偿事务。以下几种不同的方法可用来构建Saga的协调逻辑。

- 协同式（choreography):把Saga的决策和执行顺序逻辑分布在Saga的每一个参与方中，它们通过交换事件的方式来进行沟通。
- 编排式(orchestration):把Saga的决策和执行顺序逻辑集中在一个Saga编排器类中。Saga编排器发出命令式消息给各个Saga参与方，指示这些参与方服务完成具体操作(本地事务)。