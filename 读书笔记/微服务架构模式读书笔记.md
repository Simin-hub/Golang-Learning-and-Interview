# 微服务架构模式读书笔记

## 第一章 逃离单体地狱

### 扩展立方体

![image-20221005210602589](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221005210602589.png)

扩展立方体定义了三种不同的扩展应用程序的方法：X轴扩展在多个相同实例之间实现请求的负载均衡；Z轴扩展根据请求的属性路由请求；Y轴扩展根据功能将应用程序拆分为服务。

这个模型描述了扩展一个应用程序的三种维度：X、Y和Z。

#### **X轴扩展：在多个实例之间实现请求的负载均衡**

X轴扩展是扩展单体应用程序的常用方法。下图展示了X轴扩展的工作原理。在负载均衡器之后运行应用程序的多个实例。负载均衡器在N个相同的实例之间分配请求。这是提高应用程序吞吐量和可用性的好方法。

![image-20221005212125948](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221005212125948.png)

#### **Z轴扩展：根据请求的属性路由请求**

Z轴扩展也需要运行单体应用程序的多个实例，但不同于X轴扩展，每个实例仅负责数据的一个子集。下图展示了Z轴扩展的工作原理。置于前端的路由器使用请求中的特定属性将请求路由到适当的实例。例如，应用程序可能会使用请求中包含的userId来路由请求。

在这个例子中，每个应用程序实例负责一部分用户。该路由器使用请求Authorization头部指定的userId来从N个相同的应用程序实例中选择一个。对于应用程序需要处理增加的事务和数据量时，Z轴扩展是一种很好的扩展方式。

![image-20221005213310383](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221005213310383.png)

#### **Y轴扩展：根据功能把应用拆分为服务**

X轴和Z轴扩展有效地提升了应用的吞吐量和可用性，然而这两种方式都没有解决日益增长的开发问题和应用复杂性。为了解决这些问题，我们需要采用Y轴扩展，也就是功能性分解。Y轴扩展把一个单体应用分成了一组服务，如图1-6示。

![image-20221006110610203](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006110610203.png)

服务本质上是一个麻雀虽小但五脏俱全的应用程序，它实现了一组相关的功能，例如订单管理、客户管理等。服务可以在需要的时候借助X轴或Z轴方式进行扩展。例如，订单服务可以被部署为一组负载均衡的服务实例。

我对微服务架构的概括性定义是：把应用程序功能性分解为一组服务的架构风格。请注意这个定义中并没有包含任何与规模有关的内容。重要的是，每一个服务都是由一组专注的、内聚的功能职责组成。我们稍后会详细讨论。

目前而言，我们先来看看为什么微服务架构是模块化的一种形式。

### 微服务

微服务架构使用服务作为模块化的单元。服务的API为它自身构筑了一个不可逾越的边界，你无法越过API去访问服务内部的类，这与采用Java包的单体应用完全不同。因此模块化的服务更容易随着时间推移而不断演化。微服务架构也带来其他的好处，例如服务可以独立进行部署和扩展。

微服务架构的一个关键特性是**每一个服务之间都是松耦合的，它们仅通过API进行通信**。实现这种松耦合的方式之一，是**每个服务都拥有自己的私有数据库**。对于一个线上商店来说，Order Service拥有一个包括ORDERS表的数据库，Customer Service服务拥有一个包含CUSTOMERS表的数据库。在开发阶段，开发者可以修改自己服务的数据库模式，而不必同其他服务的开发者协调。在运行时，服务实现了相互之间的独立。服务不会因为其他的服务锁住了数据库而进入堵塞的状态。

### 微服务架构与SOA的异同

某些针对微服务架构的批评声称它其实就是SOA,并没有新鲜的内容。在某些层面，它们的确有些相似。SOA和微服务架构都是特定的架构风格，它们都以一系列服务的方式来把一个系统组织在一起。但如果深入研究，你就会发现微服务和SOA之间巨大的差异，如表1-1所示。

![image-20221006111626749](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006111626749.png)

### 微服务的优缺点



### 模式和模式语言

**模式是针对特定上下文中发生的问题的可重用解决方案**。这个想法起源于现实世界中的建筑架构设计，并且已被证明针对软件架构设计同样行之有效。

常用的模式结构包括三个重要部分：

- 需求(Forces)。
- 结果上下文(Resulting context)。
- 相关模式(Related patterns)。

#### **需求：必须解决的问题**

需求部分**描述了必须解决的问题和围绕这个问题的特定上下文环境**。需求有时候是互相冲突的，所以不能指望把它们全部都解决（必须取舍）。哪一个需求更重要，取决于它的上下文。你必须**把需求按优先级进行排序**。例如，像代码必须易于理解和代码必须有好的性能，类似这样的两个需求在某些情况下就是冲突的。采用响应式风格编写的代码性能往往比那些同步代码的性能好很多，但是这些代码也更难以读懂。把所有的需求明确列出是非常有帮助的，因为它可以清晰展现哪些问题需要被（优先）解决。

#### **结果上下文：采用模式后可能带来的后果**

结果上下文部分**描述了采用这个模式的结果**，它包含三个部分：

- 好处：这个模式的好处和它解决了什么需求。
- 弊端：这个模式的弊端和它没有解决哪些需求。
- 问题：使用这个模式所引人的新问题。

结果上下文提供了更加完整、从不偏不倚的视角来描述的解决方案，这有助于更好的决策。

#### **相关模式：5种不同类型的关系**

相关模式部分**描述了这个模式和其他模式之间的关系**。

模式之间存在5种关系：

- 前导(Predecessor):**前导模式是催生这个模式的需求的模式**，例如，微服务架构模式是除单体架构模式以外整个模式语言中所有模式的前导模式。
- 后续（Successor):**后续模式是指用来解决当前模式引入的新问题的模式**，例如，如果你采纳了微服务架构模式，你需要一系列的后续模式来解决诸如服务发现、断路器等微服务带来的新问题。
- 替代(Alternative):**当前模式的替代模式，提供了另外的解决方案**，例如，单体架构和微服务架构就是互为替代的模式，它们都是应用的架构风格。你可以选择其一。
- 泛化（Generalization)：**针对一个问题的一般性解决方案**。例如，在第l2章中你会了解到“每主机单个服务”这个模式存在多种不同的技术实现。
- 特化（Specialization)：**针对特定模式的具体解决方案**。例如，在第l2章中你会了解到将服务部署为容器模式是针对“每主机单个服务”的具体解决方案。

### 微服务架构的模式语言概述

微服务架构的模式语言是一组模式，可帮助架构师使用微服务架构构建应用程序。图1-10显示了模式语言的结构。**模式语言首先帮助架构师决定是否使用微服务架构。它描述了单体架构和微服务架构，以及它们的好处和弊端**。然后，如果微服务架构非常适合当前的应用程序，那么模式语言可以帮助架构师通过解决各种架构和设计问题来有效地使用它。

![image-20221006113544827](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006113544827.png)

这套模式语言由若干组模式构成。在图1-10的左侧是应用程序架构模式组，包括单体架构模式和微服务架构模式。这些模式我们在本章中都已经有所讨论。其余的模式语言包括了一组如何解决采用微服务架构后引入的新问题的模式。

这些模式被分为三组：

- 基础设施相关模式组：这些模式解决通常是在开发环节跟基础设施有关的问题。
- 应用基础设施相关模式组：这些模式解决应用层面的基础设施相关问题。
- 应用相关模式组：这些模式解决开发人员面对的具体技术和架构问题。这些模式根据所解决问题的不同可进行更进一步的分组。我们先看看其中主要的几组模式。

#### **服务拆分的相关模式**

决定如何把系统分解为一组服务，这项工作从本质上来讲是一门艺术，但是即使这样，我们仍旧有一些策略可以遵循。我在服务拆分相关的模式中提出了一些策略，可以用于定义应用程序的架构。如图1-11所示。

![image-20221006114223621](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006114223621.png)

#### **通信的相关模式**

使用微服务架构构建的应用程序是分布式系统。因此，进程间通信（PC)是微服务架构的重要组成部分。架构师必须就服务彼此之间以及与外部世界进行通信做出各种架构和设计决策。

图1-12显示了通信模式，它们分为以下5组：

- 通信风格：使用哪一类进程间通信机制？
- 服务发现：客户端如何获得服务具体实例（如HTTP请求）的IP地址？
- 可靠性：在服务不可用的情况下，如何确保服务之间的可靠通信？
- 事务性消息：如何将消息发送、事件发布这样的动作与更新业务数据的数据库事务集成？
- 外部API:应用程序的客户端如何与服务进行通信？

![image-20221006135119932](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006135119932.png)

#### 实现事务管理的数据一致性相关模式

如之前提到的，为了确保松耦合，每个服务都必须拥有它自己的数据库。不幸的是，每个服务都有独立的数据库会引入一些大麻烦。例如，我会在第4章中解释为什么我们常用的两步式提交(two phase commit,2Pc)分布式事务机制在微服务架构之类场景下就不再适用。取而代之，应用程序需要使用Saga模式来确保数据的一致性。图1-13展示了数据一致性有关的模式。

![image-20221006140529219](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006140529219.png)

两步式提交(two phase commit)是指，当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引人一个作为协调者的组件来统一掌控所有节点（称作参与方）的操作结果，并最终指示这些节点是否要把操作结果进行真正的提交（比如将更新后的数据写人磁盘等等）的算法。

#### **在微服务架构中查询数据的相关模式**

服务和数据库一一对应还会带来另外一个挑战：**有些查询需要从多个服务的数据源获取数据**（传统应用采用SQL JOIN的方式完成）。服务的数据仅可以通过API的方式访问，所以我们不能直接针对服务的数据库执行分布式查询。图1-14展示了跟实现查询有关的一些模式。

![image-20221006140721369](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006140721369.png)

有些时候我们可以使用API组合模式，**逐一调用服务的API然后把所有的返回聚合在一起**。多数情况之下，你需要使用称之为**命令查询职责隔离(CQRS)的方式**，来维护一些重要和常用的查询数据视图。在第7章，我会深入探讨实现这些查询的方法。

#### 服务部署的相关模式

部署一个单体应用往往不是一件简单的事情，但总体上来说还是一个比较直观的操作，因为毕竟只有一个应用实体需要被部署。你需要考虑的只是如何在负载均衡器后面运行这个应用的多份实例。

然而，部署基于微服务的应用程序就要复杂得多。通常应用由各种异构的语言和框架开发的数十甚至上百个服务组成，有很多动态的部分需要被考虑。图1-15展示了跟部署有关的一些模式。

传统（手工）方式的应用程序部署，也就是把应用程序（如WAR文件）复制到服务器上，这样的做法不再适用于微服务架构了。你需要一个高度自动化部署的基础设施。理想情况下，你需要有一个部署平台，包括一个简单的界面（命令行或者图形用户界面都可以）来部署和管理这些服务。这些部署平台往往都是基于虚拟机、容器或者Serverless技术的。我在第12章会详细介绍这些部署方式的差异。

![image-20221006140905477](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006140905477.png)

#### 可观测性的相关模式

**应用运维的一项重要工作就是搞明白应用在运行时的一些行为，同时能够根据错误的请求或者高延迟等故障进行诊断排错**。理解和诊断一个单体应用并不是一项容易的工作，但毕竟它的请求和处理都是针对一个实例，以相对简单的方式完成的。每一个人站请求都通过负载均衡指派到了一个具体的应用实例，然后实例向数据库发起若干请求，最后返回结果。如果需要，你可以通过查阅该应用实例的日志文件的方式理解整个请求的过程。

与之相反，理解和诊断微服务架构下发生的问题往往是一项令人头疼的工作。在把最终结果返回给客户端之前，一项请求往往会在多个服务之间跳转，也就是说光看一个日志文件是解决不了问题的。有关高延迟的问题就更加令人抓狂，因为这会涉及多种可能的原因。

以下模式可用来设计具备可观测性的服务：

- 健康检查API:可以返回服务健康状态的API。
- 日志聚合：把服务产生的日志写入一个集中式的日志服务器，这个服务器可以提供日志搜索，也可以根据日志情况触发报警。
- 分布式追踪：为每一个外部请求分配一个唯一的D,用于在各个服务之间追踪外部请求。
- 异常跟踪：把程序异常发送到异常跟踪服务，这个服务会排除重复异常，给开发者发送告警并且跟踪每一个异常的解决。
- 应用指标：供维护使用的指标，例如计数器等，导出到指标服务器。
- 审计日志：记录用户的行为。

#### 实现服务自动化测试的相关模式

微服务架构让单一的服务测试变得容易，因为相比单体应用，每一个服务都变得更小了。但与此同时，重要的是测试不同的服务是否协同工作，同时避免使用复杂、缓慢和脆弱的端到端测试来测试多个服务。以下是通过单独测试服务来简化测试的模式：

- 消费端驱动的契约测试：验证服务满足客户端所期望的功能。
- 消费端契约测试：验证服务的客户端可以正常与服务通信。
- 服务组件测试：在隔离的环境中测试服务。

在第9章和第10章中，我们会介绍这些跟测试有关的模式。

#### 解决基础设施和边界问题的相关模式

**在微服务架构中，每个服务都必须实现许多跟基础设施相关的功能，包括可观测性模式和服务发现模式**。还必须实现外部化配置模式，该模式在运行时向服务提供数据库凭据等配置参数。在开发新服务时，从头开始重新实现这些功能是在太费时间了。一种更好的方法是在处理这些问题时应用微服务基底©模式，在这样的现有成熟的基底框架之上构建服务。第11章将详细描述这些模式。

#### 安全相关的模式

在微服务架构中，用户身份验证的工作通常由API Gateway完成。然后，它必须将有关用户的信息（例如身份和角色）传递给它调用的服务。常见的解决方案是应用访问令牌模式。API Gateway将访问令牌（例如JWT,即JSON Web令牌）传递给服务，这些服务可以验证令牌并获取有关用户的信息。第11章将更详细地讨论访问令牌模式。不必惊讶，这些模式的目的就是解决采用新架构之后浮现的种种问题。为了成功地开发软件，你必须选择合适的架构。但架构不是你唯一需要关注的领域，你还必须思考流程和组织。

## 第二章 服务的拆分策略

微服务架构的关键挑战是将应用程序功能分解为服务。因此，架构设计的第一个也是最重要的工作就是服务的定义。

### 微服务架构

#### 软件架构

> 计算机系统的软件架构是构建这个系统所需要的一组结构，包括软件元素、它们之间的关系以及两者的属性。

这显然是一个非常抽象的定义。但其实质是**应用程序的架构是将软件分解为元素(element)和这些元素之间的关系(relation)**。由于以下两个原因，分解很重要：

- 它**促进了劳动和知识的分工**。它使具有特定专业知识的人们（或多个团队）能够就应用程序高效地协同工作。
- 它**定义了软件元素的交互方式**。将软件分解成元素以及定义这些元素之间的关系，决定了软件的能力。

#### 软件架构的 4+1 视图

![image-20221006142955334](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006142955334.png)

每个视图的目的如下：

- 逻辑视图：开发人员创建的软件元素。在面向对象的语言中，这些元素是类和包。它们之间的关系是类和包之间的关系，包括继承、关联和依赖。
- 实现视图：构建编译系统的输出。此视图由表示打包代码的模块和组件组成，组件是由一个或多个模块组成的可执行或可部署单元。在Java中，模块是JAR文件，组件通常是WAR文件或可执行JAR文件。它们之间的关系包括模块之间的依赖关系以及组件和模块之间的组合关系。
- 进程视图：运行时的组件。每个元素都是一个进程，进程之间的关系代表进程间通信。
- 部署视图：进程如何映射到机器。此视图中的元素由（物理或虚拟）计算机和进程组成。机器之间的关系代表网络。该视图还描述了进程和机器之间的关系。

除了这四个视图以外，**4+1中的+1是指场景，它负责把视图串联在一起。每个场景负责描述在一个视图中的多个架构元素如何协作，以完成一个请求**。例如，在逻辑视图中的场景，展现了类是如何协作的。同样，在进程视图中的场景，展现了进程是如何协作的。4+1视图是描述应用程序架构的绝佳方式。每一个视图都描述了架构的一个重要侧面。场景把视图中的元素如何协作串联在一起。现在我们来看看为什么架构是如此重要。

#### 架构的风格

##### 分层式架构风格

##### 六边形架构

##### 单体架构

单体架构是一种架构风格，它的实现视图是单个组件：单个可执行文件或WAR文件。这个定义并没有说明其他的视图。例如，单体应用程序可以具有六边形架构风格的逻辑视图。

##### 微服务架构

微服务架构也是一种架构风格。它的实现视图由多个组件构成：一组可执行文件或WAR文件。它的组件是服务，连接器是使这些服务能够协作的通信协议。每个服务都有自己的逻辑视图架构，通常也是六边形架构。

> 模式：微服务架构
>
> 将应用程序构建为松耦合、可独立部署的一组服务。

微服务架构强加的一个关键约束是服务松耦合。因此，服务之间的协作方式存在一定限制。为了解释这些限制，我将尝试定义什么是服务，解释松耦合意味着什么，并告诉你为什么这很重要。

**什么是服务**

**服务是一个单一的、可独立部署的软件组件，它实现了一些有用的功能**。图2-4显示了服务的外部视图，在此示例中是Order Service。服务具有API,为其客户端提供对功能的访问。有两种类型的操作：命令和查询。API由命令、查询和事件组成。命令如createorder()执行操作并更新数据。查询，如findOrderById()检索数据。服务还发布由其客户端使用的事件，例如OrderCreated。

**服务的API封装了其内部实现**。与单体架构不同，开发人员无法绕过服务的API直接访问服务内部的方法或数据。因此，微服务架构强制实现了应用程序的模块化。

微服务架构中的每项服务都有自己的架构，可能还有独特的技术栈。但是典型的服务往往都具有六边形架构。其API由与服务的业务逻辑交互的适配器实现。操作适配器调用业务逻辑，事件适配器对外发布业务逻辑产生的事件。

![image-20221006144816083](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006144816083.png)

一个基本要求是服务具有API并且可以独立部署。

### 为应用程序定义微服务架构

那么如何定义一个微服务架构呢？跟所有的软件开发过程一样，一开始我们需要拿到领域专家或者现有应用的需求文档。跟所有的软件开发一样，定义架构也是一项艺术而非技术。本节我们将介绍一种定义应用程序架构的三步式流程，如图2-5所示。世界上并没有一个机械化的流程可以遵循，然后指望这个流程输出一个合理的架构。我们只能介绍一个大概的方法，现实世界中，这是一个不断迭代和持续创新的过程。

![image-20221006150422417](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006150422417.png)

#### 识别系统操作

**定义应用程序架构的第一步是定义系统操作**。起点是应用程序的需求，包括用户故事及其相关的用户场景（请注意，这些与架构场景不同）。使用图2-6中所示的两步式流程识别和定义系统操作。这个流程的灵感来自Craig Larman的名著《Applying UML and Patterns》(PrenticeHall,2004)中介绍的面向对象设计过程（www.craiglarman.com/wiki/index.php?title--BookApplying_UML_and_Patterns))。**第一步创建由关键类组成的抽象领域模型，这些关键类提供用于描述系统操作的词汇表。第二步确定系统操作，并根据领域模型描述每个系统操作的行为**。

![image-20221006150939463](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006150939463.png)

**领域模型主要源自用户故事中提及的名词，系统操作主要来自用户故事中提及的动词**。你还可以使用名为事件风暴(Event Storming)的技术定义领域模型，我将在第5章中讨论。每个系统操作的行为都是根据它对一个或多个领域对象的影响以及它们之间的关系来描述的。**系统操作可以创建、更新或删除领域对象，以及创建或破坏它们之间的关系**。我们来看看如何定义抽象领域模型。之后，我将根据领域模型定义系统操作。

#### 应用服务的识别

##### 根据业务能力进行服务拆分

创建微服务架构的策略之一就是采用业务能力进行服务拆分。业务能力是一个来自于业务架构建模的术语。**业务能力是指一些能够为公司（或组织）产生价值的商业活动**。特定业务的业务能力取决于这个业务的类型。例如，保险公司业务能力通常包括承保、理赔管理、账务和合规等。在线商店的业务能力包括：订单管理、库存管理和发货，等等。

##### 根据子域进行服务拆分

**领域模型以解决具体问题的方式包含了一个领域内的知识**。它定义了当前领域相关团队的词汇表，DDD也称之为通用语言(Ubiquitous language)。领域模型会被紧密地映射到应用的设计和实现环节。在微服务架构的设计层面，DDD有两个特别重要的概念，子域和限界上下文。

DDD把领域模型的边界称为限界上下文(bounded context)。限界上下文包括实现这个模型的代码集合。当使用微服务架构时，**每一个限界上下文对应一个或者一组服务**。换一种说法，我们可以通过DDD的方式定义子域，并把子域对应为每一个服务，这样就完成了微服务架构的设计工作。图2-9展示了子域和服务之间的映射，每一个子域都有属于它们自己的领域模型。

![image-20221006152730170](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006152730170.png)

按子域分解和按业务能力分解是定义应用程序的微服务架构的两种主要模式。但是，也有一些有用的拆分指导原则源于面向对象的设计。我们来详细讨论这些原则。

##### 拆分原则

**单一职责原则**

类所承载的每一个职责都是对它进行修改的潜在原因。如果一个类承载了多个职责，并且互相之间的修改是独立的，那么这个类就会变得非常不稳定。遵照SRP原则，你所定义的每一个类都应该只有一个职责，因此也就只有一个理由对它进行修改。

**闭包原则**（CCP）

在包中包含的所有类应该是对同类的变化的一个集合，也就是说，如果对包做出修改，需要调整的类应该都在这个包之内。

这就意味着，**如果由于某些原因，两个类的修改必须耦合先后发生，那么就应该把它们放在同一个包内**。也许，这些类实现了一些特定的业务规则的不同方面。这样做的目标是当业务规则发生变化时，开发者只需要对一个交付包做出修改，而不是大规模地修改（和重新编译)整个应用。采用闭包原则，极大地改善了应用程序的可维护性。

在微服务架构下采用CCP原则，这样我们就能把根据同样原因进行变化的服务放在一个组件内。这样做可以控制服务的数量，当需求发生变化时，变更和部署也更加容易。理想情况下，一个变更只会影响一个团队和一个服务。CCP是解决分布式单体这种可怕的反模式的法宝。

##### 拆分单体应用为服务的难点

从表面上看，通过定义与业务能力或子域相对应的服务来创建微服务架构的策略看起来很简单。但是，你可能会遇到几个障碍：

- 网络延迟。
- 同步进程间通信导致可用性降低。
- 在服务之间维持数据一致性。
- 获取一致的数据视图。
- 上帝类阻碍了拆分。

#### 定义服务API

存在服务API操作有以下两个原因：首先，某些操作对应于系统操作。它们由外部客户端调用，也可能由其他服务调用。另次，存在一些其他操作用以支持服务之间的协作。这些操作仅由其他服务调用。

定义服务API的起点是将每个系统操作映射到服务。之后确定服务是否需要与其他服务协作以实现系统操作。如果需要协作，我们将确定其他服务必须提供哪些API才能支持协作。首先来看一下如何将系统操作分配给服务。

**把系统操作分配给服务**



**确定支持服务协作所需要的API**



## 第三章 微服务架构中的进程间通信

### 进程间通信

有很多进程间通信技术可供开发者选择。服务可以使用基于同步请求/响应的通信机制，例如HTTP REST或gRPC。另外，也可以使用异步的基于消息的通信机制，比如AMQP或STOMP。消息的格式也不尽相同。服务可以使用具备可读性的格式，比如基于文本的JSON或XML。也可以使用更加高效的、基于二进制的Avro或Protocol Buffers格式。

#### 交互方式

在为服务的API选择进程间通信机制之前，首先考虑服务与其客户端的交互方式是非常重要的。考虑交互方式将有助于你专注于需求，并避免陷入特定进程间通信技术的细节。

有多种客户端与服务的交互方式。如表3-1所示，它们可以分为两个维度。

**第一个维度关注的是一对一和一对多**。

- 一对一：每个客户端请求由一个服务实例来处理。
- 一对多：每个客户端请求由多个服务实例来处理。

**交互方式的第二个维度关注的是同步和异步**。

- 同步模式：客户端请求需要服务端实时响应，客户端等待响应时可能导致堵塞。
- 异步模式：客户端请求不会阻塞进程，服务端的响应可以是非实时的。

![image-20221006164143279](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006164143279.png)

一对一的交互方式有以下几种类型。

- 请求/响应：一个客户端向服务端发起请求，等待响应；客户端期望服务端很快就会发送响应。在一个基于线程的应用中，等待过程可能造成线程阻塞。这样的方式会导致服务的紧耦合。
- 异步请求/响应：客户端发送请求到服务端，服务端异步响应请求。客户端在等待响应时不会阻塞线程，因为服务端的响应不会马上就返回。
- 单向通知：客户端的请求发送到服务端，但是并不期望服务端做出任何响应。

一对多的交互方式有以下几种类型。

- 发布/订阅方式：客户端发布通知消息，被零个或者多个感兴趣的服务订阅。
- 发布/异步响应方式：客户端发布请求消息，然后等待从感兴趣的服务发回的响应。

#### 在微服务架构中定义API

API或接口是软件开发的中心。应用是由模块构成的，每个模块都有接口，这些接口定义了模块的客户端可以调用若干操作。一个设计良好的接口会在暴露有用功能同时隐藏实现的细节。因此，这些实现的细节可以被修改，而接口保持不变，这样就不会对客户端产生影响。

API和接口在微服务架构中同样重要。**服务的API是服务与其客户端之间的契约**(contract).。如第2章所述，服务的API由客户端结构可以调用的方法和服务发布的事件组成。方法具备名称、参数和返回类型。事件具有一个类型和一组字段，发布到消息通道。

#### API的演变



#### 消息的格式

进程间通信的本质是交换消息。消息通常包括数据，因此一个重要的设计决策就是这些数据的格式。消息格式的选择会对进程间通信的效率、API的可用性和可演化性产生影响。如果你正在使用一个类似HTTP的消息系统或者协议，那么你需要选择消息的格式。有些进程间通信机制，如我们马上就会讲到的gRPC,已经指定了消息格式。在这两种情况下，使用跨语言的消息格式尤为重要。即使我们今天使用同一种编程语言来开发微服务应用，那也很有可能在今后会扩展到其他的编程语言。我们不应该使用类似Java序列化这样跟编程语言强相关的消息格式。**消息的格式可以分为两大类：文本和二进制**。我们来逐一分析。

### 基于同步远程过程调用模式的通信

当使用基于远程过程调用（P)的进程间通信机制时，客户端向服务发送请求，服务处理该请求并发回响应。有些客户端可能会处在堵塞状态并等待响应，而其他客户端可能会有个响应式的非阻塞架构。但与使用消息机制时不同，客户端假定响应将及时到达。

图3-1显示了远程过程调用的工作原理。**客户端中的业务逻辑调用代理接口，这个接口由远程过程调用代理适配器类实现**。远程过程调用代理向服务发出请求。该请求由远程过程周用服务器适配器类处理，该类通过接口调用服务的业务逻辑。然后它将回复发送回远程过程调用代理，该代理将结果返回给客户端的业务逻辑。

![image-20221006165515261](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006165515261.png)

**代理接口通常封装底层通信协议**。有许多协议可供选择

#### 使用断路器模式处理局部故障

分布式系统中，当服务试图向另一个服务发送同步请求时，永远都面临着局部故障的风险。因为客户端和服务端是独立的进程，服务端很有可能无法在有限的时间内对客户端的请求做出响应。服务端可能因为故障或维护的原因而暂停。或者，服务端也可能因为过载而对请求的响应变得极其缓慢。

客户端等待响应被阻塞，这可能带来的麻烦就是在其他客户端甚至使用服务的第三方应用之间传导，并导致服务中断。

> 模式：断路器
>
> 这是一个远程过程调用的代理，在连续失败次数超过指定阈值后的一段时间内，这个代理会立即拒绝其他调用。

要通过合理地设计服务来防止在整个应用程序中故障的传导和扩散，这是至关重要的。解决这个问题分为两部分：

- 必须让远程过程调用代理（例如OrderServiceProxy)有正确处理无响应服务的能力。
- 需要决定如何从失败的远程服务中恢复。

首先，我们将看看如何编写健壮的远程过程调用代理。开发可靠的远程过程调用代理 

##### 开发可靠的远程过程调用代理



##### 从服务失效故障中恢复



#### 使用服务发现

服务实例启动和停止时，服务发现机制会更新服务注册表。当客户端调用服务时，服务发现机制会查询服务注册表以获取可用服务实例的列表，并将请求路由到其中一个服务实例。

实现服务发现有以下两种主要方式：

- 服务及其客户直接与服务注册表交互。
- 通过部署基础设施来处理服务发现。（我将在第12章中详细讨论这一点。）

##### 应用层服务发现模式

实现服务发现的一种方法是应用程序的服务及其客户端与服务注册表进行交互。图3-5显示了它的工作原理。服务实例使用服务注册表注册其网络位置。客户端首先通过查询服务注册表获取服务实例列表来调用服务，然后它向其中一个实例发送请求。

![image-20221006173711393](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006173711393.png)

这种服务发现方法是两种模式的组合。**第一种模式是自注册模式**。服务实例调用服务注册表的注册API来注册其网络位置。它还可以提供运行状况检查URL,在第11章中有更详细的描述。运行状况检查URL是一个API端点，服务注册表会定期调用该端点来验证服务实例是否正常且可用于处理请求。服务注册表还可能要求服务实例定期调用“心跳”API以防止其注册过期。

> 模式：自注册
>
> 服务实例向服务注册表注册自己。

第二种模式是**客户端发现模式**。当客户端想要调用服务时，它会查询服务注册表以获取服务实例的列表。为了提高性能，客户端可能会缓存服务实例。然后，服客户端使用负载平衡算法（例如循环或随机）来选择服务实例。然后它向选择的服务实例发出请求。

> 模式：客户端发现客户端从服务注册表检索可用服务实例的列表，并在它们之间进行负载平衡。

应用层服务发现的一个**好处是它可以处理多平台部署的问题**（服务发现机制与具体的部署平台无关)。例如，想象一下，你在Kubernetes上只部署了一些服务（将在第12章中讨论过)，其余服务在遗留环境中运行。在这种情况下，使用Eureka的应用层服务发现同时适用于两种环境，而基于Kubernetes的服务发现仅能用于部署在Kubernetes平台之上的部分服务。

应用层服务发现的一个**弊端是：你需要为你使用的每种编程语言（可能还有框架）提供服务发现库**。Spring Cloud只能帮助Spring开发人员。如果你正在使用其他Java框架或非JVM语言（如Node.js或GoLang),则必须找到其他一些服务发现框架。应用层服务发现的另一个弊端是开发者负责设置和管理服务注册表，这会分散一定的精力。因此，**最好使用部署基础设施提供的服务发现机制**。

##### 平台层服务发现模式

在第l2章中，你将了解许多现代部署平台（如Docker和Kubernetes)都具有内置的服务注册表和服务发现机制。部署平台为每个服务提供DNS名称、虚拟IP(VIP)地址和解析为VIP地址的DNS名称。客户端向DNS名称和VIP发出请求，部署平台自动将请求路由到其中一个可用服务实例。因此，**服务注册、服务发现和请求路由完全由部署平台处理**。图3-6显示了它的工作原理。

![image-20221006205828719](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006205828719.png)

部署平台包括一个服务注册表，用于跟踪已部署服务的P地址。在此示例中，客户端使用DNS名称order-service访问Order Service,该服务解析为虚拟P地址10.1.3.4。部署平台会自动在Order Service的三个实例之间对请求进行负载均衡。

这种方法是以下两种模式的组合。

- 第三方注册模式：由第三方负责（称为注册服务器，通常是部署平台的一部分）处理注册，而不是服务本身向服务注册表注册自己。
- 服务端发现模式：客户端不再需要查询服务注册表，而是向DNS名称发出请求，对该DNS名称的请求被解析到路由器，路由器查询服务注册表并对请求进行负载均衡。

> 模式：第三方注册
>
> 服务实例由第三方自动注册到服务注册表。

> 模式：服务端发现
>
> 客户端向路由器发出请求，路由器负责服务发现。

由平台提供服务发现机制的主要好处是**服务发现的所有方面都完全由部署平台处理**。服务和客户端都不包含任何服务发现代码。因此，无论使用哪种语言或框架，服务发现机制都可供所有服务和客户使用。

平台提供服务发现机制的一个**弊端是它仅限于支持使用该平台部署的服务**。例如，如前所述，在描述应用程序级别发现时，基于Kubernetes的发现仅适用于在Kubernetes上运行的服务。尽管存在此限制，我建议尽可能使用平台提供的服务发现。

现在我们已经学习了使用REST或gRPC的同步进程间通信，让我们来看看替代方案：基于异步消息模式的通信。

### 基于异步消息模式的通信

使用消息机制时，**服务之间的通信采用异步交换消息的方式完成**。基于消息机制的应用程序通常使用消息代理，它充当服务之间的中介。另一种选择是使用无代理架构，通过直接向服务发送消息来执行服务请求。服务客户端通过向服务发送消息来发出请求。如果希望服务实例回复，服务将通过向客户端发送单独的消息的方式来实现。由于通信是异步的，因此客户端不会堵塞和等待回复。相反，客户端都假定回复不会马上就收到。

> 模式：消息
>
> 客户端使用异步消息调用服务。

#### 什么是消息传递

**消息通过消息通道进行交换**。发送方（应用程序或服务）将消息写入通道，接收方（应用程序或服务）从通道读取消息。让我们先学习消息，然后学习通道。

##### 关于消息

**消息由消息头部和消息主体组成**（www,enterpriseintegrationpatterns.com/Message.html)。**消息头部是名称与值对的集合，描述正在发送的数据的元数据**。除了消息发送者提供的名称与值对之外，消息头部还包含其他信息，例如发件人或消息传递基础设施生成的唯一消息D,以及可选的返回地址，该地址指定发送回复的消息通道。**消息正文是以文本或二进制格式发送的数据**。

有以下几种不同类型的消息。

- 文档：仅包含数据的通用消息。接收者决定如何解释它。对命令式消息的回复是文档消息的一种使用场景。
- 命令：一条等同于RPC请求的消息。它指定要调用的操作及其参数。
- 事件：表示发送方这一端发生了重要的事件。事件通常是领域事件，表示领域对象(如Order或Customer)的状态更改。

##### 关于消息通道

如图3-7所示，消息通过消息通道进行交换(www.enterpriseintegrationpatterns.com/MessageChannel.html)。发送方中的业务逻辑调用发送端接口，该接口封装底层通信机制。发送端由消息发送适配器类实现，该消息发送适配器类通过消息通道向接收器发送消息。消息通道是消息传递基础设施的抽象。调用接收器中的消息处理程序适配器类来处理消息。它调用接收方业务逻辑实现的接收端接口。任意数量的发送方都可以向通道发送消息。类似地，任何数量的接收方都可以从通道接收消息。

![image-20221006211218330](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221006211218330.png)

有以下两种类型的消息通道：点对点(www.enterpriseintegrationpatterns.com/PointToPointChannel..html)和发布-订阅(www.enterpriseintegrationpatterns..com/PublishSubscribeChannel.html)。

- 点对点通道向正在从通道读取的一个消费者传递消息。服务使用点对点通道来实现前面描述的一对一交互方式。例如，命令式消息通常通过点对点通道发送。
- 发布-订阅通道将一条消息发给所有订阅的接收方。服务使用发布-订阅通道来实现前面描述的一对多交互方式。例如，事件式消息通常通过发布-订阅通道发送。

#### 使用消息机制实现交互方式

消息机制的一个有价值的特性是它足够灵活，可以支持3.1.1节中描述的所有交互方式。一些交互方式通过消息机制直接实现。其他必须在消息机制之上实现。

##### 实现请求/响应和异步请求/响应

**当客户端和服务使用请求/响应或异步请求/响应进行交互时，客户端会发送请求，服务会发回回复**。两种交互方式之间的区别在于，对于请求/响应，客户端期望服务立即响应，而对于异步请求/响应，则没有这样的期望。消息机制本质上是异步的，因此只提供异步请求/响应。但客户端可能会堵塞，直到收到回复。

**客户端和服务端通过交换一对消息来实现异步请求/响应方式的交互**。如图3-8所示，客户端发送命令式消息，该消息指定要对服务执行的操作和参数，这些内容通过服务拥有的点对点消息通道传递。该服务处理请求，并将包含结果的回复消息发送到客户端拥有的点对点通道。

![image-20221008103948562](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008103948562.png)

##### 实现单向通知



##### 实现发布/订阅

消息机制内置了对发布/订阅交互方式的支持。客户端将消息发布到由多个接收方读取的发布/订阅通道。如第4章和第5章所述，服务使用发布/订阅来发布领域事件，领域事件代表领域对象的更改。发布领域事件的服务拥有自己的发布/订阅通道，通道的名称往往派生自领域类。例如，Order Service将Order事件发布到Order通道，DeliveryService将Delivery事件发布到Delivery通道。对特定领域对象的事件感兴趣的服务只需订阅相应的通道。

##### 实现发布/异步响应



#### 为基于消息机制的服务API创建API规范

服务的异步API包含供客户端调用的操作和由服务对外发布的事件。这些API的记录方式不尽相同。让我们从操作开始逐一分析。

可以使用以下两种不同交互方式之一调用服务的操作：

![image-20221008105303974](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008105303974.png)

- **请求/异步响应式API**：包括服务的命令消息通道、服务接受的命令式消息的具体类型和格式，以及服务发送的回复消息的类型和格式。
- **单向通知式API**：包括服务的命令消息通道，以及服务接受的命令式消息的具体类型和格式。

服务可以对异步请求/响应和单向通知使用相同的请求通道。

##### 记录事件

发布服务还可以使用发布/订阅的方式对外发布事件。此API风格的规范包括事件通道以及服务发布到通道的事件式消息的类型和格式。消息和消息通道模型是一种很好的抽象，也是设计服务异步API的好方法。但是，为了实现服务，你需要选择具体的消息传递技术并确定如何使用它们的能力来实现设计。让我们看一看所涉及的内容。

#### 使用消息代理

**基于消息传递的应用程序通常使用消息代理，即服务通信的基础设施服务**。但基于消息代理的架构并不是唯一的消息架构。你还可以使用基于无代理的消息传递架构，其中服务直接相互通信。这两种方法（如图3-10所示）具有不同的利弊，但通常基于代理的架构是一种更好的方法。

![image-20221008163052422](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008163052422.png)

##### 无代理消息

在无代理的架构中，服务可以直接交换消息。ZeroMQ(http:/zeromq.org)是一种流行的无代理消息技术。它既是规范，也是一组适用于不同编程语言的库。它支持各种传输协议，包括TCP、UNIX风格的套接字和多播。

##### 基于代理的消息

消息代理是所有消息的中介节点。发送方将消息写入消息代理，消息代理将消息发送给接收方。使用消息代理的一个重要好处是发送方不需要知道接收方的网络位置。另一个好处是消息代理缓冲消息，直到接收方能够处理它们。

有许多消息代理可供选择。流行的开源消息代理包括：

- Apache ActiveMQ (http://activemq.apache.org)
- RabbitMQ(https://www.rabbitmq.com)。
- Apache Kafka (http://kafka.apache.org).

还有基于云的消息服务，例如AWS Kinesis（https:/aws.amazon.com/kinesis)和AWS SQS (https://aws.amazon.com/sqs/).

#### 处理并发和消息顺序

**挑战之一是如何在保留消息顺序的同时，横向扩展多个接收方的实例**。为了同时处理消息，拥有多个实例是一个常见的要求。而且，即使单个服务实例也可能使用线程来同时处理多个消息。使用多个线程和服务实例来并发处理消息可以提高应用程序的吞吐量。但同时处理消息的挑战是**确保每个消息只被处理一次，并且是按照它们发送的顺序来处理的**。

例如，假设有3个相同的接收方实例从同一个点对点通道读取消息，发送方按顺序发布了Order Created、Order Updated和Order Cancelled这3个事件消息。简单的消息实现可能就会同时将每个消息给不同的接收方。若由于网络问题或JVM垃圾收集等原因导致延迟，消息可能没有按照它们发出时的顺序被处理，这将导致奇怪的行为。理论上，服务实例可能会在另一个服务处理Order Created消息之前处理Order Cancelled消息。

现代消息代理（如Apache Kafka和AWS Kinesis)使用的常见解决方案是使用分片（分区)通道。图3-11展示了这是如何工作的。该解决方案分为三个部分。

1. 分片通道由两个或多个分片组成，每个分片的行为类似于一个通道。
2. 发送方在消息头部指定分片键，通常是任意字符串或字节序列。
3. 消息代理使用分片键将消息分配给特定的分片。例如，它可以通过计算分片键的散列来选择分片。

![image-20221008164907771](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008164907771.png)

#### 处理重复消息

使用消息机制时必须解决的另一个挑战是**处理重复消息**。理想情况下，消息代理应该只传递一次消息，但保证有且仅有一次的消息传递通常成本很高。相反，大多数消息代理承诺至少成功传递一次消息。

当系统正常工作时，保证传递的消息代理只会传递一次消息。但是客户端、网络或消息代理的故障可能导致消息被多次传递。假设客户端在处理消息后、发送确认消息之前，它的数据库崩溃了，这时消息代理将再次发送未确认的消息，在数据库重新启动时向该客户端或客户端的另一个副本发送。

理想情况下，你应该使用消息代理，在重新传递消息时保留排序。想象一下，客户端处理Order Created事件，然后紧接着收到了同一Order的Order Cancelled事件，但这时候Order Created事件还没有得到确认。消息代理应重新投递Order Created和OrderCancelled事件。如果它仅重新发送Order Created,客户可以撤回Order的取消。处理重复消息有以下两种不同的方法。

- 编写幂等消息处理程序。
- 跟踪消息并丢弃重复项。

##### 编写幂等消息

处理器如果应用程序处理消息的逻辑是满足幂等的，那么重复的消息就是无害的。所谓应用程序的幂等性，是指即使这个应用被相同输入参数多次重复调用时，也不会产生额外的效果。例如，取消一个已经被取消的订单，就是一个幂等性操作。同样，创建一个已经存在的订单操作也必是这样。满足幂等的消息处理程序可以被放心地执行多次（而不会引起错误的结果)只要消息代理在重新传递消息时保持相同的消息顺序。

不幸的是，应用程序逻辑通常不是幂等的。或者你可能正在使用消息代理，该消息代理在重新传递消息时不会保留排序。重复或无序消息可能会导致错误。在这种情况下，你必须**编写跟踪消息并丢弃重复消息的消息处理程序**。

##### 跟踪消息并丢弃重复消息

例如，考虑一个授权消费者信用卡的消息处理程序。它必须为每个订单仅执行一次信用卡授权操作。这段应用程序逻辑在每次调用时都会产生不同的效果。如果重复消息导致消息处理程序多次执行该逻辑，则应用程序的行为将不正确。执行此类应用程序逻辑的消息处理程序必须通过检测和丢弃重复消息而成为幂等的。

一个简单的解决方案是消息接收方使用message id跟踪它已处理的消息并丢弃任何重复项。例如，它可以存储它在数据库表中使用的每条消息的message id.。图3-12显示了如何使用专用表执行此操作。

![image-20221008165646785](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008165646785.png)

当接收方处理消息时，它将消息的message id作为创建和更新业务实体的事务的一部分记录在数据库表中。在此示例中，接收方将包含message id的行插人PROCESSEDMESSAGES表。如果消息是重复的，则INSERT将失败，接收方可以选择丢弃该消息。

另一个选项是**消息处理程序在应用程序表**，而不是专用表中记录message id。当使用具有受限事务模型的NoSQL数据库时，此方法特别有用，因为NoSQL数据库通常不支持将针对两个表的更新作为数据库的事务。第7章将介绍这种方法的一个例子。

#### 事务性消息

**服务通常需要在更新数据库的事务中发布消息**。例如，在本书中，你将看到在创建或更新业务实体时发布领域事件的例子。**数据库更新和消息发送都必须在事务中进行**。否则，服务可能会更新数据库，然后在发送消息之前崩溃。如果服务不以原子方式执行这两个操作，则类似的故障可能使系统处于不一致状态。

##### 使用数据库表作为消息队列

我们假设你的应用程序正在使用关系型数据库。可靠地发布消息的直接方法是应用事务性发件箱模式。此模式使用数据库表作为临时消息队列。如图3-13所示，发送消息的服务有一个OUTBOX数据库表。作为创建、更新和删除业务对象的数据库事务的一部分，服务通过将消息插人到OUTBOX表中来发送消息。这样可以保证原子性，因为这是本地的ACID事务。

![image-20221008170224376](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008170224376.png)

OUTBOX表充当临时消息队列。MessageRelay是一个读取OUTBOX表并将消息发布到消息代理的组件。

> 模式：事务性发件箱
>
> 通过将事件或消息保存在数据库的OUTBOX表中，将其作为数据库事务的一部分发布。

##### 通过轮询模式发布事件

**如果应用程序使用关系型数据库**，则对外发布插人OUTBOX表的消息的一种非常简单的方法是让MessageRelay在表中轮询未发布的消息。它定期查询表：

> 模式：轮询发布
>
> 数据通过轮询数据库中的发件箱来发布消息。

轮询数据库是一种在小规模下运行良好的简单方法。其弊端是**经常轮询数据库可能造成昂贵的开销**（导致数据库性能下降）。此外，你是否可以将此方法与NoSQL数据库一起使用取决于NoSQL数据库支持的查询功能。这是因为应用程序必须查询业务实体，而不是查询OUTBOX表，这可能会无法有效地执行。由于这些弊端和限制，通常在某些情况下，更好的办法是使用更复杂和高性能的方法，来拖尾(tailing)数据库事务日志。

##### 使用事务日志拖尾模式发布事件

更加复杂的实现方式，是**让MessageRelay拖尾数据库的事务日志文件**（也称为提交日志)。每次应用程序提交到数据库的更新都对应着数据库事务日志中的一个条目。事务日志挖掘器可以读取事务日志，把每条跟消息有关的记录发送给消息代理。图3-14展示了这个方案的具体实现方式。

Transaction-Log-Miner读取事务日志条目。它将对应于插人消息的每个相关日志条目转换为消息，并将该消息发布到消息代理。此方法可用于发布写人关系型数据库中的OUTBOX表的消息或附加到NoSQL数据库中的记录的消息。

> 模式：事务日志拖尾
>
> 通过拖尾事务日志发布对数据库所做的更改。

![image-20221008170832856](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008170832856.png)

### 使用异步消息提高可用性

#### 同步消息会降低可用性



#### 消除同步交互

##### 使用异步交互模式

**理想的情况是，所有的交互都应该使用本章之前所描述的异步交互**。例如，让我们假设FTGO采用请求/异步响应的交互方式来创建订单。客户端可以通过向Order Service发送一个请求消息交换消息的方式创建订单。这个服务随即采用异步交换消息的方式跟其他服务通信完成订单的创建，并向客户端发回一个返回消息。图3-16展示了具体的设计。

![image-20221008210942790](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008210942790.png)

**客户端和服务端使用消息通道发送消息来实现异步通信**。这个交互过程中不存在堵塞等待响应的情况。

这样的架构非常有弹性，因为消息代理会一直缓存消息，直到有服务端接收并处理消息。然而，问题是**服务很多情况下都采用类似REST这样的同步通信协议的外部API,并且要求对请求立即做出响应**。

在这种情况下，我们可以采用复制数据的方式来提高可用性。我们看看如何实现。

##### 复制数据

**在请求处理环节中减少同步请求的另外一种办法，就是进行数据复制**。服务维护一个数据副本，这些数据是服务在处理请求时需要使用的。这些数据的源头会在数据变化时发出消息，服务订阅这些消息来确保数据副本的实时更新。例如，Order Service可以维护来自Consumer Service和Restaurant Service的数据副本。在这种情况下，Order Service可以在不与其他服务进行交互的情况下完成订单创建的请求。图3-17展示了具体的设计。

![image-20221008211339882](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008211339882.png)

Consumer Service和Restaurant Service在它们的数据发生变化时对外发布事件。Order Service服务订阅这些事件，并据此更新自己的数据副本。

在有些情况下，复制数据是一种有用的方式，第5章中还会有更具体的讨论，描述Order Service如何从Restaurant Service复制数据以验证菜单并定价。然而，**复制数据的一个弊端在于，有时候被复制的数据量巨大**，会导致效率低下。例如，让Order Service服务去维护一个Consumer Service的数据副本并不可行，因为数据量实在太大了。复制的另外一个弊端在于，复制数据并没有从根本上解决服务**如何更新其他服务所拥有的数据**这个问题。

解决该问题的一种方法是让服务暂缓与其他服务交互，直到它给客户端发送了响应。接下来我们将看看它是如何工作的。

##### 先返回响应，再完成处理

另外一种在请求处理环节消除同步通信的办法如下：

1. 仅使用本地的数据来完成请求的验证。

2. 更新数据库，包括向OUTBOX表插入消息。

3. 向客户端返回响应。

当处理请求时，服务并不需要与其他服务直接进行同步交互。取而代之的是，服务异步向其他的服务发送消息。这种方式确保了服务之间的松耦合。正如我们将在下一章看到的，这是通过Saga实现的。

例如，Order Service可以用这种方式创建一个未经验证(Pending)状态的订单，然后通过异步交互的方式直接跟其他服务通信来完成验证。图3-l8展示了createorder()被调用时发生的具体过程。

![image-20221008211827580](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008211827580.png)

事件的顺序是：

1.Order Service在PENDING状态下创建订单。

2.Order Service返回包含订单ID的响应给客户。

3.Order Service向Consumer Service发送ValidateConsumerInfo消息

4.Order Service向Restaurant Service发送ValidateorderDetails消息。

5.Consumer Service接收ValidateConsumerInfo消息，验证消费者是否可以下订单，并向Order Service发送ConsumerValidated消息。

6.Restaurant Service收到ValidateOrderDetails消息，验证菜单项是否有效以及餐馆是否可以交付订单的交付地址，并向Order Service发送OrderDetailsValidated消息。

7.order Service接收ConsumerValidated和OrderDetailsValidated,并将订单状态更改为VALIDATED。

8.…

Order Service可以按任意顺序接收ConsumerValidated和OrderDetailsValidated消息。它**通过更改订单状态来跟踪它首先收到的消息**。如果它首先收到ConsumerValidated,它会将订单状态更改为CONSUMER_VALIDATED;如果它首先收到OrderDetailsValidated消息，则会将其状态更改为ORDER_DETAILS_VALIDATED。Order Service在收到其他消息时将订单状态更改为VALIDATED.。

**订单验证后，Order Service完成订单创建过程的其余部分**，这些细节将在下一章中讨论。这种方法的优点在于，即使Consumer Service中断，Order Service仍然会创建订单并响应其客户。最终，Consumer Service将重新启动并处理任何排队的消息，并且验证订单。

**在完全处理请求之前响应服务的弊端是它使客户端更复杂**。例如，Order Service在返回响应时对新创建的订单的状态提供最低限度的保证。它会在验证订单并授权消费者的信用卡之前立即创建订单并返回。因此，为了使客户端知道订单是否已成功创建，要么必须定期轮询，要么Order Service必须向客户端发送通知消息。听起来很复杂，但是在许多情况下这是首选方法：特别是因为它还解决了我将在下一章中讨论的分布式事务管理问题。在第4章和第5章中，我将介绍Order Service如何使用这种方法。

## 第四章 使用Saga管理事务

ACID(原子性、一致性、隔离性和持久性)事务造成了一种错觉，让开发人员认为每个事务都具有对数据的独占访问权，这种错觉极大地简化了开发人员的工作。在微服务架构中，单个服务中的事务仍然可以使用ACID事务。然而，在对更新多个服务所拥有的数据的操作实现事务时，我们面临着新的挑战。**跨服务的操作必须使用所谓的Saga**（一种消息驱动的本地事务序列)来维护数据一致性，而不是ACID事务。**Saga的一个挑战在于只满足ACD(原子性、一致性和持久性)特性**，而缺乏传统ACD事务的隔离性。因此，应用程序必须使用所谓的对策(countermeasure),找到办法来防止或减少由于缺乏隔离而导致的并发异常。

分析协调Saga的两种不同方式：一种是协同式（choreography),Saga的参与方在没有集中控制器的情况下交换事件式消息；另外一种是编排式(orchestration),集中控制器告诉Saga参与方要执行的操作。我会讲解如何使用对策来防止或减少由于Saga之间缺乏隔离而导致的并发异常。最后，我会描述一个Saga的实现例子。让我们首先看一看在微服务架构中管理事务的挑战。

### 微服务架构下的事务管理

#### 微服务架构对分布式事务的需求



#### 分布式事务的挑战

**在多个服务、数据库和消息代理之间维持数据一致性的传统方式是采用分布式事务**。分布式事务管理的事实标准是X/Open Distributed Transaction Processing(DTP)Model(X/OpenXA,https::/en.wikipedia.org/wiki/X/Open XA)。**XA采用了两阶段提交(two phase commit,2PC)来保证事务中的有参与方同时完成提交，或者在失败时同时回滚**。应用程序的整个技术栈需要满足XA标准，包括符合XA要求的数据库、消息代理、数据库驱动、消息API,以及用来传播XA全局事务D的进程间通信机制。市面上绝大多数的SQL数据库和一部分消息代理满足XA标准。例如，Jave EE应用程序可以使用JTA来完成分布式事务。

#### 使用Saga模式维护数据一致性

Saga是一种在微服务架构中维护数据一致性的机制，它可以避免分布式事务所带来的问题。**一个Saga表示需要更新多个服务中数据的一个系统操作**。Saga由一连串的本地事务组成。每一个本地事务负责更新它所在服务的私有数据库，这些操作仍旧依赖于我们所熟悉的ACID事务框架和函数库。

> 模式：Saga
>
> 通过使用异步消息来协调一系列本地事务，从而维护多个服务之间的数据一致性。

系统操作启动了Saga的第一步。完成本地事务会触发下一个本地事务的执行。稍后在4.2节中，你将看到如何使用异步消息实现Saga步骤间的协调。异步消息的一个重要好处是它确保Saga的所有步骤都被执行，即使一个或多个Saga的参与方暂时不可用。

Saga在几个重要方面与ACID事务不同。正如我将在4.3节中详细描述的那样，它们缺少ACID事务的隔离性。此外，由于每个本地事务都提交了其更改，因此必须使用补偿事务回滚Saga。我将在本节后面详细讨论补偿事务。先来看一个例子。

##### 示例Saga：Create Order Saga

本章中使用的示例Saga是Create order Saga,如图4-2所示。Order Service使用此Saga实现createorder()操作。Saga的第一个本地事务由创建订单的外部请求启动。其他5个本地事务均由前一个完成触发。

![image-20221008213809361](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008213809361.png)

这个Saga包含了以下几个本地事务：

1. Order Service:创建一个处于APPROVAL PENDING状态的Order.

2. Consumer Service:验证当前订单中的消费者可以下单。

3. Kitchen Service:验证订单内容，并创建一个后厨工单Ticket,状态为CREATE PENDING

4. Accounting Service:对消费者提供的信用卡做授权操作。

5. Kitchen Service:把后厨工单Ticket的状态改为AWAITING ACCEPTANCE。

6. Order Service:把Order的状态改为APPROVED。

稍后在4.2节中，我将介绍参与Saga的服务如何使用异步消息进行通信。当本地事务完成时，服务会发布消息。然后，此消息将触发Sga中的下一个步骤。使用消息不仅可以确保Saga参与方之间的松散耦合，还可以保证Saga完成。这是因为如果消息的接收方暂时不可用，则消息代理会缓存消息，直到消息可以被投递为止。从表面上看，Saga似乎很简单，但使用它们有一些挑战。一个挑战是Saga之间缺乏隔离。4.3节将描述如何处理这个问题。另一个挑战是在发生错误时的回滚更改。我们来看看如何做到这一点。

##### Saga使用补偿事务来回滚所做出的改变

传统ACID事务的一个重要特性是：如果业务逻辑检测到违反业务规则，可以轻松回滚事务。通过执行ROLLBACK语句，数据库可以撤销（回滚）目前为止所做的所有更改。遗憾的是，Saga无法自动回滚，因为每个步骤都会将其更改提交到本地数据库。这意味着，如果Create order Saga的第4个步（信用卡授权)失败，则FTG0应用程序必须明确撤销前三个步骤所做的更改。你必须编写所谓的补偿事务。

假设一个Saga的第$$n+1$$个事务失败了。必须撤销前n个事务的影响。从概念上讲，每个步骤 $$T_i$$ :都有一个相应的补偿事务$$C_i$$,它可以撤销$$T_i$$:的影响。要撤销前n个步骤的影响，Saga必须以相反的顺序执行每个C。步骤顺序为$$T_1...T_n,C_n...C_1,$$如图4-3所示。在这个例子中，$$T_{n+1}$$失败，这需要撤销步骤$$T_1...T_n$$ 。

![image-20221008214652648](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221008214652648.png)

Saga按照正常事务的反向顺序来执行补偿事务：$$C_n...C_1$$的顺序机制与$$T_i$$的顺序机制并无差别。$$C_i$$执行完成后必须触发$$C_{i-1}$$的执行。

### Saga的协调模式

Saga的实现包含协调Saga步骤的逻辑。当通过系统命令启动Saga时，协调逻辑必须选择并通知第一个Saga参与方执行本地事务。一旦该事务完成，Saga协调选择并调用下一个Saga参与方。这个过程一直持续到Saga执行完所有步骤。如果任何本地事务失败，则Saga必须以相反的顺序执行补偿事务。以下几种不同的方法可用来构建Saga的协调逻辑。

- 协同式（choreography):把Saga的决策和执行顺序逻辑分布在Saga的每一个参与方中，它们通过交换事件的方式来进行沟通。
- 编排式(orchestration):把Saga的决策和执行顺序逻辑集中在一个Saga编排器类中。Saga编排器发出命令式消息给各个Saga参与方，指示这些参与方服务完成具体操作(本地事务)。

#### 协同式Saga

实现Saga的一种方法是使用协同。**使用协同时，没有一个中央协调器会告诉Saga参与方该做什么**。相反，Saga参与方订阅彼此的事件并做出相应的响应。

##### 实现协同式的Create order Saga

图4-4显示了Create Order Saga的基于协同式版本的设计。参与方通过交换事件进行沟通。每个参与方从Order Service开始，更新其数据库并发布触发下一个参与方的事件。

Saga的正常工作路径如下所示：

1. Order Service创建一个处于APPROVAL PENDING状态的Order并发布OrderCreated事件。
2. Consumer Service消费OrderCreated事件，验证消费者是否可以下订单，并发布ConsumerVerified事件。

![image-20221013193121926](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221013193121926.png)

3. Kitchen Service消费OrderCreated事件，验证Order,创建一个处于CREATE PENDING状态的后厨工单Ticket,并发布TicketCreated事件。

4. Accounting Service消费OrderCreated事件并创建一个处于PENDING状态CreditCardAuthorization.

5. Accounting Service消费TicketCreated和ConsumerVerified事件，向消费者的信用卡收费，并发布CreditCardAuthorized事件。

6. Kitchen Service消费CreditCardAuthorized事件并将Ticket的状态更改为AWAITING_ACCEPTANCE·

7. Order Service接收CreditCardAuthorized事件，将Order的状态更改为APPROVED,并发布OrderApproved事件。

Create order Saga还必须**处理Saga参与方拒绝Order并发布某种失败事件的场景**。例如，消费者信用卡的授权可能会失败。Saga必须**执行补偿性事务来撤销已经完成的事务**。图4-5显示了Accounting Service无法授权消费者信用卡时的事件流。

事件的顺序如下：

1. Order Service创建一个处于APPROVAL PENDING状态的Order并发布

![image-20221013194157782](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221013194157782.png)

3. Kitchen Service消费OrderCreated事件，验证Order,创建一个处于CREATE PENDING状态的后厨工单Ticket,并发布TicketCreated事件。

4. Accounting Service消费OrderCreated事件并创建一个处于PENDING状态CreditCardAuthorizationo

5. Account Service消费TicketCreated和ConsumerVerified事件，向消费者的信用卡扣款（失败了），并发布CreditCardAuthorizationFailed事件。

6. Kitchen Service消费CreditCardAuthorizationFailed事件，然后把后厨工单Ticket的状态更改为REJECTED。

7. Order Service消费CreditCardAuthorizationFailed事件，并将Order的状态更改为REJECTED。

#### 编排式Saga

编排式是实现Saga的另外一种方式**。当使用编排式Saga时，开发人员定义一个编排器类，这个类的唯一职责就是告诉Saga的参与方该做什么事情**。Saga编排器**使用命令/异步响应方式**与Saga的参与方服务通信。为了完成Saga中的一个环节，编排器对某个参与方发出一个命令式的消息，告诉这个参与方该做什么操作。当参与方服务完成操作后，会给编排器发送一个答复消息。编排器处理这个消息，并决定Saga的下一步操作是什么

##### 实现编排式的Create order Saga

图4-6显示了Create order Saga的基于编排式的设计。该Saga由CreateorderSaga类编排，该类使用异步请求/响应调用Saga参与方。该类跟踪流程并向Saga参与方发送命令式消息，例如Kitchen Service和Consumer Service。Create order Saga类从其回复通道读取回复消息，然后确定Saga中的下一步（如果有的话)。

Order Service首先创建（实例化）一个Order对象和一个Create order Saga编排器对象。一切正常情况下的流程如下所示：

1. Saga编排器向Consumer Service发送Verify Consumer命令。

2. Consumer Service回复Consumer Verified消息。

3. Saga编排器向Kitchen Service发送Create Ticket命令。

4. Kitchen Service回复Ticket Created消息。

5. Saga编排器向Accounting Service发送Authorize Card消息。

6. Accounting Service使用Card Authorized消息回复。

7. Saga编排器向Kitchen Service发送Approve Ticket命令。

8. Saga编排器向Order Service发送Approve Order命令。

![image-20221013195558569](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221013195558569.png)

请注意，**在最后一步中，Saga编排器会向Order Service发送命令式消息，即使它是Order Service的一个组件**。原则上，Create Order Saga可以通过直接更新Order来批准订单。但为了保持一致性，Saga将Order Service视为另一个参与方。

图4-6描述了Saga的一个场景，但一个Saga可能有很多场景。例如，CreateOrderSaga有4个场景。除了一切正常情况下的流程，由于Consumer Service、KitchenService或Accounting Service的失败，Saga可能会失败。因此，将Saga建模为状态机非常有用，因为它描述了所有可能的场景。

##### 把Saga编排器视为一个状态机

状态机是建模Saga编排器的一个好方法。**状态机由一组状态和一组由事件触发的状态之间的转换组成**。每个转换都可以有一个动作，对Saga来说动作就是对某个参与方的调用。状态之间的转换由Saga参与方执行的本地事务完成触发。**当前状态和本地事务的特定结果决定了状态转换以及执行的动作**（如果有的话)。对状态机也有有效的测试策略。因此，使用状态机模型可以更轻松地设计、实现和测试Saga。

图4-7显示了Create Order Saga的状态机模型。此状态机由多个状态组成，包括以下内容：

- Verifying Consumer:初始状态。当处于此状态时，该Saga正在等待ConsumerService验证消费者是否可以下订单。
- Creating Ticket:该Saga正在等待对Create Ticket命令的回复。
- Authorizing Card:等待Accounting Service授权消费者的信用卡。Order Approved:最终状态，表示该Saga已成功完成。
- Order Rejected:最终状态，表示Order被其中一个参与方拒绝。

![image-20221013200220511](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221013200220511.png)

##### Saga编排和事务性消息

基于编排的Saga的**每个步骤都包括一个更新数据库和发布消息的服务**。例如，OrderService持久化保存Order和Create order Saga编排器，并向第一个Saga参与方发送消息。一个Saga参与方（例如Kitchen Service)通过更新其数据库并发送回复消息，作为对编排器的响应。Order Service通过更新Saga编排器的状态并向下一个Saga参与方发送命令式消息来处理参与方的回复消息。



## 第五章 微服务架构中的业务逻辑设计

由于**业务逻辑散布在多个服务**上，因此在微服务架构中开发复杂的业务逻辑更具挑战性。我们需要解决两个关键问题。首先，典型的**领域模型是由各种类(class)交织在一起的一个网络**。虽然这在单体应用程序中不是问题，但在微服务架构中，类分散在不同的服务中，你需要避免跨越服务边界（也就是进程)的对象引用。第二个挑战是**设计在微服务架构下的业务逻辑**，这些业务逻辑受到微服务下事务管理的种种约束。你的业务逻辑可以在一个服务内部使用ACID事务，但如第4章所述，它必须使用Saga模式来维护服务之间的数据一致性。

幸运的是，我们可以使用**领域驱动设计中的聚合模式**（Aggregate)来解决这些问题。聚合模式下，服务的业务逻辑通过多个聚合组成的一个集合来体现。**聚合是一组对象，可以作为一个单元来处理**。在微服务架构中开发业务逻辑时，聚合可以起到以下两个重要的作用：

- **使用聚合可以避免任何跨服务边界的对象引用**，因为聚合之间通过主键进行引用，而不是通过对象的地址进行引用。
- 由于单**个事务只能创建或更新单个聚合**，因此聚合满足微服务事务模型的约束。因此，我们可以确保单个服务中的事务都满足ACID特性。

本章将从描述组织业务逻辑的两种不同方法（事务脚本模式和领域建模模式）开始。接下来，我将介绍领域驱动设计中的聚合概念，并解释为什么可以用聚合来构建服务的业务逻辑。在这之后，我将描述领域事件模式，并解释领域事件对服务发布事件的价值。在本章末尾，我会提供几个来自Kitchen Service和Order Service的业务逻辑开发实例。

### 业务逻辑组织模式

图5-1显示了一个典型的服务架构。如第2章所述，**业务逻辑是六边形架构的核心**。**业务逻辑的周围是入站和出站适配器。入站适配器处理来自客户端的请求并调用业务逻辑。出站适配器被业务逻辑调用，然后它们再调用其他服务和外部应用程序**。

此服务由业务逻辑和以下适配器组成。

- REST API adapter:**入站适配器**，实现REST API,这些API会调用业务逻辑。
- OrderCommandHandlers:**入站适配器**，它接收来自消息通道的**命令式消息**，并调用业务逻辑。
- Database Adapter:由业务逻辑调用**以访问数据库的出站适配器**。
- Domain Event Publishing Adapter:**将事件发布到消息代理的出站适配器**。

![image-20221013201955382](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221013201955382.png)

**业务逻辑通常是服务中最复杂的部分**。在开发业务逻辑时，你应该以最适合应用程序的方式，精心地设计和组织业务逻辑。我确信大多数读者都经历过不得不维护别人的糟糕代码的挫败感。大多数企业应用程序都是用面向对象的语言编写的，例如Java,因此它们由类和方法组成。但是使用面向对象的语言并不能保证业务逻辑具有面向对象的设计。在开发业务逻辑时必须做出的关键决策是选用面向对象的方式，还是选用面向过程的方式。**组织业务逻辑有两种主要模式：面向过程的事务脚本模式和面向对象的领域建模模式**。

#### 使用事务脚本模式设计业务逻辑

可以编写一个**称为事务脚本的方法来处理来自表示层的每个请求**，而不是进行任何面向对象的设计。如图5-2所示，这种方法的一个重要特征是实现行为的类与存储状态的类是分开的。

![image-20221013203259467](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221013203259467.png)

**使用事务脚本模式时，脚本通常位于服务类中**，在此示例中是OrderService类。每个服务类都有一个用于请求或系统操作的方法。这个方法实现该请求的业务逻辑。它使用数据访问对象(DAO)访问数据库，例如OrderDao。数据对象（在此示例中为Order类）是纯数据，几乎没有行为。

> 模式：事务脚本
>
> 将业务逻辑组织为面向过程的事务脚本的集合，每种类型的请求都有一个脚本。

这种设计风格是高度面向过程的，仅仅依赖于面向对象编程(OOP)语言的少量功能。就好比你使用C或其他非OOP语言编写应用所能实现的功能。然而，在适当的时候，你不应该羞于使用面向过程的设计。这种方法适用于简单的业务逻辑。但这往往不是实现复杂业务逻辑的好方法。

#### 使用领域模型模式设计业务逻辑

面向过程方法的可以简单迅速地搞定项目，这非常诱人。你可以专注编写业务逻辑代码，而无须仔细考虑如何设计和组织各种类。但是问题在于，如果业务逻辑变得复杂，你最终可能会得到噩梦般难以维护的代码。实际上，就像单体应用程序不断增长的趋势一样，事务脚本也存在同样的问题。因此，除非是编写一个非常简单的应用程序，否则你应该抵制编写面向过程代码的诱惑，使用领域模型模式，并进行面向对象的设计。

> 模式：领域模型
>
> 将业务逻辑组织为由具有状态和行为的类构成的对象模型。

**在面向对象的设计中，业务逻辑由对象模型和相对较小的一些类的网络组成**。这些类通常直接对应于问题域中的概念。在这样的设计中，有些类只有状态或行为，但很多类同时包含状态和行为，这样的类都是精心设计的。图5-3显示了领域模型模式的示例。

![image-20221013203655842](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221013203655842.png)



#### 关于领域驱动设计

领域驱动设计(Domain-Driven Design,DDD)的概念产生于Eric Evans写的《DomainDriven Design》e一书，DDD是对面向对象设计的改进，是开发复杂业务逻辑的一种方法。我在第2章介绍过DDD,领域驱动设计的子域概念有助于把应用程序分解为服务。使用DDD时，每个服务都有自己的领域模型，这就避免了在单个应用程序全局范围内的领域模型问题。子域和相关联的限界上下文的相关概念是两种战略性DDD模式。

DDD还有一些战术性模式，它们是领域模型的基本元素（building block)。每个模式都是一个类在领域模型中扮演的角色，并定义了类的特征。开发人员广泛采用的基本元素包括以下几种。

- 实体(entity):**具有持久化ID的对象**。**具有相同属性值的两个实体仍然是不同的对象**。在Java EE应用程序中，使用JPA@Entity进行持久化的类通常是DDD实体。
- 值对象(value object):**作为值集合的对象**。**具有相同属性值的两个值对象可以互换使用**。值对象的一个例子是Money类，它由币种和金额组成。
- 工厂(factory):**负责实现对象创建逻辑的对象或方法**，该逻辑过于复杂，无法由类的构造函数直接完成。它还可以隐藏被实例化的具体类。工厂方法一般可实现为类的静态方法。
- 存储库（repository)：**用来访问持久化实体的对象**，存储库也封装了访问数据库的底层机制
- 服务(service):**实现不属于实体或值对象的业务逻辑的对象**。

许多开发人员都使用这些基本元素，有些基本元素是通过JPA和Spring框架等实现的。除了DDD纯粹主义者之外，还有一个被众人（包括我在内）忽略的基本元素：**聚合**。事实证明，在开发微服务时，聚合是一个非常有用的概念。让我们首先来看一看，聚合如何解决经典面向对象设计的一些微妙问题。

### 使用聚合模式设计领域模型

**在传统的面向对象设计中，领域模型由一组类和它们之间的关系组成，这些类通常被组织成包**。图5-4显示了FTGO应用程序的领域模型的一部分。它是一个典型的领域模型，由一组互相关联的类组成。

![image-20221013204836970](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221013204836970.png)

这个例子包含与业务对象相对应的多个类：Consumer、Order、Restaurant和Courier.。但有趣的是，**这种传统领域模型缺少每个业务对象的明确边界**。例如，它没有指定哪些类是Order业务对象的一部分。缺乏边界有时会导致问题，尤其是在微服务架构中。

我从讨论由于缺少明确的边界而导致的具体问题开始本节。接下来，我将描述聚合的概念以及它如何具有明确的边界。之后，我会介绍聚合必须遵守的规则，以及这些规则如何使聚合在微服务架构中很好地发挥作用。我将强调如何选择聚合的边界，以及边界的重要性。最后，我将讨论如何使用聚合来设计业务逻辑。我们先来看一看模糊边界所带来的问题。

#### 模糊边界所带来的问题

假设你想要在Order业务对象上执行操作，例如加载或删除。这到底是什么意思呢？操作范围是什么？当然你会加载或删除Order对象。但实际上，订单中的Order不仅仅是Order对象。还有订单行项目、付款信息等。在图5-4所示的模型中，如何划定领域对象的边界其实是由开发人员拍脑袋决定的。

除了概念模糊之外，**缺少明确的边界会在更新业务对象时导致问题**。典型的业务对象具有一些不变量，即必须始终强制执行的业务规则。例如，Order具有最小订单金额。FTGO应用必须始终确保任何更新订单的尝试都不违反最低订单金额这个不变量约束。挑战在于，为了强制执行这些不变量约束，你必须仔细设计业务逻辑。

#### 聚合拥有明确的边界

**聚合是一个边界内的领域对象的集群，可以将其视为一个单元**。它由根实体和可能的一个或多个其他实体和值对象组成。许多业务对象都被建模为聚合。例如，在第2章中，我们通过分析需求中使用的名词，与领域专家一起创建过粗略的领域模型。许多这些名词，如Order、Consumer和Restaurant,都是聚合。

> 模式：聚合
>
> 将领域模型组织为聚合的集合，每个聚合都是可以作为一个单元进行处理的一组对象构成的图。

图5-5显示了Order聚合及其边界。Order聚合由Order实体、一个或多个Order-LineItem值对象以及其他值对象（如Address和PaymentInformation)组成。

![image-20221013205931899](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221013205931899.png)

聚合将领域模型分解为块，单独的每一块更容易理解。它们还阐明了加载、更新和删除等操作的范围。这些操作作用于整个聚合而不是部分聚合。**聚合通常从数据库中完整加载，从而避免了延迟加载所导致的任何复杂性**。删除聚合会从数据库中删除其所有对象。

##### 聚合代表了一致的边界

**更新整个聚合而不是聚合的一部分，可以解决前面例子中遇到的一致性问题**。**在聚合根上调用更新操作**，这会强制执行各种不变量约束。此外，可以使用例如版本号或数据库级锁锁定聚合根来处理并发性。例如，客户端必须在Order聚合的根上调用方法，而不是直接更新订单项的数量，这会强制执行包括最小订单金额在内的各种不变量约束。但请注意，此方法不需要在数据库中更新整个聚合。例如，应用程序可能只更新与Order对象和更新的OrderLineItem相对应的行。

##### 识别聚合是关键

在领域驱动设计中，设计领域模型的关键部分是识别聚合，以及它们的边界和根。聚合内部结构的细节是次要的。然而，聚合的价值不仅仅是帮助我们设计模块化的领域模型。更重要的是聚合必须遵守某些规则。

#### 聚合的规则

领域驱动设计要求聚合遵守一组规则。这些规则确保聚合是一个可以强制执行各种不变量约束的自包含单元。让我们来看看每个规则。

##### **规则一：只引用聚合根**

前面的例子说明了直接更新Order工ineItems可能引发业务规则失效问题。第一个聚合规则的目标是消除这个问题。它**要求聚合根是聚合中唯一可以由外部类引用的部分**。客户端只能通过调用聚合根上的方法来更新聚合。

例如，服务使用存储库从数据库加载聚合并获取对聚合根的引用。它通过在聚合根上调用方法来更新聚合。此规则可确保聚合能够强制执行各种不变量约束。

##### 规则二：聚合间的引用必须使用主键

另一个规则是**引用聚合必须通过标识（例如，主键)而不是对象引用**。例如，如图5-6所示，Order使用consumerId引用其Consumer,而不是直接引用Consumer对象。同样，Order使用restaurantId引用Restaurant聚合。

这种方法与传统的对象建模完全不同，传统的对象建模将领域模型中的外键视为不好的设计。使用标识（例如，主键）而不是对象引用意味着聚合是松耦合的。它确保聚合之间的边界得到很好的定义，并避免意外更新不同的聚合。此外，如果聚合是另一个服务的一部分，则不会出现跨服务的对象引用问题。

聚合同时也是存储的单元，因此这种方法让持久化也变得简单。我们可以更容易地将聚合存储在NoSQL数据库（如MongoDB)中。通过主键引用聚合，因此不再需要透明延迟加载(transparent lazy loading,同时也避免了它所带来的问题。通过分片(sharding)聚合来横向扩展数据库也相对简单。

![image-20221013211827904](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221013211827904.png)

##### 规则三：在一个事务中，只能创建或更新一个聚合

聚合必须遵守的另一个规则是**一个事务只能创建或更新一个聚合**。多年前第一次读到它时，我感觉这条规则毫无意义！当时，我正在开发使用关系型数据库的传统单体应用程序，因此事务可以更新多个聚合。今天，这个约束对于微服务架构来说是完美的。它可以**确保单个事务的范围不超越服务的边界**。此约束还满足大多数NoSQL数据库的受限事务模型。

这个规则让创建或更新多个聚合的操作变得更加复杂。但这正是Saga(第4章中描述过)旨在解决的问题。Saga的每一步都只创建或更新一个聚合。图5-7显示了它的工作原理。

![image-20221013212039583](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221013212039583.png)

在此示例中，Saga由三个事务组成。第一个事务更新服务A中的聚合X。其他两个事务都在服务B中。一个事务更新聚合X,另一个更新聚合Y。

**在单个服务中维护多个聚合的一致性的另一种方法是打破聚合规则，在一个事务中更新多个聚合**。例如，服务B可以在单个事务中更新聚合Y和Z。只有在使用支持复杂事务模型的数据库（如关系型数据库）时才能实现此目的。如果你使用的NoSQL数据库只有简单的事务，除了使用Saga之外别无选择。

事实证明，聚合边界并非一成不变。在开发领域模型时，你可以选择边界所在的位置，但需要非常小心。

#### 聚合的颗粒度

在开发领域模型时，你**必须做出的关键决策是决定每个聚合的大小**。一方面，**聚合理想上应该很小**。由于每个聚合的更新都是序列化的，因此更细粒度的聚合将提高应用程序能同时处理的请求数量，从而提高可扩展性。它还将改善用户体验，因为它降低了两个用户尝试同时更新一个聚合而引发冲突的可能性。但是另一方面，因为聚合是事务的范围，所以你可能需要定义更大的聚合以使特定的聚合更新操作满足事务的原子性。

#### 使用聚合设计业务逻辑

在典型的（微）服务中，大部分业务逻辑由聚合组成。其余的业务逻辑存在于领域服务和Saga中。Saga编排本地事务的序列，以确保数据的一致性。服务是业务逻辑的入口，由入站适配器调用。服务使用存储库从数据库中检索聚合或将聚合保存到数据库。每个存储库都由访问数据库的出站适配器实现。图5-9显示了Order Service基于聚合设计的业务逻辑。

![image-20221013213013733](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221013213013733.png)

### 发布领域事件

韦博词典（https:lwww,merriam-webster..com/dictionary/event)列出了事件(Event)这个单词的几个定义，包括：

1.发生的事情。

2.一件值得注意的事情。

3.社交场合或活动。

4.不良或有害的医疗事故，心脏病发作或其他心脏事件。

在领域驱动设计的上下文中，**领域事件是聚合发生的事情**。它由领域模型中的一个类表示。**事件通常代表状态的变化**。例如，考虑FTG0应用程序中的Order聚合。其状态变化事件包括Order Created、Order Cancelled、Order Shipped等。Order聚合可以在每次进行状态变化时发布一个或多个事件，给那些感兴趣的接收方。

> 模式：领域事件
>
> 聚合在被创建时，或发生其他重大更改时发布领域事件。

#### 为什么需要发布变更事件

领域事件很有用，因为应用程序的其他协作方（比如客户端、其他应用程序或同一应用程序中的其他组件)通常有兴趣了解聚合的状态更改。以下是一些可能的场景：

- **使用基于编排的Saga维护服务之间的数据一致性**，如第4章所述。通知维护数据副本的服务，源数据已经发生了更改。这种方法称为**命令查询职责隔离**(CQRS),我会在第7章中进行详细介绍。
- 通过Webhook或消息代理通知不同的应用程序，以**触发下一步业务流程**。
- **按顺序通知同一应用程序的不同组件**，例如，将WebSocket消息发送到用户的浏览器或更新如ElasticSearch这样的文本数据库。
- 向用户发送短信或电子邮件通知，告诉他们订单已发货、他们的医疗处方已准备就绪，或者他们的航班延误。
- 监控领域事件以验证应用程序是否正常运行。
- 分析领域事件，为用户行为建模。

在所有这些场景中，领域事件都是由应用程序数据库中聚合的状态更改所触发的。

#### 什么是领域事件

**在命名领域事件时，我们往往选择动词的过去分词**。这样的命名能够明确表达事件的一些属性。**领域事件的每个属性都是原始值或值对象**。例如，OrderCreated事件类具有orderId属性。

**领域事件通常还具有元数据**，例如事件ID和时间戳。它也可能包含执行了此次更改的用户的身份，因为这对用户行为审计很有用。元数据可以是事件对象的一部分，可能在超类中定义。**事件元数据也可以位于封装事件对象的“信封对象”中**。触发事件的聚合的ID也可以是事件“信封对象”的一部分，而不是明确的事件属性。

#### 事件增强

想象一下，你正在编写一个处理Order领域事件的事件接收方。**之前定义的OrderCreated事件类涵盖了已发生事件的本质**。但是在处理OrderCreated事件时，**事件接收方可能需要订单的详细信息**。一种选择是从Order Service中检索该信息，让事件接收方查询聚合服务，但这样做的缺点是它会产生服务请求的开销。

另一种称为事件增强的方法是，事件包含接收方需要的信息。它简化了事件接收方，因为他们不再需要从发布事件的服务请求数据。在OrderCreated事件中，Order聚合可以通过包含订单详细信息来增强事件。

#### 识别领域事件

有一些不同的策略可用于识别领域事件。通常，软件的需求会描述需要发送通知的场景。**需求可能包括诸如“当X发生时做Y”之类的语言**。例如，FTGO应用程序中的一个需求是“当下订单时，向消费者发送电子邮件”，这个需求表明这里存在一个领域事件。

另一种越来越流行的方法是使用**事件风暴**。**事件风暴是一种以事件为中心的研讨会，用于理解复杂的领域**。它的具体方法是：把领域专家聚集在一个屋子里，准备大量便笺和一个非常大的白板。事件风暴的结果是一个以事件为中心的领域模型，它由聚合和事件组成。事件风暴包括三个主要步骤：

1. 头脑风暴：请求领域专家集体讨论领域事件。领域事件由橙色便笺表示，这些便笺在白板上按照时间轴顺序摆放。

2. 识别事件触发器：请求领域专家确定每个事件的触发器，例如：

   - 用户操作，表示为使用蓝色便笺的命令。

   - 外部系统，由紫色便笺表示。

   - 另一个领域事件。

   - 时间的流逝。

3. 识别聚合：请求领域专家识别那些使用命令的聚合并发出相应的事件。聚合由黄色便笺表示。事件风暴是快速创建领域模型的有效技术。

现在我们已经介绍了领域事件的基础知识，再来看一下生成和发布它们的机制。

#### 生成和发布领域事件

**使用领域事件进行通信是第3章中讨论的异步消息传递的一种形式**。但在业务逻辑将它们发布到消息代理之前，它必须首先生成领域事件。我们来看看如何做到这一点。

##### 生成领域

事件从概念上讲，**领域事件由聚合负责发布**。聚合知道其状态何时发生变化，从而知道要发布的事件。聚合可以直接调用消息传递API。这种方法的弊端在于，由于聚合不能使用[依赖注入](https://juejin.cn/post/6844904071657160717)，所以消息传递API需要作为方法参数传递。这将把基础设施和业务逻辑交织在一起，是非常不可取的。

更好的方法是在**聚合和调用它的服务（或类）之间分配职责**。服务可以使用依赖注入来获取对消息传递API的引用，从而轻松发布事件。只要状态发生变化，聚合就会生成事件并将它们返回给服务。聚合可以通过几种不同的方式将事件返回给服务。一种选择是在聚合方法的返回值中包括一个事件列表。

*依赖注入：**将依赖的类作为 形参放入依赖的类中 就成为依赖注入***

##### **如何可靠地发布领域事件**

第3章我们讨论了如何可靠地发送消息，例如把消息发送作为本地数据库事务的一部分。领域事件也不例外。**服务必须使用事务性消息来发布事件，以确保领域事件是作为更新数据库中聚合的事务的一部分对外发布**。第3章中描述的Eventuate Tram框架实现了这样一种机制。它将事件插入到OUTBOX表中，作为更新数据库的ACID事务的一部分。事务提交后，插入到OUTBOX表中的事件将发布到消息代理。

#### 消费领域事件

**领域事件最终作为消息发布到消息代理**，例如Apache Kafka。**领域事件的接收方可以直接使用事件代理的客户端API**。但是使用更高级的API比较方便，例如第3章中描述的Eventuate Tram框架的DomainEventDispatcher。DomainEventDispatcher可以将领域事件调度到适当的处理程序方法。



## 第六章 使用事件溯源开发业务逻辑

### 使用事件溯源开发业务逻辑概述

**事件溯源**是构建业务逻辑和持久化聚合的另一种选择。它**将聚合以一系列事件的方式持久化保存**。每个事件代表聚合的一次状态变化。应用程序通过重放(replaying)事件来重新创建聚合的当前状态。

> 模式：事件溯源
>
> 使用一系列表示状态更改的领域事件来持久化聚合。

事件溯源有几个重要的好处。例如，它保留了聚合的历史记录，这对于实现审计和监管的功能非常有帮助。它可靠地发布领域事件，这在微服务架构中特别有用。事件溯源也有弊端。它有一定的学习曲线，因为这是一种完全不同的业务逻辑开发方式。此外，查询事件存储库通常很困难，这需要你使用第7章中描述的CQRS模式。

我将通过描述传统持久化技术的局限性来开始本节。然后，我会详细描述事件溯源技术，并讨论它是如何克服这些局限性的。之后，我将展示如何使用事件溯源来实现Order聚合。最后，我将描述事件溯源的好处和弊端。

#### 传统持久化技术的问题

大多数企业应用程序以这种方式保存数据，但它有几个弊端：

- 对象与关系的“阻抗失调”(impedance mismatch)。关系型数据的表格结构模式，与领域模型及其复杂关系的图状结构之间，存在基本的概念不匹配问题
- 缺乏聚合历史。**传统持久化的另一个限制是它只存储聚合的当前状态**。聚合更新后，其先前的状态将丢失。
- 实施审计功能将非常烦琐且容易出错。**许多应用程序必须维护审计日志，用于跟踪哪些用户更改了聚合**
- 事件发布凌驾于业务逻辑之上。**传统持久化的另一个限制是它通常不支持发布领域事件**

#### 什么是事件溯源

**事件溯源是一种以事件为中心的技术，用于实现业务逻辑和聚合的持久化**。聚合作为一系列事件存储在数据库中。每个事件代表聚合的状态变化。**聚合的业务逻辑围绕生成和使用这些事件的要求而构建**。

##### 事件溯源通过事件来持久化聚合

事件溯源采用基于领域事件的概念来实现聚合的持久化，这是一种非同寻常的方法。它**将每个聚合持久化为数据库中的一系列事件，我们称之为事件存储**。

以Order聚合为例。如图6-2所示，事件溯源不是将每个Order作为一行存储在ORDER表中，而是将每个Order聚合持久化为EVENTS表中的一行或多行。每行都是跟Order聚合有关的一个领域事件，例如Order Created、Order Approved、OrderShipped,等等。

![image-20221014103237420](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014103237420.png)

**当应用程序创建或更新聚合时，它会将聚合发出的事件插入到EVENTS表中**。应用程序通过从事件存储中检索并重放事件来加载聚合。具体来说，加载聚合包含以下三个步骤：

1. 加载聚合的事件。
2. 使用其默认构造函数创建聚合实例。
3. 调用apply()方法谝历事件。

**事件溯源通过加载事件和重放事件来重建聚合的内存状态**，这对一些开发人员来说可能是新奇和陌生的做法。它与JPA或Hibernate等ORM框架加载实体的方式并不完全不同。ORM框架通过执行一个或多个SELECT语句检索当前对象的持久化状态，并使用其默认构造函数实例化对象，从而实现加载对象。它使用反射机制来初始化这些对象。事件溯源的不同之处在于使用事件完成实例内存状态的重建。

##### 事件代表状态的改变

**使用事件溯源时，事件不再是可有可无的**。包括创建在内的每一个聚合状态变化，都由领域事件表示。每当聚合的状态发生变化时，它必须发出一个事件。例如，Order聚合必须在创建时发出OrderCreated事件，并在更新时发出Order*事件。这是一个比以前更严格的要求，在此之前，聚合只需要发出那些外部接收方感兴趣的事件。而且，**事件中必须包含聚合执行状态变化所需的数据**。**聚合的状态由构成聚合对象的字段值组成**。状态更改可能与更改对象字段的值一样简单，例如Order.state。或者，状态更改可能涉及添加或删除聚合中的对象，例如修改Order的订单项。

##### 聚合方法都和事件相关

**业务逻辑通过调用聚合根上的命令方法（command method)来处理对聚合的更新请求**。在传统的应用程序中，命令方法通常会验证其参数，然后更新一个或多个聚合字段。基于事件溯源的应用程序中的命令方法则通过生成事件来起作用。如图6-4所示，调用聚合命令方法的结果是一系列事件，表示必须进行的状态更改。这些事件将保存在数据库中，并应用于聚合以更新其状态。

![image-20221014104859019](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014104859019.png)

**生成事件并应用(apply)事件的做法将导致对业务逻辑的重构**。事件溯源将命令方法重构为两个或更多个方法。第一个方法接收命令对象参数，该参数表示具体的请求，并确定需要执行哪些状态更改。它验证命令对象的参数，并且在不更改聚合状态的情况下，返回表示状态更改的事件列表。如果无法执行该命令，则此方法通常会引发异常。

其他方法都将特定事件类型作为参数来更新聚合。这些方法与聚合产生的事件类型一一对应。重要的是要注意执行这些方法不会出现失败，因为这些事件代表了一个已经发生的状态变化。每个方法都会根据事件更新聚合。

Eventuate Client框架是一个事件溯源框架，在6.2.2节中有更详细的描述，它将这些方法命名为process()和apply()。process()方法将包含更新请求的命令对象作为参数，并返回事件列表。apply()方法将事件作为参数，并返回空(VOID)。聚合将定义这些方法的多个重载版本：每个命令类有一个process()方法，聚合发出的每个事件类型都有一个与之对应的apply()方法。

**创建聚合**的步骤如下：

1. 使用聚合的默认构造函数实例化聚合根。

2. 调用process()以生成新事件。

3. 遍历新生成的事件并调用apply()来更新聚合的状态。

4. 将新事件保存在事件存储库中。

**更新聚合**的步骤如下：

1. 从事件存储库加载聚合事件。

2. 使用其默认构造函数实例化聚合根。

3. 遍历加载的事件，并在聚合根上调用apply()方法。

4. 调用其process()方法以生成新事件。

5. 遍历新生成的事件并调用apply()来更新聚合的状态。

6. 将新事件保存在事件存储库中。

#### 使用乐观锁处理并发更新

两个或多个请求同时更新同一聚合的情况并不少见。使用传统持久化技术的应用程序通常使用乐观锁来防止一个事务覆盖另一个事务的更改。**乐观锁通常使用版本列来检测聚合自读取以来是否已更改**。应用程序将聚合根映射到具有VERSION列的表，每当更新聚合时，该列都会递增。应用程序使用UPDATE语句更新聚合，如下所示：

```
UPDATE AGGREGATE ROOT TABLE
SET VERSIONVERSION 1...
WHERE VERSION <original version>
```

**只有当前版本和应用程序读取聚合时的版本一致时，此UPDATE语句才会成功**。如果两个事务读取相同的聚合，则第一个更新聚合的事务将成功。第二个将失败，因为版本号已更改，因此它不会意外覆盖第一个事务的更改。事件存储库也可以使用乐观锁来处理并发更新。每个聚合实例都有一个与事件一起读取的版本号。当应用程序插入事件时，事件存储会验证版本是否未更改。一种简单的方法是使用事件数作为版本号。或者，正如你将在6.2节中看到的那样，**事件存储库可以维护一个显式的版本号**。

#### 事件溯源和发布事件

**严格来说，事件溯源将聚合作为事件进行持久化，并从这些事件中重建聚合的当前状态**。你还可以将事件溯源作为可靠的事件发布机制。在事件存储库中保存事件本质上是一个原子化的操作。我们需要实现一种机制，将这些持久化保存的事件传递给所有感兴趣的消费者。

**第3章描述了几种不同的机制，例如轮询和事务日志拖尾，这些机制可以把插入到数据库中的消息作为事务一部分的对外发布**。基于事件溯源的应用程序可以使用这些机制之一发布事件。主要区别在于它将事件永久存储在EVENTS表中，而不是暂时将事件保存在OUTBOX表中，后者在事件发布后会将其删除。

#### 使用快照提升性能

在一个order聚合的生命周期中往往不会发生很多次状态转换，因此它只有少量事件查询事件存储库，找到这些事件并重新构建Order聚合是可行的。但是，长生命周期的聚合可能会有大量事件。例如，Account聚合可能包含大量事件。随着时间的推移，加载和重放这些事件会变得越来越低效。

常见的解决方案是**定期持久保存聚合状态的快照**。图6-7显示了使用快照的示例。应用程序通过加载最新快照以及仅加载快照后发生的事件来快速恢复聚合状态。

![image-20221014110811692](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014110811692.png)

在此示例中，快照版本为N。应用程序仅需要加载快照及其后面的两个事件，以便恢复聚合的状态。不再需要从事件存储库中加载之前的N个事件。

从快照恢复聚合状态时，应用程序首先从快照创建聚合实例，然后遍历快照之后的事件并应用它们。

使用快照时，将从快照创建聚合实例，而不是使用其默认构造函数创建聚合实例。如果聚合具有简单、易于串行化的结构，则快照可以使用JSON序列化。复杂结构的聚合可以使用Memento模式进行快照(https:/en.wikipedia.org/wiki/Memento_pattern)。

#### 幂等方式的消息处理

服务通常会消费来自其他应用程序或其他服务的消息。例如，服务可能会消费聚合发布的领域事件，或Saga编排器发送的命令式消息。如第3章所述，**开发消息接收方需要注意的重要问题是确保它是幂等的，因为消息代理可能会多次传递相同的消息**。

如果可以使用相同的消息多次安全地调用消息接收方，则消息接收方是幂等的。例如，Eventuate Tram框架通过检测和丢弃重复消息来实现幂等的消息处理。它将已处理消息的id记录在PROCESSED MESSAGES表中，作为业务逻辑用于创建或更新聚合的本地ACID事务的一部分。如果消息的ID在PROCESSED MESSAGES表中，则它是重复的并可以被丢弃。基于事件溯源的业务逻辑必须实现类似的机制。具体的实现方式取决于事件存储库是关系型数据库还是NoSQL数据库。

- 基于关系型数据库事件存储库的幂等消息处理:如果应用程序使用基于关系型数据库的事件存储库，则它可以使用相同的方法来检测和丢弃重复消息。它**将消息ID插入PROCESSED MESSAGES表，作为插入EVENTS表的事件的事务的一部分**。
- 基于非关系型数据库事件存储库的幂等消息处理:消息消费者把消息的ID存储在处理它时生成的事件中。它**通过验证聚合的所有事件中是否包含该消息ID来做重复检测**。使用此方法的挑战是处理一些消息时可能不会生成任何事件。缺少事件意味着没有处理过消息的记录。随后重新传递和重新处理相同的消息可能会导致错误的行为。

#### 领域事件的演化

**事件溯源在概念上将会永久存储事件，而这是一把双刃剑**。一方面，它能为应用程序提供准确的更改信息的审计日志。它还使应用程序能够重建聚合的历史状态。另一方面，它也会带来一个挑战，因为事件的结构经常随着时间的推移而变化。

**应用程序可能需要处理多个事件版本**。例如，加载Order聚合的服务可能需要处理多个版本的事件。同样，事件订阅者可能会看到多个版本。

让我们首先看看事件可以演化的不同方式，然后介绍一种常用的处理事件演化的方法。

##### 事件结构的演化

从概念上讲，事件溯源应用程序的结构(Schema)分为三个层次：

- 由一个或多个聚合组成。
- 定义每个聚合发出的事件。
- 定义事件的结构。

表6-1显示了每个级别可能发生的不同类型的更改。

![image-20221014111938217](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014111938217.png)

```
向前兼容和向后兼容
向前兼容对应的英文是 forward compatibility 或 upward compatibility。
向后兼容对应的英文是 backward compatibility 或 downward compatibility。
向前兼容表示旧版本的系统可以接受新版本的数据，是旧版本对新版本的兼容。
向后兼容表示新版本的系统可以接受旧版本的数据，是新版本对旧版本的兼容。
我们一般会认为向前兼容是向之前的版本兼容，这个理解其实是错误的。
线上项目的开发中，向后兼容非常重要。
```

##### 通过向上转换(Upcasting)来管理结构的变化

**在SQL数据库的世界中，通常使用模式（结构）迁移来处理对数据库结构的更改**。每个结构更改都由迁移表示，这是一个更改结构并将数据迁移到新模式的SQL脚本。结构迁移脚本存储在版本控制系统中，并使用Flyway 等工具应用于数据库。

事件溯源应用程序可以使用类似的方法来处理非向后兼容的更改。但是，事件溯源框架不是将事件迁移到新的版本，而是在从事件存储库加载事件时执行转换。通常用称为“向上转换”(upcaster)的组件将各个事件从I旧版本更新为更新的版本。因此，应用程序代码只需处理当前事件结构。

#### 事件溯源的好处与坏处



### 实现事件存储库

使用事件溯源的应用程序将事件存储在事件存储库中。**事件存储库是数据库和消息代理功能的组合。它表现为数据库，因为它具有用于通过主键插入和检索聚合事件的API。它表现为消息代理，因为它有一个用于订阅事件的API**。



### 同时使用Saga和事件溯源

**事件溯源可以轻松使用基于协同式的Saga**。**参与方交换其聚合发出的领域事件。每个参与方的聚合都可以处理命令和发出新事件**。你需要编写聚合和事件处理程序类，这些事件处理程序负责更新聚合。但是，将基于事件溯源的业务逻辑与基于编排的Saga相结合更具挑战性。因为事件存储库的事务处理能力可能非常有限。使用某些事件存储库时，应用程序只能创建或更新单个聚合并发布生成的事件。但是，Saga的每一步都包含几个必须**以原子化方式执行**的动作：

- Saga创建：启动Saga的服务必须以原子方式创建或更新聚合，并同时创建Saga编排器。例如，Order Service的createorder()方法必须同时创建Order聚合和Createordersaga.
- Saga编排器：一个Saga编排器必须以原子方式消费回复（消息），更新其状态并发送命令式消息。
- Saga参与方：Saga的参与方服务，例如Kitchen Service和Order Service,必须自动接收消息、检测和丢弃重复消息、创建或更新聚合，以及发送回复消息。



## 第七章 在微服务架构中实现查询

为了支持用户界面，FTGO应用程序需要实现各种查询操作。在现有的单体应用程序中实现这些查询相对简单，因为它有一个单独的数据库。在大多数情况下，所有FTGO开发人员需要做的是编写SQL SELECT语句并定义必要的索引。正如玛丽所发现的那样，在微服务架构中编写查询非常具有挑战性。**查询通常需要检索分散在多个服务所拥有的数据库中的数据**。但是，你不能使用传统的分布式查询处理机制，因为即使技术上可行，它也会打破服务之间的隔离和封装。

在微服务架构中实现查询操作有两种不同的模式：

- API组合模式：这是最简单的方法，应尽可能使用。它的工作原理是让拥有数据的服务的客户端负责调用服务，并组合服务返回的查询结果。
- 命令查询职责隔离（CQRS)模式：它比API组合模式更强大，但也更复杂。它维护一个或多个视图数据库，其唯一目的是支持查询。

在讨论了这两种模式之后，我将介绍如何设计CQS视图，然后展示视图的实现例子。让我们首先看一看API组合模式。

### 使用API组合模式进行查询

#### 什么是API组合模式

我们可以使用API组合模式实现查询操作，例如findorder(),它会检索多个服务所拥有的数据。这个模式通过调用拥有数据的服务并组合结果来实现查询操作。图7-2显示了该模式的结构。它有两种类型的参与者：

- API组合器：它通过查询数据提供方的服务来实现查询操作。
- 数据提供方服务：拥有查询返回的部分数据的服务。

图7-2显示了三个提供方服务。**API组合器通过从提供方服务检索数据并组合结果来实现查询**。API组合器可能是需要数据呈现网页的客户端，例如Wb应用程序。或者，它可能是一个服务，例如API Gateway及第8章中描述的后端前置模式,这个模式将查询操作公开为API接口。

![image-20221014114406631](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014114406631.png)

> 模式：API组合
>
> 通过查询每个服务的API并组合结果，实现从多个服务检索数据的查询。

#### API组合模式的设计缺陷

使用此模式时，你必须解决两个设计问题：

- 确定架构中的哪个组件是查询操作的API组合器。
- 如何编写有效的聚合逻辑

#### API组合模式的好处和弊端

此模式是在微服务架构中实现查询操作的简单直观方式。

但它也有一些缺点：

- 增加了额外的开销。
- 带来可用性降低的风险。
- 缺乏事务数据一致性。

### 使用CQRS模式

许多企业级应用程序使用关系型数据库作为数据记录的事务系统，并使用文本搜索数据库（如Elasticsearch或Solr)进行文本搜索查询。某些应用程序可以通过同时写入来保持数据库同步。然后再定期将数据从关系型数据库复制到文本搜索引擎中。**具有此架构的应用程序利用了多个数据库的优势：关系型数据库的事务属性和文本数据库的查询功能**。

> 模式：命令查询职责隔离(CQRS)
>
> 使用事件来维护从多个服务复制数据的只读视图，借此实现对来自多个服务的数据的查询。

CQRS是这种架构的概括。它**维护一个或多个视图数据库，而不仅仅是文本搜索数据库，进而实现一个或多个应用程序的查询**。为了理解这个概念，我们将查看一些使用API组合模式无法有效实现的查询。我将解释CQRS的工作原理，然后讨论CQRS的优点和弊端。下面，我们先来看看何时需要使用CQRS。

#### 为什么要使用CQRS



#### 什么是CQRS

节中描述的例子强调了在微服务架构中实现查询时经常会遇到的三个问题：

- 使用API组合模式检索分散在多个服务中的数据会导致昂贵、低效的内存中连接。
- 拥有数据的服务将数据存储在不能有效支持所需查询的表单或数据库中。
- 隔离问题的考虑意味着，拥有数据的服务不一定是会实现查询操作的服务。

所有这三个问题的解决方案是使用CQRS模式。

##### CQRS隔离命令和查询

CQRS是**命令查询职责隔离**（Command Query Responsibility Segregation)的简称，顾名思义，它涉及隔离或问题的分隔。如图7-8所示，它将持久化数据模型和使用数据的模块分为两部分：**命令端和查询端**。**命令端模块和数据模型实现创建、更新和删除操作**（缩写为CUD,例如：HTTP POST、PUT和DELETE)。**查询端模块和数据模型实现查询**（例如HTTPGET)。查询端通过订阅命令端发布的事件，使其数据模型与命令端数据模型保持同步。

![image-20221014115202780](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014115202780.png)

**服务的非CQRS和CQRS版本都包括由各种CRUD操作组成的API**。在基于非CQRS的服务中，这些操作通常由映射到数据库的领域模型实现。为了提高性能，一些查询可能会绕过领域模型并直接访问数据库。持久化数据模型同时支持命令端和查询端。

在基于CQRS的服务中，**位于命令端的领域模型处理CRUD操作并映射到其自己的数据库**。它还可以处理简单查询，例如不需要joi,仅是基于主键的查询。命令端在数据发生变化时发布领域事件。可以使用诸如Eventuate Tram之类的框架或使用事件溯源来发布这些事件。

**独立的查询模型可以用来处理复杂的查询场景**。查询端的代码往往比命令端简单很多，因为它不需要负责实现具体的业务逻辑。查询端可以使用的数据库种类很灵活，只要数据库能够支持需要的查询功能即可。查询端的事件处理程序会订阅领域事件并更新数据库。甚至可能存在多个查询模型，与需要的查询类型一一对应。

##### CQRS和查询专用服务

CQRS不仅可以在服务中应用，还可以使用此模式来定义查询服务。查询服务的API只包含查询操作，并无命令操作。它通过订阅由一个或多个其他服务发布的事件来确保它的数据库是不断更新的，并由此实现查询操作。查询端服务订阅由多个服务发布的事件。这是实现查询用视图的好方法。这种视图（和它的数据）不属于任何特定服务，因此将其实现为独立的服务是合理的。这种服务的一个很好的例子是Order History Service,它是一个实现findorderHistory()查询操作的专用查询服务。如图7-9所示，此服务订阅了多个服务发布的事件，包括Order Service和Delivery Service等。

![image-20221014151008972](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014151008972.png)

在许多方面，CQRS也代表了当前流行的基于事件的数据库应用场景，例如它使用关系型数据库作为记录系统，使用文本搜索引擎（如Elasticsearch)来处理文本查询。不同之处在于CQRS使用更广泛的数据库类型，而不仅仅是文本搜索引擎。此外，通过订阅事件，近乎实时地更新CQRS查询端视图。

#### CQRS的好处和坏处



### 设计CQRS视图

**CQRS视图模块包括由一个或多个查询操作组成的API**。它**通过订阅由一个或多个服务发布的事件来更新它的数据库视图，从而实现这些查询操作**。如图7-10所示，视图模块包含视图数据库和三个子模块。

![image-20221014151428898](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014151428898.png)

数据访问模块实现数据库访问逻辑。**事件处理程序和查询API模块使用数据访问模块来更新和查询数据库**。事件处理程序模块订阅事件并更新数据库。查询API模块负责实现查询API。

在开发视图模块时，你必须做出一些重要的设计决策：

- 你必须选择合适的底层数据库，并设计数据库结构。
- 在设计数据访问模块时，你必须解决各种问题，包括**确保更新是幂等**的，并且能够处理**并发更新**。
- 在现有应用程序中实现新视图或更改现有应用程序的模式时，必须实现一种机制，以便有效地构建或重建视图。
- 你必须决定如何设计视图的客户端，以应对前面描述的复制延迟。

#### 选择视图存储库



#### 设计数据访问模块

**事件处理程序和查询API模块不直接访问数据存储区**。相反，它们使用数据访问模块，该模块由数据访问对象(DAO)及其辅助类组成。DAO有几项职责。它**实现由事件处理程序调用的更新操作，以及查询模块调用的查询操作**。DAO把上层代码映射到数据库API使用的数据类型。它还**必须处理并发更新并确保更新是幂等的**。

##### 并发处理

例如，Order\*事件的事件处理程序可能与同一订单的Delivery\*事件的事件处理程序同时调用。然后，两个事件处理程序同时调用DAO来更新该Order的数据库记录。DAO必须以确保正确处理这种情况的方式编写。它不能允许一次更新覆盖另一次更新。**如果DAO通过读取记录进行更新，然后再写入已更新记录的做法，则必须使用悲观锁或乐观锁**。在下一节中，你将看到一个DAO实例，它通过更新数据库记录而不是先读取它们来处理并发更新。

##### 幂等事件处理程序

**如果重复事件导致不正确的结果，则事件处理程序不是幂等的**。例如，增加银行账户余额的事件处理程序不是幂等的。如第3章所述，非幂等事件处理程序必须通过记录它在视图数据存储中处理事件的D来检测和丢弃重复事件。

为了确保可靠，**事件处理程序必须记录事件ID并以原子化的方式更新数据存储区**。如何执行此操作取决于数据库的类型。如果视图的底层数据库是SQL数据库，则事件处理程序可以将已处理的事件作为更新视图事务的一部分插入PROCESSED EVENTS表中。但是，如果视图底层数据库是具有有限事务模型的NoSQL数据库，则事件处理程序必须将事件保存在它更新的数据存储区“记录”（例如，MongoDB文档或DynamoDB表项）中。

请务必注意，**事件处理程序不需要记录每个事件的ID。如果与Eventuate的情况一样，事件具有单调递增的ID,则每个记录仅需要存储从给定聚合实例接收的max(eventId)**。此外，如果记录对应于单个聚合实例，则事件处理程序仅需要记录max(eventId)。只有表示来自多个聚合的事件连接的记录必须包含从[aggregate type,aggregate id]到max(eventId)的映射。

正如我之前所说，使用CQRS的一个问题是命令端更新后，**立即执行查询的客户端可能看不到自己的更新**。由于消息传递基础设施不可避免的延迟，视图是最终一致的。

命令和查询模块API可以使客户端使用以下方法检测不一致性。命令端操作将包含已发布事件的ID标记返回给客户端。然后，客户端把这个事件有关的ID传递给查询操作，如果该事件尚未更新视图，则返回查询错误。视图模块可以使用重复事件检测机制来实现这样的功能。

#### 添加和更新CQRS视图

CQRS视图将在应用程序的整个生命周期内被不断地添加和更新。有时你需要添加新视图以支持新查询。在其他时候，你可能需要重新创建视图，因为架构已更改，或者你需要修复更新视图代码中的错误。

添加和更新视图在概念上非常简单。**要创建新视图，你需要开发查询端模块、设置数据存储区并部署服务**。查询端模块的事件处理程序处理所有事件，最终视图将是最新的。同样，**更新现有视图在概念上也很简单：更改事件处理程序并从头开始重建视图**。然而，问题是这些想法在实践中不太可行。我们来看看具体的问题。



## 第8章 外部API模式

### 外部API的设计难题

使用服务API的客户端一共有四种：

- Web应用程序，如Consumer Web应用程序一为消费者实现基于浏览器的用户界面，Restaurant Web应用程序一实现基于浏览器的餐馆用户界面，以及Admineb应用程序一实现供内部管理员使用的用户界面。
- 在浏览器中运行的JavaScript应用程序。
- 移动应用程序，一个供消费者使用，另一个供送餐员使用
- 由第三方开发人员编写的应用程序

API的一种设计思路是让客户端直接调用服务。从表面上看，这听起来非常简单，毕竟，这就是客户端调用单体应用程序的API的方式。但由于存在以下弊端，这种方法很少用于微服务架构：

- 细粒度服务API要求客户端发出多个请求以检索所需的数据，这样做效率低，并且可能导致糟糕的用户体验。
- 由于客户端了解每项服务以及服务的API从而导致封装不足（紧耦合)，因此今后很难更改服务的架构和API。
- 服务可能使用对客户端而言不便或不能使用的进程间通信机制，尤其是防火墙外的客户端。

### API Gateway模式

正如你刚才所见，直接访问服务的API会导致很多问题。客户端通过互联网完成API组合通常是不切实际的。缺乏封装使开发人员难以更改服务分解和API。服务有时会使用不适合防火墙之外的通信协议。因此，更好的方法是使用API Gateway。

> 模式：API Gateway
>
> 实现一个服务，该服务是外部API客户端进入基于微服务应用程序的入口点。

API Gateway是一种服务，它是外部世界进入应用程序的入口点。**它负责请求路由、API组合和身份验证等各项功能**。本节介绍API Gateway模式。我将分析它的优点和弊端，并讨论在开发API Gateway时必须解决的各种设计问题。

#### 什么是API Gateway模式

客户端向API Gateway发出单个请求。我们可以把API Gateway视为一种服务，作为从防火墙外部进入应用程序的API请求的单一入口点。它**类似于面向对象设计的外观(Facade)模式**。与外观一样，**API Gateway封装了应用程序的内部架构，并为其客户端提供API**。它还可能具有其他职责，例如身份验证、流量监控和速率限制。图8-3显示了客户端、API Gateway和服务之间的关系。

**API Gateway负责请求路由、API组合和协议转换**。来自外部客户端的所有API请求首先转到API Gateway,后者将一些请求路由到相应的服务。API Gateway使用API组合模式处理其他请求，调用多个服务并聚合结果。它还可以在客户端友好的协议（如HTTP和WebSockets)与客户端不友好的协议之间进行转换。

##### 请求路由

**API Gateway的关键功能之一是请求路由**。API Gateway通过将请求路由到相应的服务来实现一些API操作。当它收到请求时，API Gateway会查询路由映射，该映射指定将请求路由到哪个服务。例如，路由映射可以将HTTP方法和路径映射到服务的HTTP URL。此功能与NGNX等Web服务器提供的反向代理功能相同。

![image-20221014154730498](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014154730498.png)

##### API组合

API Gateway通常不仅仅是简单地扮演反向代理的角色。它也可能使用API组合实现一些API操作。例如，FTGO API Gateway使用API组合实现Get Order Details API操作。如图8-4所示，移动应用程序向API Gateway发出一个请求，该API Gateway从多个服务获取订单详细信息。

##### 协议转换

**API Gateway也可以完成协议转换**。它可能为外部客户端提供RESTful API,即使应用程序服务在内部使用混合协议，包括REST和gRPC。在需要时，某些API的操作实现在RESTful外部API和基于内部的gRPC API之间进行转换。

##### API Gateway能够为每一个客户端提供它们专用的API



##### 实现边缘功能

虽然API Gateway的主要职责是API路由和API组合，但它也可以实现所谓的边缘功能。**边缘功能（Edge Function),顾名思义，是在应用程序边缘实现的请求、处理功能**。应用程序可能实现的边缘功能包括：

- 身份验证：验证发出请求的客户端身份。
- 访问授权：验证客户端是否有权执行该特定操作。
- 速率限制：限制特定客户或所有客户端每秒的请求数。
- 缓存：缓存响应以减少对服务的请求数。
- 指标收集：收集有关API使用情况的指标，以进行计费分析。
- 请求日志：记录请求历史。

应用程序中有三个不同的位置可以实现这些边缘功能。首先，你可以在**后端服务中实现它们**。这可能对某些功能有意义，例如缓存、指标收集和可能的访问授权。但是，如果应用程序在到达服务之前对边缘上的请求进行身份验证，则通常会更安全。

**第二种选择是在API Gateway上游的边缘服务中实现这些边缘功能**。边缘服务是外部客户端的第一个联系点。它在将请求传递给API Gateway之前对请求进行身份验证并完成其他边缘处理。

**使用专用边缘服务的一个重要好处是它可以分隔问题**。API Gateway侧重于API路由和组合。另一个好处是它集中了关键边缘功能的职责，例如身份验证。当应用程序具有多种语言和框架编写的API Gateway时，这一点变得尤为重要。我稍后会谈到更多。这种方法的弊端是由于额外的请求跳跃而增加了网络延迟。它还增加了应用程序的复杂性。

因此，使用第三个选项，**在API Gateway中实现这些边缘功能（尤其是访问授权）通常就很方便**。网络跳跃少一个，就可以改善延迟状况。需要改动的部分也较少，这就降低了复杂性。第11章将介绍API Gateway和服务如何协作以实现安全性。

##### API Gateway的架构

API Gateway具有分层的模块化架构。其架构由两层组成，如图8-5所示：API层和公共层。API层由一个或多个独立的API模块组成。**每个API模块都为特定客户端实现API**。**公共层实现共享功能，包括边缘功能，如身份验证**。

![image-20221014155452470](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014155452470.png)

在这个例子中，API Gateway有三个API模块：

移动设备API:为FTGO移动客户端实现API。

浏览器API:为浏览器中运行的JavaScript应用程序实现API。

公共API:为第三方开发人员实现API。

API模块以两种方式实现每个API操作。**某些API操作直接映射到单个服务API操作**。API模块通过将请求路由到相应的服务API操作来实现这些操作。它**可以使用通用路由模块路由请求，该模块读取描述路由规则的配置文件**。

API模块也会**使用API组合实现其他更复杂的API操作**。此API操作的实现包含自定义代码。每个API操作实现都通过调用多个服务并将结果进行组合来处理请求。

###### API Gateway的所有者模式

Netflix推出的方法或许更好，**此方法让客户端团队（包括移动、Wb和公共API团队)拥有与他们有关的API模块并公开API**。**API Gateway团队负责开发公共模块和API Gateway的运维**。如图8-6所示，该所有权模型使团队可以控制属于他们自己的API。当团队需要更改其API时，他们会把对API代码的更改提交到API Gateway的代码仓库中。为了更好地工作，API Gateway的部署流水线必须完全自动化。否则，客户端团队不得不等待API Gateway团队手工部署一个新的版本。

![image-20221014155800804](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014155800804.png)

###### 使用后端前置模式

API Gateway的一个问题是它的职责不明确。多个团队为相同的代码库做贡献。APIGateway团队负责运维。虽然没有SOA ESB那么糟糕，但这种职责模糊与“如果你构建它，你就拥有它”的微服务架构哲学背道而驰。

解决方案是**为每个客户端提供一个API Gateway,即所谓的后端前置**（Backends for frontends,BFF)模式，由Phil Calcado和他在SoundCloud的同事开创(http:/www.philcalcado.com)。如图8-7所示，每个API模块都成为自己的独立API Gateway,由对应的客户端团队开发和运维。

> 模式：后端前置
>
> 为每种类型的客户端实现单独的API Gateway。

![image-20221014160235173](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014160235173.png)

#### API Gateway模式的好处和弊端



### 实现一个API Gateway

现在让我们看看如何实现API Gateway。如前所述，API Gateway的职责如下：

请求路由：根据HTTP请求方法和路径等条件，将请求路由到服务。当应用程序具有一个或多个CQRS查询服务时，API Gateway必须使用HTTP请求方法进行路由。如第7章所述，在这种架构中，命令和查询由不同的服务处理。

- API组合：使用API组合模式实现GET REST接口，如第7章所述。请求处理程序会组合调用多个服务的结果。
- 边缘功能：其中最值得注意的是身份验证。
- 协议转换：在服务使用的客户友好协议和客户不友好协议之间进行转换。
- 成为应用程序架构中的好公民。

实现API Gateway有两种不同的方法：

- 使用现成的API Gateway产品或服务：此选项几乎不需要代码开发，但灵活性最低。例如，现成的API Gateway通常不支持API组合。
- 使用API Gateway框架或Web框架作为起点，开发属于自己的API Gateway:这是最灵活的方法，但需要进行一些开发工作。

#### 使用现成的API Gateway产品或服务



#### 开发自己的API Gateway

开发API Gateway并不是特别困难。它**本质上是一个代理其他服务请求的Web应用程序**。你可以使用自己喜欢的Wb框架构建一个。但是，你需要解决两个关键设计问题：

- 实现定义路由规则的机制以简化复杂的代码。
- 正确实现HTTP代理行为，包括如何处理HTTP标头。

因此，开发API Gateway更好的起点是使用满足上述目的的框架。框架中内置的功能可显著减少你需要编写的代码量。



## 第9章 微服务架构中的测试策略（上）

### 微服务架构中的测试策略概述

自动化测试通常包括四个阶段(http:/xunitpatterns.com/Four%20 Phase%20Test.html):

1. 设置环境：将被测系统以及其他相关元素组成的测试环境初始化为所需的状态。例如，创建测试中的类，并将其初始化为呈现特定行为所需的状态。

2. 执行测试：调用被测系统，例如，在被测试的类上调用一个方法。

3. 验证结果：对调用的返回结果和被测系统的状态进行判断。例如，验证方法的返回值和被测试类的新状态与预期一致。

4. 清理环境：必要时清理测试环境。许多测试省略了这个阶段，但是某些类型的测试，比如涉及数据库的测试可能需要在这个阶段将数据库的状态回滚到设置环境阶段前的初始状态。

#### 使用模拟和桩

进行测试被测系统在运行时常常会依赖另一些系统。依赖的麻烦在于它们可能把测试复杂化，并减慢测试速度。

如图9-3所示，解决方案是用测试替身（Test double)来消除被测系统的依赖性。测试替身是一个对象，该对象负责模拟依赖项的行为。

![image-20221014162441507](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014162441507.png)

**有两种类型的测试替身：桩（stub)和模拟（mock)。术语桩和模拟通常可以互换使用**，尽管它们的行为略有不同。

桩是一个测试替身，它代替依赖项来向被测系统发送调用的返回值。

模拟是也一个测试替身，用来验证被测系统是否正确调用了依赖项。此外，模拟通常也扮演桩的角色，向被测系统发送调用的返回值。

测试的不同类型有许多不同类型的测试。某些测试（例如性能测试和易用性测试）验证应用程序是否满足其服务质量要求。在本章中，我将重点介绍用于验证应用程序或服务的功能的自动化测试。

我将介绍如何编写四种不同类型的测试：

- 单元测试：测试服务的一小部分，例如类。
- 集成测试：验证服务是否可以与基础设施服务（如数据库）或其他应用程序服务进行交互。
- 组件测试：单个服务的验收测试。
- 端到端测试：整个应用程序的验收测试。



## 第10章 微服务架构中的测试策略（下）



## 第11章 开发面向生产环境的微服务应用

为了使服务做好部署到生产环境中的准备，他们需要确保满足三个关键的质量属性：安全性、可配置性和可观测性。

第一个质量属性是**应用程序安全性**。开发安全的应用程序至关重要，除非你希望公司因为泄露数据而登上头条新闻。幸运的是，微服务架构中需要解决的大多数安全问题与单体应用程序没有任何不同。FTGO团队知道，他们多年来在开发单体应用时学到的很多东西也适用于微服务。但是微服务架构迫使你以不同方式实现应用程序级安全性的某些方面。例如，你需要实现一种机制，将用户的身份从一个服务传递到另一个服务。

必须解决的第二个质量属性是**服务可配置性**。服务通常集成一个或多个外部服务，例如消息代理和数据库。每个外部服务的网络位置和访问凭据通常取决于运行服务的环境。你无法将配置属性直接写在服务的代码中。相反，你必须使用外部化配置机制，该机制在服务运行时为它们提供需要的配置属性。

第三个质量属性是**可观测性**。FTG0团队已经为现有应用程序实现了监控和日志记录。但是微服务架构是一个分布式系统，这带来了一些额外的挑战。每个请求都由API Gateway和至少一个服务处理。例如，想象一下，你正在尝试确定是六种服务中的哪一种导致了延迟问题，或者当日志条目分散在五个不同的服务中时，试图理解如何处理请求。为了更容易理解应用程序的行为并解决问题，你必须实现多个可观测模式。

### 开发安全的服务

网络安全已成为每个企业都面临的关键问题。几乎每天都有关于黑客如何窃取公司数据的头条新闻。为了开发安全的软件并远离头条新闻，企业需要解决各种安全问题，包括硬件的物理安全性、传输和静态数据加密、身份验证、访问授权以及修补软件漏洞的策略，等等。无论你使用的是单体还是微服务架构，大多数问题都是相同的。本节重点介绍微服务架构如何影响应用程序级别的安全性。

应用程序开发人员主要负责实现安全性的四个不同方面：

- 身份验证：**验证尝试访问应用程序的应用程序或人员（安全的术语叫主体）的身份**。例如，应用程序通常会验证访问主体的凭据，例如用户的D和密码，或应用程序的API密钥。
- 访问授权：**验证是否允许访问主体对指定数据完成请求的操作**。应用程序通常使用基于角色的安全性和访问控制列表（ACL)的组合。基于角色的安全性为每个用户分配一个或多个角色，授予他们调用特定操作的权限。ACL授予用户或角色对特定业务对象或聚合执行操作的权限。
- 审计：**跟踪用户在应用中执行的所有操作**，以便检测安全问题，帮助客户实现并强制执行合规性。
- 安全的进程间通信：理想情况下，所有进出服务的通信都应该采用传输层安全性(TLS)加密。**服务间通信甚至可能需要使用身份验证**。

#### 在传统单体架构中实现安全性

![image-20221014170725784](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014170725784.png)

#### 在微服务架构中实现安全性

在微服务应用程序中实现安全性的一个挑战是我们不能仅仅从单体应用程序借鉴设计思路。这是因为单体应用程序的安全架构的一些方面对微服务架构来说是不可用的，例如：

- 内存中的安全上下文：使用内存中的安全上下文（如ThreadLocal)来传递用户身份。服务无法共享内存，因此它们无法使用内存中的安全上下文（如ThreadLocal)来传递用户身份。在微服务架构中，我们需要一种不同的机制来将用户身份从一个服务传递到另一个服务。
- 集中会话：因为内存中的安全上下文没有意义，内存会话也没有意义。从理论上讲，多种服务可以访问基于数据库的会话，但它会违反松耦合的原则。我们需要在微服务架构中使用不同的会话机制。

##### 由API Gateway处理身份验证

处理身份验证有两种不同的方法。**一种选择是让各个服务分别对用户进行身份验证**。这种方法的问题在于它允许未经身份验证的请求进入内部网络。它依赖于每个开发团队在所有服务中正确实现安全性。因此，出现安全漏洞的风险和概率都很大。

在服务中实现身份验证的另一个问题是不同的客户端以不同的方式进行身份验证。纯API客户端使用基本身份验证为每个请求提供凭据。其他客户端可能首先登录，然后为每个请求提供会话令牌。但我们要避免在服务中处理多种不同的身份验证机制。

更好的方法是**让API Gateway在将请求转发给服务之前对其进行身份验证**。在APIGateway中进行集中API身份验证的优势在于只需要确保这里的验证是正确的。因此，出现安全漏洞的可能性要小得多。另一个好处是只有API Gateway需要处理各种不同的身份验证机制。这使得其他服务的实现变得简单了。

图11-3显示了这种方法的工作原理。客户端使用API Gateway进行身份验证。API客户端在每个请求中包含凭据。基于登录的客户端将用户的凭据发送到API Gateway进行身份验证，并接收会话令牌。一旦API Gateway验证了请求，它就会调用一个或多个服务。

![image-20221014170947450](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014170947450.png)

> 模式：访问令牌
>
> API Gateway将包含用户信息（例如其身份和角色）的令牌传递给它调用的服务。

它还必须验证请求是否已经过通过身份验证。解决方案是**让API Gateway在每个服务请求中包含一个令牌**。服务使用令牌验证请求，并获取有关主体的信息。API Gateway还可以为面向会话的客户端提供相同的令牌，以用作会话令牌。

客户端的事件序列如下：

1. 客户端发出包含凭据的请求给API Gateway.

2. API Gateway对凭据进行身份验证，创建安全令牌，并将其传递给服务。

基于登录的客户端的事件序列如下：

1. 客户端发出包含凭据的登录请求。

2. API Gateway返回安全令牌。

3. 客户端在调用操作的请求中包含安全令牌。

4. API Gateway验证安全令牌并将其转发给服务。

在本章稍后，我将介绍如何实现令牌，但让我们首先看一下安全性的另一个主要方面：访问授权。

##### 处理访问授权

**实现访问授权的一个位置是API Gateway**。例如，它可以将对GET/orders/{orderId}的访问限制为消费者和客户服务代表。如果不允许用户访问特定路径，则API Gateway可以在将请求转发到服务之前拒绝该请求。与身份验证一样，在API Gateway中集中实现访问授权可降低安全漏洞的风险。你可以使用安全框架（如Spring Security)在API Gateway中实现访问授权。

在API Gateway中实现访问授权的一个弊端是，它**有可能产生API Gateway与服务之间的耦合，要求它们以同步的方式进行代码更新**。而且，API Gateway通常只能实现对URL路径的基于角色的访问。由API Gateway实现对单个领域对象的访问授权通常是不实际的，因为这需要详细了解服务的领域逻辑。

另一个实现**访问授权的位置是服务**。**服务可以对URL和服务方法实现基于角色的访问授权**。它还可以实现ACL来管理对聚合的访问。例如，在Order Service中可以实现基于角色和基于ACL的授权机制，以控制对Order的访问。FTGO应用程序中的其他服务也可以实现类似的访问授权逻辑。



### 如何使用外部化配置模式



> 模式：外部化配置
>
> 在运行时向服务提供配置属性值，例如数据库访问凭据和网络位置。

外部化配置机制在运行时向服务实例提供配置属性值。主要有两种方法：

- 推送模型：部署基础设施通过类似操作系统环境变量或配置文件，将配置属性传递给服务实例。
- 拉取模型：服务实例从配置服务器读取它所需要的配置属性。

#### 使用基于推送的外部化配置

推送模型依赖于部署环境和服务的协作。**部署环境在创建服务实例时提供配置属性**。如图11-7所示，它可能会将配置属性作为环境变量传递。或者，部署环境可以使用配置文件来提供配置属性。然后，服务实例在启动时读取配置属性。

![image-20221014171946341](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014171946341.png)

#### 使用基于拉取的外部化配置

在拉取模型中，**服务实例从配置服务器读取其配置属性**。图11-8显示了它的工作原理。启动时，服务实例会在配置服务中查询其配置。用于访问配置服务器的配置属性（例如其网络位置)通过基于推送的配置机制（例如环境变量）提供给服务实例。

![image-20221014172002426](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014172002426.png)

使用配置服务器有几个好处：

- 集中配置：所有配置属性都存储在一个位置，这使它们更易于管理。此外，为了消除重复的配置属性，有些实现允许你定义全局默认值，针对单个服务的值可以覆盖这些默认值。
- 敏感数据的透明解密：加密敏感数据（如数据库访问凭据）是一种安全性最佳实践。但是，使用加密的一个挑战是通常服务实例需要解密它们，这意味着它需要解密密钥。某些配置服务器实现会在将属性返回给服务之前自动对其进行解密。
- 动态重新配置：服务可能会通过轮询等方式检测更新的属性值，并重新配置自身。

使用配置服务器的主要缺点是，除非由基础设施提供，否则它需要额外的人力进行设置和运维。幸运的是，有各种开源框架，例如Spring Cloud Config,它使运行配置服务器变得更加容易。



### 设计可观测的服务

在生产中管理应用程序的许多方面都超出了开发人员的职责范畴，例如监控硬件可用性和利用率。这些显然是运维的职责。但是，作为服务开发人员，你必须实现多种模式才能使你的服务更易于管理和排错。这些模式（如图11-9所示)公开了服务实例的行为和健康状况。它们使监控系统能够跟踪和可视化服务状态，并在出现问题时生成告警。这些模式还可以更轻松地用于故障排错。

你可以使用以下模式来设计可观测的服务：

- 健康检查API:公开返回服务运行状况的接口。
- 日志聚合：记录服务活动并将日志写人集中式日志记录服务器，该服务器提供搜索和告警。
- 分布式跟踪：为每一个在服务之间跳转的外部请求分配唯一ID,并跟踪请求。
- 异常跟踪：向异常跟踪服务报告异常，该异常跟踪服务可以对异常进行重复数据删除，向开发人员发出警报并跟踪每个异常的解决方案。
- 应用程序指标：服务运维指标，例如计数器和指标，并将它们公开给指标服务器。
- 审核日志记录：记录用户操作。

![image-20221014172430684](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014172430684.png)

#### 使用健康检查API模式

有时服务看上去正在运行，但它却无法处理请求。例如，新启动的服务实例可能尚未准备好接受请求。例如，FTGO的Consumer Service大约需要l0秒钟来初始化消息和数据库适配器。在它们准备好之前，部署基础设施将HTTP请求路由到服务实例是没有意义的。

此外，服务实例可能会失败却不自动终止。例如，错误可能导致Consumer Service的实例耗尽数据库连接并且无法访问数据库。部署基础设施不应将请求路由到已失败但仍在运行的服务实例。并且，如果服务实例无法恢复，则部署基础设施必须终止它并创建新实例。

> 模式：健康检查API
>
> 服务公开健康检查API接口，例如GET/health,它返回服务的健康状况。

**服务实例需要能够告诉部署基础设施它是否能够处理请求**。一个好的解决方案是服务实现健康检查接口，如图l1-l0所示。例如，Spring Boot Actuator Java库实现了一个GET/actuator/hea1th接口，当服务健康时返回200，否则返回503。同样，HealthChecksNET库实现了GET/hc接口(https:/docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/implement-resilient-applications/monitor-app-health)。部署基础设施定期调用此接口以确定服务实例的运行状况，并在其运行状况不佳时执行相应的操作。

![image-20221014194949637](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014194949637.png)

使用健康检查时需要考虑两个问题。**第一个是接口的实现**，它必须报告服务实例的健康状况。**第二个问题是如何配置部署基础设施以调用健康检查接口**。我们先来看看如何实现接口。

##### 实现健康检查接口

实现健康检查接口的代码必须以某种方式确定服务实例的健康状况。一种简单的方法是**验证服务实例是否可以访问其外部基础设施服务**。具体做法取决于具体的基础设施服务，例如可以通过获取数据库连接，并执行测试查询来验证服务是否已连接到数据库。更复杂的方法是执行模拟客户端调用服务API的综合事务。这种健康检查更加彻底，但实现起来可能更耗时，执行时间也更长。

还可以**通过对服务实现其他健康检查来自定义此行为**。可以通过定义实现HealthIndicator接口的类来实现自定义健康检查。此接口定义了一个health()方法，该方法由/actuator/health接口的实现调用。它返回健康检查的结果。

##### 调用健康检查接口

如果没有人调用它，健康检查接口就没有意义了。部署服务时，必须配置部署基础设施以调用接口。如何执行此操作取决于部署基础设施的特定详细信息。例如，如第3章所述，你可以配置一些服务注册表（例如Netflix Eureka)来调用健康检查接口，以确定是否应将流量路由到服务实例。第l2章将讨论如何配置Docker和Kubernetes以调用健康检查接口。

#### 使用日志聚合模式

对于故障排除，日志是必不可少的。如果你想知道应用程序有什么问题，最好是从阅读日志文件开始。但是在微服务架构中使用日志具有挑战性。

> 模式：日志聚合
>
> 在支持搜索和告警的集中式数据库中聚合所有服务的日志。

解决方案是使用日志聚合。如图11-11所示，**日志聚合流水线将所有服务实例的日志发送给集中式日志服务器**。日志服务器存储日志后，你可以查看、搜索和分析日志。你还可以配置在日志中出现某些消息时触发的告警。

![image-20221014195635242](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014195635242.png)

##### 服务如何生成日志

作为服务开发人员，你需要考虑几个问题。首先，你需要确定要使用的日志库。第二个问题是在哪里写日志条目。我们先来看一下日志库。

大多数编程语言都有一个或多个日志库，可以轻松生成正确结构化的日志条目。例如，三个流行的Java日志库是Logback、log4j和JUL（java.util.logging),还有SLF4J,它是各种日志框架的外围（facade)API。同样，Log4JS是Node.js的流行日志框架。使用日志记录的一种合理方法是在服务代码中调用其中一个日志库。但是，如果你有日志库无法强制执行的某些更严格的日志记录要求，则可能需要基于日志记录库定义自己的日志记录API。

你还需要确定记录的位置。**传统上，你需要将日志框架配置为写入文件系统中众所周知的位置**。但是**当使用更现代化的部署技术时**，例如容器和Serverless(在第12章中将详细描述)，把日志写入文件系统通常不是最好的方法。在某些环境中，例如AWS Lambda,甚至没有“永久”文件系统来写入日志！相反，你的服务**应该把日志输出到stdout**。然后，部署基础设施将决定如何处理服务的输出。

##### 日志聚合的基础设施

日志记录的基础设施服务负责聚合日志、存储日志以及使用户能够搜索日志。一种流行的日志记录基础设施是ELK套件。ELK由三个开源产品组成：

- Elasticsearch:面向文本搜索的NoSQL数据库，用作日志记录服务器。
- Logstash:聚合服务日志并将其写人Elasticsearch的日志流水线。
- Kibana:Elasticsearch的可视化工具。

其他开源日志流水线包括Fluentd和Apache Flume。日志服务器包括云服务，例如AWSCloud Watch Logs,以及众多商业产品。日志聚合是微服务架构中的一种有用的调试工具。现在让我们看一看分布式追踪，这是了解基于微服务的应用程序行为的另一种方法。

#### 使用分布式追踪模式

深入了解应用程序正在执行的操作的一种好方法是使用分布式追踪。**分布式追踪类似于单体应用程序中的性能分析器。它记录有关处理请求时所进行的服务树调用的信息**（例如，开始时间和结束时间)。然后，你可以看到服务如何在处理外部请求期间进行交互，包括花费时间的细分。

> 模式：分布式追踪
>
> 为每个外部请求分配一个唯一的D,并在提供可视化和分析的集中式服务器中记录它如何从一个服务流向下一个服务。

图11-12显示了分布式追踪服务器如何显示API Gateway处理请求时发生的情况的例子。它显示了对API Gateway的入站请求以及API Gateway对Order Service的请求。对于每个请求，分布式追踪服务器显示已执行的操作和请求的时间。

![image-20221014200231429](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014200231429.png)

图11-12显示了分布式追踪术语中称为追踪的内容。**追踪表示外部请求，由一个或多个跨度组成**。跨度表示操作，其关键属性是操作的名称、开始时间戳和结束时间。跨度可以有一个或多个子跨度，表示嵌套操作。例如，顶层的跨度可能表示API Gateway的调用，如图11-12所示。它的子跨度代表API Gateway对服务的调用。

分布式追踪的一个有价值的副作用是它为每个外部请求分配一个唯一的D。服务可以在其日志条目中包含请求ID。与日志聚合相结合时，请求ID使你可以轻松查找特定外部请求的所有日志条目。

##### 使用追踪工具类库

追踪工具类库构建跨度树，并将它们发送到分布式追踪服务器。服务代码可以直接调用追踪工具类库，但这会将检测逻辑与业务和其他逻辑交织在一起。更简洁的方法是使用拦截器或面向切面编程(AOP)。

##### 关于分布式追踪服务器

追踪工具类库将跨度发送到分布式追踪服务器。分布式追踪服务器将跨度拼接在一起以形成完整的追踪并将它们存储在数据库中。一个流行的分布式追踪服务器是Open Zipkin。Zipkin 最初由Twitter开发。服务可以使用HTTP或消息代理向Zipkin提供跨度。Zipkin将追踪存储在存储后端中，后端可以是SQL或NoSQL数据库。它有一个用来显示追踪的用户界面，如图11-12所示。AWS X Ray是分布式追踪服务器的另一个示例。

![image-20221014201624214](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014201624214.png)

#### 使用应用程序指标模式

监控和告警功能是生产环境的关键部分。如图11-14所示，监**控系统从技术栈的每个部分收集指标**，这些指标提供有关应用程序健康状况的关键信息。指标涵盖的范围从基础设施相关的指标（如CPU、内存和磁盘利用率)到应用程序级别的指标（如服务请求延迟和执行的请求数)。例如，Order Service收集有关已下订单、已批准订单和已拒绝订单数量的指标。指标服务收集各类指标数据，提供可视化和告警功能。

![image-20221014201923799](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014201923799.png)

> 模式：应用程序指标服务
>
> 将指标数据发送给负责聚合、可视化和告警的中央服务器。

指标定期采样。指标样本具有以下三个属性：

- 名称：指标的名称，例如jvm memory_max_bytes或placed_orders.
- 值：数值。
- 时间戳：样本的时间。

此外，**一些监控系统支持维度的概念，维度是任意的名称与值的组合**。例如，报告jvm memory_max bytes的维度：area="heap",id="PS Eden Space"和area="heap",id="PS01dGen"。**维度通常用于提供其他信息**，例如计算机名称、服务名称或服务实例标识符。监控系统通常沿一个或多个维度聚合（求和或平均）度量样本。监控的许多方面都是运维人员的职责。但是服务开发人员需要负责指标的两个方面。首先，他们必须编写监测服务的代码，以便收集有关其行为的指标。其次，他们必须将这些服务指标以及来自JVM和应用程序框架的指标发送给指标服务器。

##### 收集服务层面的指标

收集指标的工作量取决于应用程序使用的框架以及要收集的具体指标。例如，经过简单的配置，基于Spring Boot的服务可以使用Micrometer Metrics库作为依赖项来收集（并公布）基本指标，例如JVM指标。Spring Boot的自动配置功能负责配置指标库并对外公布指标。如果服务收集特定于应用程序的指标，则该服务仅需要直接使用Micrometer Metrics API。

##### 把指标发送给指标服务

服务有两种方式向指标服务提供数据：推送或拉取。**使用推送模型，服务实例通过调用API将指标发送到指标服务**。例如，AWS Cloudwatch指标实现推送模型。

**使用拉取模型，Metrics Service(或其本地运行的代理)调用服务API,并从服务实例检索指标信息**。Prometheus是一种流行的开源监控和警报系统，它使用拉取模型。

Prometheus服务器会定期轮询此端口以检索指标。一旦指标被保存在Prometheus中，你就可以使用数据可视化工具Grafana(https:/grafana.com)查看它们。你还可以为这些指标设置提醒，例如当placed orders total的更改率低于某个阈值时。

应用程序指标可为你的应用程序行为提供有价值的信息。通过指标触发的告警使你能够快速响应生产环境发生的问题，这些问题可能会影响用户。现在让我们看看如何观测和响应另一个警报源：异常。

#### 使用异常追踪模式

服务很少记录异常，当它发生异常时，确定根本原因很重要。**异常可能是失败或编程错误的结果**。查看异常的传统方法是查看日志。你甚至可以配置日志记录服务器，以便在日志文件中出现异常时向你发出警报。但是，这种方法存在一些问题：

- 日志文件以单行日志条目为导向，而异常由多行组成。
- 没有机制来追踪日志文件中发生的异常的解决方案。你必须手动将异常复制粘贴到问题追踪器中。
- 可能存在重复的异常，但没有自动机制将它们视为异常。

> 模式：异常追踪服务
>
> 把产生的异常报告给中央服务，该服务对异常进行重复数据删除、生成警报并管理异常的解决方案。

更好的方法是使用异常追踪服务。如图11-15所示，可将服务配置为通过类似REST API向异常追踪服务报告异常。异常追踪服务可以对异常进行重复数据删除、生成警报并管理异常的解决方案。

![image-20221014202755942](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014202755942.png)

**有几种方法可以将异常追踪服务集成到你的应用程序中**。服务可以直接调用异常追踪服务的API。更好的方法是使用异常追踪服务提供的客户端库。例如，HoneyBadger（www.honeybadger.io)的客户端库提供了几种易于使用的集成机制，包括捕获和报告异常的Servlet过滤器。

> 异常追踪服务
>
> 有几种异常追踪服务。有的纯粹是基于云的，如Honeybadger。.其他的，如Sentry..io(https://sentry.io/welcome),也有一个开源版本，你可以在自己的基础设施上部署。这些服务从你的应用程序接收异常并生成警报。它们提供了一个用于查看异常和管理异常解决方案的控制台。异常追踪服务通常以各种语言提供客户端库。

异常追踪模式是快速识别和响应生产环境问题的有用方法。追踪用户行为也很重要。我们来看看如何做到这一点。

#### 使用审计日志模式

审计日志记录的目的是记录每个用户的操作。审计日志通常用于帮助客户支持、确保合规性并检测可疑行为。每个审核日志条目都记录用户的身份、他们执行的操作以及业务对象。应用程序通常将审计日志存储在数据库表中。

> 模式：审核日志记录
>
> 记录数据库中的用户操作，以帮助客户支持、确保合规性，并检测可疑行为。

有几种不同的方法来实现审计日志记录：

- 将审计日志记录代码添加到业务逻辑中。
- 使用面向切面编程。
- 使用事件溯源。

##### 向业务逻辑添加审计日志代码

第一个也是最直接的选择是**在整个服务的业务逻辑中使用审计日志代码**。例如，每种服务方法都可以创建审核日志条目并将其保存在数据库中。这种方法的缺点是它将审计日志代码和业务逻辑交织在一起，从而降低了可维护性。另一个缺点是它可能容易出错，因为它依赖于开发人员编写审计日志代码。

##### 使用面向切面编程

第二种选择是使用AOP。你可以使用AOP框架（如Spring AOP)来定义**自动拦截每个服务的方法调用，并持久化审计日志条目**。这是一种更可靠的方法，因为它可以自动记录每个服务方法调用。使用AOP的主要缺点是只能记录调用的方法名称和它的参数，因此确定正在执行的业务对象，并生成面向业务的审计日志条目可能具有挑战性。

##### 使用事件溯源

第三个也是最后一个选择是使用事件溯源来实现你的业务逻辑。如第6章所述，事件溯源自动为创建和更新操作提供审计日志。你需要在每个事件中记录用户的身份。但是，使用事件溯源的一个限制是它不记录查询。如果你的服务必须为查询创建日志条目，那么你还必须考虑其他选择。

### 使用微服务基底模式开发服务

本章描述了服务必须实现的众多问题，包括管理指标、向异常追踪器报告异常、日志记录和健康检查、外部化配置和安全性，等等。此外，如第3章所述，服务还可能需要处理服务发现和实现断路器。每次实现新服务时，这都不是你想要从头开始、靠自己编程来完成的工作。如果你这样做，那么在你编写第一行业务逻辑代码之前，可能需要几天甚至几周时间专门解决这些问题。

> 模式：微服务基底
>
> 异常追踪、日志记录、健康检查、外部化配置和分布式追踪是微服务架构需要解决的共性问题，我们需要在能够处理那些共性问题的框架或框架集合上构建服务。

开发服务的一种更快捷的方法是在微服务基底上构建服务。如图11-16所示，微服务基底是处理这些问题的框架或一组框架。使用微服务基底时，你只需编写很少的代码来处理这些问题。

![image-20221014204946201](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014204946201.png)

##### 使用微服务基底

微服务基底是一个框架或一组框架，可以处理许多问题，包括：

- 外部化配置。
- 健康检查。
- 应用程序指标。
- 服务发现。
- 断路器。
- 分布式追踪。

它可以显著减少你需要编写的代码量。你甚至可能不需要编写任何代码。相反，你可以配置微服务基底以满足你的要求。微服务基底使你能够专注于开发服务的业务逻辑。FTGO应用程序使用Spring Boot和Spring Cloud作为微服务基底。Spring Boot提供外部化配置等功能。Spring Cloud提供断路器等功能。尽管FTGO应用程序依赖于服务发现的基础设施，Spring Cloud还可以实现客户端服务发现，。Spring Boot和Spring Cloud不是唯的微服务基底框架。例如，如果使用Golang编写服务，则可以使用Go Kit(https::∥github.com/go-kit/kit)Micro (https://github.com/micro/micro).

使用微服务基底的一个弊端是，**开发者必须需要确保正使用的编程语言/平台组合，有与之对应的微服务基底框架或类库**。幸运的是，微服务基底实现的许多功能很可能由基础设施实现。例如，如第3章所述，许多部署环境会处理服务发现。更重要的是，微服务基底的许多与网络相关的功能将由所谓的服务网格处理，**服务网格是在服务之外运行的基础设施层**。

##### 从微服务基底到服务网格

**微服务基底是解决各种共性问题的好方法**，例如断路器。但使用微服务基底的一个障碍是，你需要确保你使用的编程语言有对应的微服务基底框架或类库。例如，如果你是Java/Spring的开发人员，Spring Boot和Spring Cloud很有用，但如果你想编写基于Node.js的服务，它们就没有任何帮助。

> 模式：服务网格
>
> 把所有进出服务的网络流量通过一个网络层进行路由，这个网络层负责解决包括断路器、分布式追踪、服务发现、负载均衡和基于规则的流量路由等具有共性的需求。

避免此问题的新兴替代方案是在所谓的服务网格中实现服务之外的某些功能。**服务网格是网络基础设施，它调和(mediate)服务与其他服务和外部应用程序之间的通信**。如图11-17所示，**进出服务的所有网络流量都通过服务网格**。它实现了各种共性的需求：包括断路器、分布式追踪、服务发现、负载均衡和基于规则的流量路由。服务网格还可以通过在服务之间使用基于TLS的机制来保护进程间通信。因此，你不再需要在服务中解决这些特定问题。

![image-20221014213122531](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014213122531.png)

使用服务网格后，微服务基底需要担负的责任就少了很多。它只需要实现与应用程序代码紧密集成的问题，例如外部化配置和健康检查。**微服务基底必须通过传播分布式追踪信息来支持分布式追踪**，例如我在前面11.3.3节中讨论过的B3标准报头。

## 第12章 部署微服务应用

**部署包含两个相互关联的概念：流程和架构**。**部署流程包括一些由开发人员和运维人员执行的步骤，以便将软件投人到生产环境。部署架构定义了该软件运行的环境结构**。自从我在20世纪90年代末开始开发企业Java应用程序以来，部署的流程和架构都发生了根本性的变化。早先开发人员将代码扔给运维人员进行手动部署的历史已经一去不复返了，生产环境的部署过程已经变得高度自动化。如图12-1所示，之前由物理机组成的生产环境已被越来越多轻量级和短生命周期的计算基础设施所取代。

![image-20221014213339414](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20221014213339414.png)



## 第13章 微服务架构的重构策略