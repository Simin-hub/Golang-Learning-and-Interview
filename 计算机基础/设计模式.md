# Go 语言设计模式

[Go 语言设计模式](https://www.topgoer.cn/docs/golang-design-pattern)

[图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html)

[深入设计模式](https://refactoringguru.cn/design-patterns/factory-method)

[23 种设计模式的通俗解释](https://mp.weixin.qq.com/s/J3V_jpJnmKWo3LwrbbHvVQ)

[参考](https://juejin.cn/post/6844904125721772039)、[实践GoF的23种设计模式：Go实现](https://github.com/ruanrunxue/Practice-Design-Pattern--Go-Implementation)

## 类之间的关系

[参考](https://yqcznb.github.io/2019/12/14/UML%E7%B1%BB%E5%9B%BE%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%846%E7%A7%8D%E5%85%B3%E7%B3%BB%E5%8F%8A%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/)

常见的关系有：继承，关联关系，聚合关系，复合关系，依赖关系,实现关系。

其中，聚合关系（Aggregation），组合关系（Composition）属于关联关系（Association）。

几种关系所表现的强弱程度依次为：组合>聚合>关联>依赖。

------

- 虚线箭头指向依赖；
- 实线箭头指向关联；
- 虚线三角指向接口；
- 实线三角指向父类；
- 空心菱形能分离而独立存在，是聚合；
- 实心菱形精密关联不可分，是组合；

------

**这些关系之间的表示方法如下图所示**

![img](https://yqcznb.github.io/images/blog/pic.jpg)

1. 继承（泛化）

   一种继承关系，表示一般与特殊的关系，它指定了**子类如何特化父类的特征和行为**。

2. 实现

   一种类与接口之间的关系，表示类是接口所有特征和行为的实现

3. 组合

   整体与部分的关系，但**部分不能离开整体而单独存在**

4. 聚合

   整体与部分的关系，**部分可以离开整体而单独存在**

5. 关联

   关联关系是类与类之间的联结

   是一种拥有的关系，它**使一个类知道另一个类的属性和方法**

   关联关系可以是`单向`也可以是`双向`，双向的关联关系两端`没有箭头或两个箭头`，单向的关联关系`有一个箭头`，而且箭头在被关联类方

6. 依赖

   依赖关系也是代表类与类的联结

   是一种使用的关系，即**一个类的实现需要另一个类的协助**

   依赖必须是`单向`的。

**聚合和组合的区别**

这两个比较难理解，重点说一下。聚合和组合的区别在于：聚合关系是“has-a”关系，组合关系是“contains-a”关系；聚合关系表示整体与部分的关系比较弱，而组合比较强；聚合关系中代表部分事物的对象与代表聚合事物的对象的生存期无关，一旦删除了聚合对象不一定就删除了代表部分事物的对象。组合中一旦删除了组合对象，同时也就删除了代表部分事物的对象。

**关联和聚合的区别**

关联和聚合的区别主要在语义上，关联的两个对象之间一般是平等的，例如你是我的朋友，聚合则一般不是平等的，例如一个公司包含了很多员工，其实现上是差不多的。

**依赖于关联的区别**

1.首先从关系程度上依赖没有关联程度强烈，对于两个类之间的依赖，只是保持在方法上，例如一个类的方法中引用了某个类的变量。

2.在关联中确实彼此把对方作为自己的一个属性，耦合度更高。保持的时间更长些，毕竟是作为一个属性存在，实例化我的时候，就会有你。而依赖只是单纯的用到对方方法时才存在

**泛化与实现的区别**

其实泛化与实现之间的关系只有一点，如实是实现的话，那么子类就不能够在扩充方法，如果是泛化的话，可以在父类基础上再次扩充自己的方法。

## go 实现接口与继承

### 实现接口

在 Golang 中，接口是一组方法签名。当类型为接口中的所有方法提供定义时，它被称为实现接口。它与 OOP(面向对象编程) 非常相似。接口指定了类型应该具有的方法，类型决定了如何实现这些方法。

如果**某个对象实现了某个接口的所有方法，则此对象就实现了该接口**。

**接口嵌套**

顾名思义，接口嵌套就是一个接口中包含了其他接口，如果**要实现外部接口，那么就要把内部嵌套的接口对应的所有方法全实现了**。

### 组合与继承

学习golang的过程中，有一个比较关注的价值观，**golang提倡组合，不提倡继承**。看过一些书和资料，感觉对这个概念的解释都不是很满意，特总结这篇文章，大家指正。

先说说组合与继承的概念。对设计模式有过了解的同学对这两个名词应该都有初步的理解，我们来总结一下：官方解释就不说了，**组合一般理解为 has-a 的关系，继承是is-a的关系**。以java为例，组合可以理解为类里边添加的属性（一般是接口类型），继承是extends。
这里我引用一篇文章的段落[浅谈组合与继承](https://blog.51cto.com/zhaoyongpan/546546)

#### 继承的优缺点

优点：

1. 类继承简单粗爆，直观，**关系在编译时静态定义**。
2. 被复用的实现易于修改，sub可以覆盖super的实现。

缺点：

1. 无法在运行时变更从super继承来的实现（也不一定是缺点）
2. sub的部分实现通常定义在super中。
3. sub直接面对super的实现细节，因此破坏了封装。
4. super实现的任何变更都会强制子类也进行变更，因为它们的实现联系在了一起。
5. 如果在新的问题场景下继承来的实现已过时或不适用，所以必须重写super或继承来的实现。
6. 由于在类继承中，实现的依存关系，对子类进行复用可能会有问题。有一个解决办法是，只从协议或抽象基类继承(子类型化)，国为它们只对很少的实现，而协议则没有实现。

#### 组合的优缺点

对象组合让我们同时使用多个对象，而每个对象都假定其他对象的接口正常运行。因此，为了在系统中正常运行，它们的接口都需要经过精心的设计。下面我就来说说他的优缺点

优点：

1. 不会破坏封装，因为只通过接口来访问对象；
2. 减少实现的依存关系，因为实面是通过接口来定义的；
3. 可以在运行时将任意对象替换为其他同类型的对象；
4. 可以保持类的封装以专注于单一任务；
5. 类和他的层次结构能保持简洁，不至于过度膨胀而无法管理；

缺点：

1. 涉及对象多；
2. 系统的行为将依赖于不同对象间的关系，而不是定义于单个类中；
3. 现成的组件总是不太够用，从而导致我们要不停的定义新对象。

#### 总结

总结来看，我认为，组合相对于继承的优点在于

1. 可以利用面向接口编程原则的一系列优点，封装性好，耦合性低
2. 相对于继承的编译期确定实现，组合的运行态指定实现，更加灵活



匿名和组合的区别

- 如果一个struct**嵌套了另一个匿名结构体**，那么这个结构**可以直接访问匿名结构体的方法，从而实现继承**
- 如果一个struct**嵌套了另一个【有名】的结构体**，那么这个模式叫做**组合**
- 如果一个struct嵌套了**多个匿名结构体**，那么这个结构可以直接访问多个匿名结构体的方法，从而实现**多重继承**

### 代码演示

网上很少有例子解释清楚golang所提倡的组合的优势，一般就是将一个struct嵌入到另外一个struct里。

```
package main

import (
    "fmt"
)

type A struct {
}

func (*A) Hello(name string) {
    fmt.Println("hello " + name + ", i am a")
}

type B struct {
    *A
}

func main() {
    name := "Lee"
    a := A{}
    a.Hello(name) //hello Lee, i am a

    b := B{&A{}}
    b.Hello(name) //hello Lee, i am a

}
```

如上文所述，我认为组合需要与接口结合使用才能体现其精髓。

让我们来看一段改造后的代码：

```
package main

import (
    "fmt"
)

type IHello interface {
    Hello(name string)
}

type A struct {
}

func (*A) Hello(name string) {
    fmt.Println("hello " + name + ", i am a")
}

type D struct {
}

func (*D) Hello(name string) {
    fmt.Println("hello " + name + ", i am d")
}

type B struct {
    *A
}

type C struct {
    IHello
}

func main() {
    name := "Lee"
    a := A{}
    a.Hello(name) //hello Lee, i am a

    b := B{&A{}}
    b.Hello(name) //hello Lee, i am a

    c := C{&A{}}
    c.Hello(name) //hello Lee, i am a

    c = C{&D{}}
    c.Hello(name) //hello Lee, i am d
}
```

发现不同了吗？

A的指针继承了接口IHello, B中嵌入了具体实现类A，C中嵌入了接口IHello,

B C两者在赋值时，均可嵌入A的指针实例，但是C可以根据运行时上下文指定具体实现，更加灵活。

所以让我们面向接口编程，提倡共用组合与接口的优雅代码

## 简介

### 什么是设计模式

- 设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。

### 为什么要学习设计模式

- 看懂源代码：如果你不懂设计模式去看Jdk、Spring、SpringMVC、IO等等等等的源码，你会很迷茫，你会寸步难行
- 看看前辈的代码：你去个公司难道都是新项目让你接手？很有可能是接盘的，前辈的开发难道不用设计模式？
- 编写自己的理想中的好代码：我个人反正是这样的，对于我自己开发的项目我会很认真，我对他比对我女朋友还好，把项目当成自己的儿子一样

### 设计模式分类



![在这里插入图片描述](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172acfe20b2d2d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)



- 创建型模式，**提供创建对象的机制**，增加已有代码的灵活性和 可复用性。共五种：**工厂方法模式、抽象工厂模式**、**单例模式**、建造者模式、**原型模式。**
- 结构型模式，**如何将对象和类组装成较大的结构**，并同时 保持结构的灵活和高效。共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
- 行为型模式，**负责对象间的高效沟通和职责委派**。共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

#### 创建型(Creational Patterns)

| 设计模式                   | 描述                                                         | 学习难度 | 使用频率 |
| -------------------------- | ------------------------------------------------------------ | -------- | -------- |
| 抽象工厂(Abstract Factory) | 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 | ★★★★☆    | ★★★★★    |
| 工厂方法(Factory Method)   | 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类 | ★★☆☆☆    | ★★★★★    |
| 单例(Singleton)            | 保证一个类仅有一个实例，并提供一个访问它的全局访问点         | ★☆☆☆☆    | ★★★★☆    |
| 原型(Prototype)            | 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 | ★★★☆☆    | ★★★☆☆    |
| 建造者(Builder)            | 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 | ★★★★☆    | ★★☆☆☆    |

#### 结构型(Structural Patterns)

| 设计模式        | 描述                                                         | 学习难度 | 使用频率 |
| --------------- | ------------------------------------------------------------ | -------- | -------- |
| 外观(Facade)    | 为子系统中的一组接口提供一个一致的接口,Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 | ★☆☆☆☆    | ★★★★★    |
| 适配器(Adapter) | 将一个类的接口转换成客户希望的另外一个接口.Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 | ★★☆☆☆    | ★★★★☆    |
| 组合(Composite) | 将对象组合成树形结构以表示“部分-整体”的层次结构,使得用户对单个对象和组合对象的使用具有一致性 | ★★★☆☆    | ★★★★☆    |
| 代理(Proxy )    | 为其他对象提供一种代理以控制对这个对象的访问                 | ★★★☆☆    | ★★★★☆    |
| 桥接(Bridge)    | 将抽象部分与它的实现部分分离,使它们都可以独立地变化          | ★★★☆☆    | ★★★☆☆    |
| 装饰(Decorator) | 动态地给一个对象添加一些额外的职责                           | ★★★☆☆    | ★★★☆☆    |
| 享元(Flyweight) | 使用共享来有效地支持大量细粒度对象                           | ★★★★☆    | ★☆☆☆☆    |

#### 行为型(Behavioral patterns)

| 设计模式                        | 描述                                                         | 学习难度 | 使用频率 |
| ------------------------------- | ------------------------------------------------------------ | -------- | -------- |
| 观察者(Observer)                | 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新 | ★★★☆☆    | ★★★★★    |
| 迭代器                          | 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示 | ★★★☆☆    | ★★★★★    |
| 策略(Strategy)                  | 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化 | ★☆☆☆☆    | ★★★★☆    |
| 命令                            | 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作 | ★★★☆☆    | ★★★★☆    |
| 状态(State)                     | 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类 | ★★★☆☆    | ★★★☆☆    |
| 模板方法(Template Method)       | 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 | ★★☆☆☆    | ★★★☆☆    |
| 中介者(Mediator)                | 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 | ★★★☆☆    | ★★☆☆☆    |
| 责任链(Chain of Responsibility) | 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止 | ★★★☆☆    | ★★☆☆☆    |
| 访问者(Visitor)                 | 表示要在对象结构的元素上执行的操作。Visitor允许您定义一个新的操作，而不需要更改它所操作的元素的类 | ★★★★☆    | ★☆☆☆☆    |
| 解释器(Interpreter)             | 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子 | ★★★★★    | ★☆☆☆☆    |
| 备忘录(Memento)                 | 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态 | ★★☆☆☆    | ★★☆☆☆    |

**设计模式的用途：**

- 设计模式来源众多专家的经验和智慧，它们是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作
- 设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。
- 设计模式将有助于提高系统的灵活性和可扩展性，让我们在不修改或者少修改现有系统的基础上增加、删除或者替换功能模块。
- 合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统。

### 设计模式的六大原则

![在这里插入图片描述](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/17172acff10be430%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp)

#### 开放封闭原则（Open Close Principle）

- 原则思想：**尽量通过扩展软件实体来解决需求变化**，而不是通过修改已有的代码来完成变化
- 描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。
- 优点：单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。

#### 里氏代换原则（Liskov Substitution Principle）

- 原则思想：**使用的基类可以在任何地方使用继承的子类**，完美的替换基类。
- 大概意思是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。
- 优点：增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。

#### 依赖倒转原则（Dependence Inversion Principle）

- 依赖倒置原则的核心思想是**面向接口编程**.
- 依赖倒转原则要求我们**在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类**，
- 这个是开放封闭原则的基础，具体内容是：对接口编程，依赖于抽象而不依赖于具体。

#### 接口隔离原则（Interface Segregation Principle）

- 这个原则的意思是：**使用多个隔离的接口，比使用单个接口要好**。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
- 例如：支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口

#### 迪米特法则（最少知道原则）（Demeter Principle）

- 原则思想：**一个对象应当对其他对象有尽可能少地了解，简称类间解耦**
- 大概意思就是一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。
- 优点：低耦合，高内聚。

#### 单一职责原则（Principle of single responsibility）

- 原则思想：**一个方法只负责一件事情**。
- 描述：单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。
- 优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。

## 创建型模式

创建型模式提供了创建对象的机制，能够提升已有代码的灵 活性和可复用性。

### 工厂模式

[参考](https://mp.weixin.qq.com/s/MlC6-TDf06LGpF8hxcSV_w)

#### 什么是工厂模式

- 它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。**实现了创建者和调用者分离**，工厂模式分为简单工厂、工厂方法、抽象工厂模式

#### 工厂模式好处

- 工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。
- 利用工厂模式可以降低程序的耦合性，为后期的维护修改提供了很大的便利。
- 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。

#### 为什么要学习工厂设计模式

- 不知道你们面试题问到过源码没有，你知道Spring的源码吗，MyBatis的源码吗，等等等 如果你想学习很多框架的源码，或者你想自己开发自己的框架，就必须先掌握设计模式（工厂设计模式用的是非常非常广泛的）

### 简单工厂模式

go 语言没有构造函数一说，所以一般会定义NewXXX函数来初始化相关类。

NewXXX 函数返回接口时就是简单工厂模式，也就是说Golang的一般推荐做法就是简单工厂。

在这个simplefactory包中只有API 接口和NewAPI函数为包外可见，封装了实现细节。

简单工厂模式主要包含3个角色。

- 简单工厂（factory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。
- 抽象产品（Product）：是简单工厂创建的所有对象的抽象父类/接口，负责描述所有实例的行为。
- 具体产品（Concrete Product）：是简单工厂模式的创建目标。

![img](http://image.tengj.top/sjms1_2.png)

simple.go代码

```go
package simplefactory

import "fmt"

//API is interface
type API interface {
    Say(name string) string
}

//NewAPI return Api instance by type
func NewAPI(t int) API {
    if t == 1 {
        return &hiAPI{}
    } else if t == 2 {
        return &helloAPI{}
    }
    return nil
}

//hiAPI is one of API implement
type hiAPI struct{}

//Say hi to name
func (*hiAPI) Say(name string) string {
    return fmt.Sprintf("Hi, %s", name)
}

//HelloAPI is another API implement
type helloAPI struct{}

//Say hello to name
func (*helloAPI) Say(name string) string {
    return fmt.Sprintf("Hello, %s", name)
}
```

simple_test.go代码

```go
package simplefactory

import "testing"

//TestType1 test get hiapi with factory
func TestType1(t *testing.T) {
    api := NewAPI(1)
    s := api.Say("Tom")
    if s != "Hi, Tom" {
        t.Fatal("Type1 test fail")
    }
}

func TestType2(t *testing.T) {
    api := NewAPI(2)
    s := api.Say("Tom")
    if s != "Hello, Tom" {
        t.Fatal("Type2 test fail")
    }
}
```

### 工厂方法模式

**工厂方法模式使用子类的方式延迟生成对象到子类中实现。**

Go中不存在继承 所以**使用匿名组合来实现**



追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：**客户类和工厂类分开**。

消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。

​	工厂方法模式角色

- 抽象工厂(Abstract Factory)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。
- 具体工厂(Concrete Factory)角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。
- 抽象产品(AbstractProduct)角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。
- 具体产品(Concrete Product)角色 ：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应

![img](http://image.tengj.top/sjms2_1.png)

factorymethod.go

```go
package factorymethod

//Operator 是被封装的实际类接口
type Operator interface {
    SetA(int)
    SetB(int)
    Result() int
}

//OperatorFactory 是工厂接口
type OperatorFactory interface {
    Create() Operator
}

//OperatorBase 是Operator 接口实现的基类，封装公用方法
type OperatorBase struct {
    a, b int
}

//SetA 设置 A
func (o *OperatorBase) SetA(a int) {
    o.a = a
}

//SetB 设置 B
func (o *OperatorBase) SetB(b int) {
    o.b = b
}

//PlusOperatorFactory 是 PlusOperator 的工厂类
type PlusOperatorFactory struct{}

func (PlusOperatorFactory) Create() Operator {
    return &PlusOperator{
        OperatorBase: &OperatorBase{},
    }
}

//PlusOperator Operator 的实际加法实现
type PlusOperator struct {
    *OperatorBase
}

//Result 获取结果
func (o PlusOperator) Result() int {
    return o.a + o.b
}

//MinusOperatorFactory 是 MinusOperator 的工厂类
type MinusOperatorFactory struct{}

func (MinusOperatorFactory) Create() Operator {
    return &MinusOperator{
        OperatorBase: &OperatorBase{},
    }
}

//MinusOperator Operator 的实际减法实现
type MinusOperator struct {
    *OperatorBase
}

//Result 获取结果
func (o MinusOperator) Result() int {
    return o.a - o.b
}
```

factorymethod_test.go

```go
package factorymethod

import "testing"

func compute(factory OperatorFactory, a, b int) int {
    op := factory.Create()
    op.SetA(a)
    op.SetB(b)
    return op.Result()
}

func TestOperator(t *testing.T) {
    var (
        factory OperatorFactory
    )

    factory = PlusOperatorFactory{}
    if compute(factory, 1, 2) != 3 {
        t.Fatal("error with factory method pattern")
    }

    factory = MinusOperatorFactory{}
    if compute(factory, 4, 2) != 2 {
        t.Fatal("error with factory method pattern")
    }
}
```

### 抽象工厂模式

抽象工厂模式：用于创建一系列相关的或者相互依赖的对象。

抽象工厂模式用于生成产品族的工厂，所生成的对象是有关联的。

如果抽象工厂退化成生成的对象无关联则成为工厂函数模式。

比如本例子中使用RDB和XML存储订单信息，抽象工厂分别能生成相关的主订单信息和订单详情信息。

如果业务逻辑中需要替换使用的时候只需要改动工厂函数相关的类就能替换使用不同的存储方式了。



请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。

工厂方法模式：**核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节**。

抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。

抽象工厂模式中存在四种角色，分别是抽象工厂角色，具体工厂角色，抽象产品角色，具体产品角色。 

- 抽象工厂角色：担任这个角色的是工厂方法模式的核心，它是与应用系统商业逻辑无关的。
- 具体工厂角色：这个角色直接在客户端的调用下创建产品的实例。这个角色含有选择合适的产品对象的逻辑，而这个逻辑是与应用系统的商业逻辑紧密相关的。 
- 抽象产品角色：担任这个角色的类是工厂方法模式所创建的对象的父类，或它们共同拥有的接口。 
- 具体产品角色：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。这是客户端最终需要的东西，其内部一定充满了应用系统的商业逻辑。 

![img](https://images2017.cnblogs.com/blog/249993/201710/249993-20171018163750756-1114804737.png)

abstractfactory.go

```go
package abstractfactory

import "fmt"

//OrderMainDAO 为订单主记录
type OrderMainDAO interface {
    SaveOrderMain()
}

//OrderDetailDAO 为订单详情纪录
type OrderDetailDAO interface {
    SaveOrderDetail()
}

//DAOFactory DAO 抽象模式工厂接口
type DAOFactory interface {
    CreateOrderMainDAO() OrderMainDAO
    CreateOrderDetailDAO() OrderDetailDAO
}

//RDBMainDAP 为关系型数据库的OrderMainDAO实现
type RDBMainDAO struct{}

//SaveOrderMain ...
func (*RDBMainDAO) SaveOrderMain() {
    fmt.Print("rdb main save\n")
}

//RDBDetailDAO 为关系型数据库的OrderDetailDAO实现
type RDBDetailDAO struct{}

// SaveOrderDetail ...
func (*RDBDetailDAO) SaveOrderDetail() {
    fmt.Print("rdb detail save\n")
}

//RDBDAOFactory 是RDB 抽象工厂实现
type RDBDAOFactory struct{}

func (*RDBDAOFactory) CreateOrderMainDAO() OrderMainDAO {
    return &RDBMainDAO{}
}

func (*RDBDAOFactory) CreateOrderDetailDAO() OrderDetailDAO {
    return &RDBDetailDAO{}
}

//XMLMainDAO XML存储
type XMLMainDAO struct{}

//SaveOrderMain ...
func (*XMLMainDAO) SaveOrderMain() {
    fmt.Print("xml main save\n")
}

//XMLDetailDAO XML存储
type XMLDetailDAO struct{}

// SaveOrderDetail ...
func (*XMLDetailDAO) SaveOrderDetail() {
    fmt.Print("xml detail save")
}

//XMLDAOFactory 是RDB 抽象工厂实现
type XMLDAOFactory struct{}

func (*XMLDAOFactory) CreateOrderMainDAO() OrderMainDAO {
    return &XMLMainDAO{}
}

func (*XMLDAOFactory) CreateOrderDetailDAO() OrderDetailDAO {
    return &XMLDetailDAO{}
}
```

abstractfactory_test.go

```go
package abstractfactory

func getMainAndDetail(factory DAOFactory) {
    factory.CreateOrderMainDAO().SaveOrderMain()
    factory.CreateOrderDetailDAO().SaveOrderDetail()
}

func ExampleRdbFactory() {
    var factory DAOFactory
    factory = &RDBDAOFactory{}
    getMainAndDetail(factory)
    // Output:
    // rdb main save
    // rdb detail save
}

func ExampleXmlFactory() {
    var factory DAOFactory
    factory = &XMLDAOFactory{}
    getMainAndDetail(factory)
    // Output:
    // xml main save
    // xml detail save
}
```

### 创建者（建造者）模式

将一个复杂对象的构建分离成多个简单对象的构建组合

建造者模式(Builder Pattern)：**将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示**。

建造者模式是一步一步创建一个复杂的对象，它允许用户**只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节**。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。



MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。

建造模式：**将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象**。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。

建造者模式的各个角色：

- 指挥者角色（Director）:指挥者的职责，是指挥建造者按照一定顺序完成产品对象的构建。
- 抽象建造者角色（Builder）：为创建一个Product对象的各个部件指定的抽象接口。
- 具体建造者角色（ConcreteBuilder）：实现Builder接口，构造和装配各个部件。
- 产品角色（Product）

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afd43c733d8e40bebf0eac77690415bb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

builder.go

```go
package builder

//Builder 是生成器接口
type Builder interface {
    Part1()
    Part2()
    Part3()
}

type Director struct {
    builder Builder
}

// NewDirector ...
func NewDirector(builder Builder) *Director {
    return &Director{
        builder: builder,
    }
}

//Construct Product
func (d *Director) Construct() {
    d.builder.Part1()
    d.builder.Part2()
    d.builder.Part3()
}

type Builder1 struct {
    result string
}

func (b *Builder1) Part1() {
    b.result += "1"
}

func (b *Builder1) Part2() {
    b.result += "2"
}

func (b *Builder1) Part3() {
    b.result += "3"
}

func (b *Builder1) GetResult() string {
    return b.result
}

type Builder2 struct {
    result int
}

func (b *Builder2) Part1() {
    b.result += 1
}

func (b *Builder2) Part2() {
    b.result += 2
}

func (b *Builder2) Part3() {
    b.result += 3
}

func (b *Builder2) GetResult() int {
    return b.result
}
```

builder_test.go

```go
package builder

import "testing"

func TestBuilder1(t *testing.T) {
    builder := &Builder1{}
    director := NewDirector(builder)
    director.Construct()
    res := builder.GetResult()
    if res != "123" {
        t.Fatalf("Builder1 fail expect 123 acture %s", res)
    }
}

func TestBuilder2(t *testing.T) {
    builder := &Builder2{}
    director := NewDirector(builder)
    director.Construct()
    res := builder.GetResult()
    if res != 6 {
        t.Fatalf("Builder2 fail expect 6 acture %d", res)
    }
}
```

### 原型模式

[参考](https://mp.weixin.qq.com/s/y1qHsQNR7EWeDU5g60Loqg)

**原型模式使对象能复制自身，并且暴露到接口中，使客户端面向接口编程时，不知道接口实际对象的情况下生成新的对象**。

原型模式配合原型管理器使用，使得客户端在不知道具体类的情况下，通过接口管理器得到新的实例，并且包含部分预设定配置。

跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）

原始模型模式：**通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象**。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。

**原型模式涉及的三个角色：**

- Client 角色 (客户角色)： 该角色提出创建对象的请求
- Prototype 角色 (抽象原型角色)：该角色用于给出具体原型所需的接口，常由接口或抽象类担任
- Concrete Protype 角色 (具体角色)： 该角色是被复制的对象必须实现抽象原型的接口

![img](http://image.tengj.top/sjms5_1.jpg)

#### 使用场景

当对象的创建成本比较大，并且同一个类的不同对象间差别不大时（大部分属性值相同），如果对象的属性值需要经过复杂的计算、排序，或者需要从网络、DB等这些慢IO中获取、亦或者或者属性值拥有很深的层级，这时就是原型模式发挥作用的地方了。

因为对象在内存中复制自己远比每次创建对象时重走一遍上面说的操作要来高效的多。

#### 示例

prototype.go

```go
package prototype

//Cloneable 是原型对象需要实现的接口
type Cloneable interface {
    Clone() Cloneable
}

type PrototypeManager struct {
    prototypes map[string]Cloneable
}

func NewPrototypeManager() *PrototypeManager {
    return &PrototypeManager{
        prototypes: make(map[string]Cloneable),
    }
}

func (p *PrototypeManager) Get(name string) Cloneable {
    return p.prototypes[name]
}

func (p *PrototypeManager) Set(name string, prototype Cloneable) {
    p.prototypes[name] = prototype
}
```

prototype_test.go

```go
package prototype

import "testing"

var manager *PrototypeManager

type Type1 struct {
    name string
}

func (t *Type1) Clone() Cloneable {
    tc := *t
    return &tc
}

type Type2 struct {
    name string
}

func (t *Type2) Clone() Cloneable {
    tc := *t
    return &tc
}

func TestClone(t *testing.T) {
    t1 := manager.Get("t1")

    t2 := t1.Clone()

    if t1 == t2 {
        t.Fatal("error! get clone not working")
    }
}

func TestCloneFromManager(t *testing.T) {
    c := manager.Get("t1").Clone()

    t1 := c.(*Type1)
    if t1.name != "type1" {
        t.Fatal("error")
    }

}

func init() {
    manager = NewPrototypeManager()

    t1 := &Type1{
        name: "type1",
    }
    manager.Set("t1", t1)
}
```

#### 总结

原型模式的优点

- 某些时候克隆比直接new一个对象再逐属性赋值的过程更简洁高效，比如创建层级很深的对象的时候，克隆比直接用构造会方便很多。
- 可以使用深克隆方式保存对象的状态，可辅助实现撤销操作。

原型模式的缺点

- **clone方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则**。
- 当实现深克隆时，需要编写较为复杂的代码，尤其当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆。因此，深克隆、浅克隆需要运用得当。

在项目中使用原型模式时，可能需要在项目初始化时就把提供克隆能力的原型对象创建好，在多线程环境下，每个线程处理任务的时候，用到了相关对象，可以去原型对象那里拷贝。不过适合当作原型对象的数据并不多，所以原型模式在开发中的使用频率并不高，如果有机会做项目架构，可以适当考虑，确实需要再在项目中引入这种设计模式。

### 单例模式

#### 什么是单例

- 保证一个类只有一个实例，并且提供一个访问该全局访问点

#### 那些地方用到了单例模式

1. **网站的计数器**，一般也是采用单例模式实现，否则难以同步。
2. **应用程序的日志应用**，一般都是单例模式实现，只有一个实例去操作才好，否则内容不好追加显示。
3. **多线程的线程池的设计**一般也是采用单例模式，因为线程池要方便对池中的线程进行控制
4. **Windows的（任务管理器）**就是很典型的单例模式，他不能打开俩个
5. **windows的（回收站）**也是典型的单例应用。在整个系统运行过程中，回收站只维护一个实例。

使用懒惰模式的单例模式，使用双重检查加锁保证线程安全

#### 单例优缺点

**优点：**

1. 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例
2. 单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。
3. 提供了对唯一实例的受控访问。
4. 由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。
5. 允许可变数目的实例。
6. 避免对共享资源的多重占用。

**缺点：**

1. **不适用于变化的对象**，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。
2. **由于单利模式中没有抽象层**，因此单例类的扩展有很大的困难。
3. **单例类的职责过重，**在一定程度上违背了“单一职责原则”。
4. 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。

#### 单例模式使用注意事项：

1. 使用时不能用反射模式创建单例，否则会实例化一个新的对象
2. 使用懒单例模式时注意线程安全问题
3. 饿单例模式和懒单例模式构造方法都是私有的，因而是不能被继承的，有些单例模式可以被继承（如登记式模式）

#### 单例创建方式

**（主要使用懒汉和懒汉式）**

1. 饿汉式:**类初始化时,会立即加载该对象**，线程天生安全,调用效率高。
2. 懒汉式: 类初始化时,不会初始化该对象,**真正需要使用的时候才会创建该对象**,具备懒加载功能。
3. 静态内部方式:结合了懒汉式和饿汉式各自的优点，**真正需要对象的时候才会加载**，加载类是线程安全的。
4. 枚举单例: 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例。
5. **双重检测锁方式**

单例模式(Singleton Pattern)：**单例模式确保某一个类只有一个实例**，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

单例模式的要点有三个：一是某个类只能有一个实例；二是它必须**自行创建**这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。



俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)

单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。

#### 示例

singleton.go

```go
package singleton

import "sync"

//Singleton 是单例模式类
type Singleton struct{}

var singleton *Singleton
var once sync.Once

//GetInstance 用于获取单例模式对象
func GetInstance() *Singleton {
    once.Do(func() {
        singleton = &Singleton{}
    })

    return singleton
}
```

singleton_test.go

```go
package singleton

import (
    "sync"
    "testing"
)

const parCount = 100

func TestSingleton(t *testing.T) {
    ins1 := GetInstance()
    ins2 := GetInstance()
    if ins1 != ins2 {
        t.Fatal("instance is not equal")
    }
}

func TestParallelSingleton(t *testing.T) {
    wg := sync.WaitGroup{}
    wg.Add(parCount)
    instances := [parCount]*Singleton{}
    for i := 0; i < parCount; i++ {
        go func(index int) {
            instances[index] = GetInstance()
            wg.Done()
        }(i)
    }
    wg.Wait()
    for i := 1; i < parCount; i++ {
        if instances[i] != instances[i-1] {
            t.Fatal("instance is not equal")
        }
    }
}
```

## 结构性模式

结构型模式介绍**如何将对象和类组装成较大的结构**，并同时 保持结构的灵活和高效。

### 外观模式

外观是一种结构型设计模式， 能为程序库、框架或其他复杂类提供一个简单的接口。

API 为facade 模块的外观接口，大部分代码使用此接口简化对facade类的访问。

facade模块同时暴露了a和b 两个Module 的NewXXX和interface，其它代码如果需要使用细节功能时可以直接调用。

外观模式(Facade Pattern)：**外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式**，它是一种对象结构型模式。



我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。

**门面模式提供一个高层次的接口，使得子系统更易于使用**。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。

外观模式包含如下两个角色：

- Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。
- SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，**对于子系统而言，外观角色仅仅是另外一个客户端而已**。

<img src="http://www.hardydou.com/images/pasted-166.png" alt="upload successful" style="zoom:50%;" />

facade.go

```go
package facade

import "fmt"

func NewAPI() API {
    return &apiImpl{
        a: NewAModuleAPI(),
        b: NewBModuleAPI(),
    }
}

//API is facade interface of facade package
type API interface {
    Test() string
}

//facade implement
type apiImpl struct {
    a AModuleAPI
    b BModuleAPI
}

func (a *apiImpl) Test() string {
    aRet := a.a.TestA()
    bRet := a.b.TestB()
    return fmt.Sprintf("%s\n%s", aRet, bRet)
}

//NewAModuleAPI return new AModuleAPI
func NewAModuleAPI() AModuleAPI {
    return &aModuleImpl{}
}

//AModuleAPI ...
type AModuleAPI interface {
    TestA() string
}

type aModuleImpl struct{}

func (*aModuleImpl) TestA() string {
    return "A module running"
}

//NewBModuleAPI return new BModuleAPI
func NewBModuleAPI() BModuleAPI {
    return &bModuleImpl{}
}

//BModuleAPI ...
type BModuleAPI interface {
    TestB() string
}

type bModuleImpl struct{}

func (*bModuleImpl) TestB() string {
    return "B module running"
}
```

facade_test.go

```go
package facade

import "testing"

var expect = "A module running\nB module running"

// TestFacadeAPI ...
func TestFacadeAPI(t *testing.T) {
    api := NewAPI()
    ret := api.Test()
    if ret != expect {
        t.Fatalf("expect %s, return %s", expect, ret)
    }
}
```

### 适配器模式

适配器是一种结构型设计模式， 它能**使接口不兼容的对象能够　 相互合作**。

**适配器模式用于转换一种接口适配另一种接口。**

实际使用中Adaptee一般为接口，并且使用工厂函数生成实例。

在Adapter中匿名组合Adaptee接口，所以Adapter类也拥有SpecificRequest实例方法，又因为Go语言中非入侵式接口特征，其实Adapter也适配Adaptee接口。



在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)

适配器（变压器）模式：**把一个类的接口变换成客户端所期待的另一种接口**，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。

**Target目标角色**：该角色定义把其他类转换为何种接口，也就是我们所期望的接口。

**Adaptee源角色**：想把谁转换为目标角色，这个谁就是源角色，它是已经存在的、运行良好的类或对象，经过适配器角色的包装，它会成为一个崭新、靓丽的角色，

**Adapter适配器角色**：适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建的，它的职责非常简单：把源角色转换为目标角色，怎么转换？通过继承类或者是类关联的方式。

<img src="https://img-blog.csdn.net/20160720111924708?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom:50%;" />

adapter.go

```go
package adapter

//Target 是适配的目标接口
type Target interface {
    Request() string
}

//Adaptee 是被适配的目标接口
type Adaptee interface {
    SpecificRequest() string
}

//NewAdaptee 是被适配接口的工厂函数
func NewAdaptee() Adaptee {
    return &adapteeImpl{}
}

//AdapteeImpl 是被适配的目标类
type adapteeImpl struct{}

//SpecificRequest 是目标类的一个方法
func (*adapteeImpl) SpecificRequest() string {
    return "adaptee method"
}

//NewAdapter 是Adapter的工厂函数
func NewAdapter(adaptee Adaptee) Target {
    return &adapter{
        Adaptee: adaptee,
    }
}

//Adapter 是转换Adaptee为Target接口的适配器
type adapter struct {
    Adaptee
}

//Request 实现Target接口
func (a *adapter) Request() string {
    return a.SpecificRequest()
}
```

adapter_test.go

```go
package adapter

import "testing"

var expect = "adaptee method"

func TestAdapter(t *testing.T) {
    adaptee := NewAdaptee()
    target := NewAdapter(adaptee)
    res := target.Request()
    if res != expect {
        t.Fatalf("expect: %s, actual: %s", expect, res)
    }
}
```

### 代理模式

代理模式**用于延迟处理操作或者在进行实际操作前后进行其它处理**。

代理是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。

#### 什么是代理模式

- 通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理/添加新的功能。(也就是AO的P微实现)
- 代理在原有代码乃至原业务流程都不修改的情况下，直接在业务流程中切入新代码，增加新功能，这也和Spring的（面向切面编程）很相似

#### 代理模式的常见用法有

- 虚代理
- COW代理
- 远程代理
- 保护代理
- Cache 代理
- 防火墙代理
- 同步代理
- 智能指引

等。。。



跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。

代理模式：**代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用**。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。

客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。

代理模式共分为四种角色：

- **Subject**（抽象主题角色）：**真实主题角色与代理主题角色的共同父类**，可以是具体类、抽象类、接口，客户端针对抽象主题角色编程
- **RealSubject**（真实主题角色）：**实现具体业务方法的类**，被代理主题角色调用
- **Proxy**（代理主题角色）：持有真实主题角色的引用，在调用真实主题角色的具体业务方法之前或者之后添加其它操作

类似于中间件。

![img](https://oscimg.oschina.net/oscnet/035761e0d20e4dd2d8d27c03e4c0591d0cb.jpg)

proxy.go

```go
package proxy

type Subject interface {
    Do() string
}

type RealSubject struct{}

func (RealSubject) Do() string {
    return "real"
}

type Proxy struct {
    real RealSubject
}

func (p Proxy) Do() string {
    var res string

    // 在调用真实对象之前的工作，检查缓存，判断权限，实例化真实对象等。。
    res += "pre:"

    // 调用真实对象
    res += p.real.Do()

    // 调用之后的操作，如缓存结果，对结果进行处理等。。
    res += ":after"

    return res
}
```

proxy_test.go

```go
package proxy

import "testing"

func TestProxy(t *testing.T) {
    var sub Subject
    sub = &Proxy{}

    res := sub.Do()

    if res != "pre:real:after" {
        t.Fail()
    }
}
```

### 组合模式

**组合模式统一对象和对象集，使得使用相同接口使用对象和对象集**。

#### 什么是「组合模式」？

> 一个具有层级关系的对象由一系列拥有父子关系的对象通过树形结构组成。

组合模式的优势：

- 所见即所码：你所看见的代码结构就是业务真实的层级关系，比如Ui界面你真实看到的那样。
- 高度封装：单一职责。
- 可复用：不同业务场景，相同的组件可被重复使用。

**组合模式常用于树状结构**，用于统一叶子节点和树节点的访问，并且可以用于应用某一操作到所有子节点。

组合模式中一般有以下三种角色：

- 抽象构件（`Component`）：一般是接口或者抽象类，是叶子构件和容器构件对象声明接口，抽象出访问以及管理子构件的方法。
- 叶子节点（`Leaf`）：在组合中表示叶子节点对象，叶子节点没有子节点，也就没有子构件。
- 容器构件（`Composite`）：容器节点可以包含子节点，子节点可以是叶子节点，也可以是容器节点。

注意：关键点就是抽象构件，所有节点都统一，不再需要调用者关心叶子节点与非叶子节点的差异。

![重学设计模式（三、设计模式-组合模式） - 掘金](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQuK4KZkUDavjuODF0BcDv8izxdcJg4eXZz6w&usqp=CAU)

![设计模式——组合模式_肥羊汤的博客-CSDN博客](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTkucYALQ3q7bvEuhppufv2Y3Hm7uYLEmJPQQ&usqp=CAU)

composite.go

```go
package composite

import "fmt"

type Component interface {
    Parent() Component
    SetParent(Component)
    Name() string
    SetName(string)
    AddChild(Component)
    Print(string)
}

const (
    LeafNode = iota
    CompositeNode
)

func NewComponent(kind int, name string) Component {
    var c Component
    switch kind {
    case LeafNode:
        c = NewLeaf()
    case CompositeNode:
        c = NewComposite()
    }

    c.SetName(name)
    return c
}

type component struct {
    parent Component
    name   string
}

func (c *component) Parent() Component {
    return c.parent
}

func (c *component) SetParent(parent Component) {
    c.parent = parent
}

func (c *component) Name() string {
    return c.name
}

func (c *component) SetName(name string) {
    c.name = name
}

func (c *component) AddChild(Component) {}

func (c *component) Print(string) {}

type Leaf struct {
    component
}

func NewLeaf() *Leaf {
    return &Leaf{}
}

func (c *Leaf) Print(pre string) {
    fmt.Printf("%s-%s\n", pre, c.Name())
}

type Composite struct {
    component
    childs []Component
}

func NewComposite() *Composite {
    return &Composite{
        childs: make([]Component, 0),
    }
}

func (c *Composite) AddChild(child Component) {
    child.SetParent(c)
    c.childs = append(c.childs, child)
}

func (c *Composite) Print(pre string) {
    fmt.Printf("%s+%s\n", pre, c.Name())
    pre += " "
    for _, comp := range c.childs {
        comp.Print(pre)
    }
}
```

composite_test.go

```go
package composite

func ExampleComposite() {
    root := NewComponent(CompositeNode, "root")
    c1 := NewComponent(CompositeNode, "c1")
    c2 := NewComponent(CompositeNode, "c2")
    c3 := NewComponent(CompositeNode, "c3")

    l1 := NewComponent(LeafNode, "l1")
    l2 := NewComponent(LeafNode, "l2")
    l3 := NewComponent(LeafNode, "l3")

    root.AddChild(c1)
    root.AddChild(c2)
    c1.AddChild(c3)
    c1.AddChild(l1)
    c2.AddChild(l2)
    c2.AddChild(l3)

    root.Print("")
    // Output:
    // +root
    //  +c1
    //   +c3
    //   -l1
    //  +c2
    //   -l2
    //   -l3
}
```

#### 实战

[参考](https://github.com/TIGERB/easy-tips/tree/master/go/patterns/composite)

### 享元模式

**享元模式从对象中剥离出不发生改变且多个实例需要的重复数据，独立出一个享元，使多个对象共享**，从而节省内存以及减少对象数量。



每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。

享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。

将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。

一般情况下享元模式分为三种角色

- **抽象享元角色（IFlyweight）：** 享元对象抽象基类或者接口，同时定义出对象的外部状态和内部状态的接口实现，主要是提供需要实现的公共接口
- **享元工厂角色（FlyweightFactory）：** 主要负责创建和管理享元角色。判断是否存在符合要求的享元对象，如果存在则直接拿取，如果不存在的话就会创建一个享元对象并保存。
- **具体享元角色（ConcreteFlyweight）：** 继承于抽象享元角色。实现抽象享元角色定义的义务，该角色的内部状态于环境无关，不会出现有一个操作修改了修改内部环境状态，同时修改了外部状态的情况。

![img](https://img.jbzj.com/file_images/article/202203/202233145628637.png?202223145647)

flyweight.go

```go
package flyweight

import "fmt"

type ImageFlyweightFactory struct {
    maps map[string]*ImageFlyweight
}

var imageFactory *ImageFlyweightFactory

func GetImageFlyweightFactory() *ImageFlyweightFactory {
    if imageFactory == nil {
        imageFactory = &ImageFlyweightFactory{
            maps: make(map[string]*ImageFlyweight),
        }
    }
    return imageFactory
}

func (f *ImageFlyweightFactory) Get(filename string) *ImageFlyweight {
    image := f.maps[filename]
    if image == nil {
        image = NewImageFlyweight(filename)
        f.maps[filename] = image
    }

    return image
}

type ImageFlyweight struct {
    data string
}

func NewImageFlyweight(filename string) *ImageFlyweight {
    // Load image file
    data := fmt.Sprintf("image data %s", filename)
    return &ImageFlyweight{
        data: data,
    }
}

func (i *ImageFlyweight) Data() string {
    return i.data
}

type ImageViewer struct {
    *ImageFlyweight
}

func NewImageViewer(filename string) *ImageViewer {
    image := GetImageFlyweightFactory().Get(filename)
    return &ImageViewer{
        ImageFlyweight: image,
    }
}

func (i *ImageViewer) Display() {
    fmt.Printf("Display: %s\n", i.Data())
}
```

flyweight_test.go

```go
package flyweight

import "testing"

func ExampleFlyweight() {
    viewer := NewImageViewer("image1.png")
    viewer.Display()
    // Output:
    // Display: image data image1.png
}

func TestFlyweight(t *testing.T) {
    viewer1 := NewImageViewer("image1.png")
    viewer2 := NewImageViewer("image1.png")

    if viewer1.ImageFlyweight != viewer2.ImageFlyweight {
        t.Fail()
    }
}
```

### 装饰模式

装饰模式**使用对象组合的方式动态改变或增加对象行为**。

Go语言借助于匿名组合和非入侵式接口可以很方便实现装饰模式。

使用匿名组合，在装饰器中不必显式定义转调原对象方法。



Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？

装饰模式：**装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性**。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。

装饰器模式主要包含以下角色。

1. 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
2. 具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。
3. 抽象装饰（Decorator）角色：**继承抽象构件，并包含具体构件的实例**，可以通过其子类扩展具体构件的功能。
4. 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

<img src="https://img-blog.csdn.net/20180809222150163?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG4xNTY5ODg0NTg3Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom:67%;" />

decorator.go

```go
package decorator

type Component interface {
    Calc() int
}

type ConcreteComponent struct{}

func (*ConcreteComponent) Calc() int {
    return 0
}

type MulDecorator struct {
    Component
    num int
}

func WarpMulDecorator(c Component, num int) Component {
    return &MulDecorator{
        Component: c,
        num:       num,
    }
}

func (d *MulDecorator) Calc() int {
    return d.Component.Calc() * d.num
}

type AddDecorator struct {
    Component
    num int
}

func WarpAddDecorator(c Component, num int) Component {
    return &AddDecorator{
        Component: c,
        num:       num,
    }
}

func (d *AddDecorator) Calc() int {
    return d.Component.Calc() + d.num
}
```

decorator_test.go

```go
package decorator

import "fmt"

func ExampleDecorator() {
    var c Component = &ConcreteComponent{}
    c = WarpAddDecorator(c, 10)
    c = WarpMulDecorator(c, 8)
    res := c.Calc()

    fmt.Printf("res %d\n", res)
    // Output:
    // res 80
}
```

#### 装饰器模式和代理模式相同点以及不同点

**相同点**

两种从设计模式分类来看都属于结构型，因为两者均使用了组合关系。其次**两者都能实现对对象方法进行增强处理的效果**。

**不同点**

代理模式，注重对对象某一功能的流程把控和辅助。它可以**控制对象做某些事**，重心是为了借用对象的功能完成某一流程，而非对象功能如何。

装饰模式，**注重对对象功能的扩展**，它不关心外界如何调用，只注重对对象功能的加强，装饰后还是对象本身。

举个例子说明两者不同之处，代理和装饰其实从另一个角度更容易去理解两个模式的区别：代理更多的是强调对对象的访问控制，比如说，访问A对象的查询功能时，访问B对象的更新功能时，访问C对象的删除功能时，都需要判断对象是否登陆，那么我需要将判断用户是否登陆的功能抽提出来，并对A对象、B对象和C对象进行代理，使访问它们时都需要去判断用户是否登陆，简单地说就是将某个控制访问权限应用到多个对象上；而装饰器更多的强调给对象加强功能，比如说要给只会唱歌的A对象添加跳舞功能，添加说唱功能等，简单地说就是**将多个功能附加在一个对象上**。

所以，**代理模式注重的是对对象的某一功能的流程把控和辅助，它可以控制对象做某些事，重心是为了借用对象的功能完成某一流程，而非对象功能如何。而装饰模式注重的是对对象功能的扩展，不关心外界如何调用，只注重对对象功能加强，装饰后还是对象本身**。 

### 桥模式

**桥接模式分离抽象部分和实现部分**。使得两部分独立扩展。

桥接模式类似于策略模式，区别在于策略模式封装一系列算法使得算法可以互相替换。

策略模式使抽象部分和实现部分分离，可以独立变化。

设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：

- 第一种设计方案是为每一种形状都提供一套各种颜色的版本。
- 第二种设计方案是根据实际需要对形状和颜色进行组合

对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。



早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了

**桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化**。

08 合成模式 Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？

合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。

桥接（Bridge）模式包含以下主要角色。

1. 1. 抽象化（Abstraction）角色：定义抽象类，并**包含一个对实现化对象的引用**。
   2. 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，**实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法**。
   3. 实现化（Implementor）角色：定义实现化角色的接口，**供扩展抽象化角色调用**。
   4. 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。

其结构图如图 1 所示：

![img](https://img2020.cnblogs.com/blog/1419013/202109/1419013-20210905133606192-1462019011.png)

bridge.go

```go
package bridge

import "fmt"

type AbstractMessage interface {
    SendMessage(text, to string)
}

type MessageImplementer interface {
    Send(text, to string)
}

type MessageSMS struct{}

func ViaSMS() MessageImplementer {
    return &MessageSMS{}
}

func (*MessageSMS) Send(text, to string) {
    fmt.Printf("send %s to %s via SMS", text, to)
}

type MessageEmail struct{}

func ViaEmail() MessageImplementer {
    return &MessageEmail{}
}

func (*MessageEmail) Send(text, to string) {
    fmt.Printf("send %s to %s via Email", text, to)
}

type CommonMessage struct {
    method MessageImplementer
}

func NewCommonMessage(method MessageImplementer) *CommonMessage {
    return &CommonMessage{
        method: method,
    }
}

func (m *CommonMessage) SendMessage(text, to string) {
    m.method.Send(text, to)
}

type UrgencyMessage struct {
    method MessageImplementer
}

func NewUrgencyMessage(method MessageImplementer) *UrgencyMessage {
    return &UrgencyMessage{
        method: method,
    }
}

func (m *UrgencyMessage) SendMessage(text, to string) {
    m.method.Send(fmt.Sprintf("[Urgency] %s", text), to)
}
```

bridge_test.go

```go
package bridge

func ExampleCommonSMS() {
    m := NewCommonMessage(ViaSMS())
    m.SendMessage("have a drink?", "bob")
    // Output:
    // send have a drink? to bob via SMS
}

func ExampleCommonEmail() {
    m := NewCommonMessage(ViaEmail())
    m.SendMessage("have a drink?", "bob")
    // Output:
    // send have a drink? to bob via Email
}

func ExampleUrgencySMS() {
    m := NewUrgencyMessage(ViaSMS())
    m.SendMessage("have a drink?", "bob")
    // Output:
    // send [Urgency] have a drink? to bob via SMS
}

func ExampleUrgencyEmail() {
    m := NewUrgencyMessage(ViaEmail())
    m.SendMessage("have a drink?", "bob")
    // Output:
    // send [Urgency] have a drink? to bob via Email
}
```

## 行为型模式

行为模式负责对象间的高效沟通和职责委派。

### 中介者模式

中介者是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。该模式**会限制对象之间的直接交互**，迫使它们通过一个中介者对象进行合作。

中介者模式封装对象之间互交，使依赖变的简单，并且使复杂互交简单化，封装在中介者中。

例子中的中介者使用单例模式生成中介者。

中介者的change使用switch判断类型。

中介者模式(Mediator Pattern)定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。



四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。

当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。

通俗理解，把复杂的网状结构关系分离为星型结构关系。

![img](https://code52-1305763557.file.myqcloud.com/uploads/article/9Uqw66Oy6p/9UqwJSVyaV.png)

中介模式由以下几部分组成:

1. **抽象中介者（Mediator）角色：** 它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。
2. **具体中介者（Concrete Mediator）角色：** 实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。
3. **抽象同事类（Colleague）角色：** 定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。
4. **具体同事类（Concrete Colleague）角色：** 是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。

![在这里插入图片描述](https://img-blog.csdnimg.cn/800352372a514714a0add81688a61c79.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAaGpwXzAwMQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

mediator.go

```go
package mediator

import (
    "fmt"
    "strings"
)

type CDDriver struct {
    Data string
}

func (c *CDDriver) ReadData() {
    c.Data = "music,image"

    fmt.Printf("CDDriver: reading data %s\n", c.Data)
    GetMediatorInstance().changed(c)
}

type CPU struct {
    Video string
    Sound string
}

func (c *CPU) Process(data string) {
    sp := strings.Split(data, ",")
    c.Sound = sp[0]
    c.Video = sp[1]

    fmt.Printf("CPU: split data with Sound %s, Video %s\n", c.Sound, c.Video)
    GetMediatorInstance().changed(c)
}

type VideoCard struct {
    Data string
}

func (v *VideoCard) Display(data string) {
    v.Data = data
    fmt.Printf("VideoCard: display %s\n", v.Data)
    GetMediatorInstance().changed(v)
}

type SoundCard struct {
    Data string
}

func (s *SoundCard) Play(data string) {
    s.Data = data
    fmt.Printf("SoundCard: play %s\n", s.Data)
    GetMediatorInstance().changed(s)
}

type Mediator struct {
    CD    *CDDriver
    CPU   *CPU
    Video *VideoCard
    Sound *SoundCard
}

var mediator *Mediator

func GetMediatorInstance() *Mediator {
    if mediator == nil {
        mediator = &Mediator{}
    }
    return mediator
}

func (m *Mediator) changed(i interface{}) {
    switch inst := i.(type) {
    case *CDDriver:
        m.CPU.Process(inst.Data)
    case *CPU:
        m.Sound.Play(inst.Sound)
        m.Video.Display(inst.Video)
    }
}
```

mediator_test.go

```go
package mediator

import "testing"

func TestMediator(t *testing.T) {
    mediator := GetMediatorInstance()
    mediator.CD = &CDDriver{}
    mediator.CPU = &CPU{}
    mediator.Video = &VideoCard{}
    mediator.Sound = &SoundCard{}

    //Tiggle
    mediator.CD.ReadData()

    if mediator.CD.Data != "music,image" {
        t.Fatalf("CD unexpect data %s", mediator.CD.Data)
    }

    if mediator.CPU.Sound != "music" {
        t.Fatalf("CPU unexpect sound data %s", mediator.CPU.Sound)
    }

    if mediator.CPU.Video != "image" {
        t.Fatalf("CPU unexpect video data %s", mediator.CPU.Video)
    }

    if mediator.Video.Data != "image" {
        t.Fatalf("VidoeCard unexpect data %s", mediator.Video.Data)
    }

    if mediator.Sound.Data != "music" {
        t.Fatalf("SoundCard unexpect data %s", mediator.Sound.Data)
    }
}
```

### 观察者模式

#### 什么是「观察者模式」？

**观察者模式用于触发联动**。

一个对象的改变会触发其它观察者的相关动作，而此对象无需关心连动对象的具体实现。

观察者模式(Observer Pattern)：**定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新**。观察者模式又叫做**发布-订阅**（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。

想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。

> 观察者观察被观察者，被观察者通知观察者

我们用“订阅通知”翻译下「观察者模式」的概念，结果：

> “订阅者订阅主题，主题通知订阅者”

是不是容易理解多了，我们再来拆解下这句话，得到：

- 两个对象
  - 被观察者 -> 主题
  - 观察者 -> 订阅者
- 两个动作
  - 订阅 -> 订阅者**订阅**主题
  - 通知 -> 主题发生变动**通知**订阅者

观察者模式的优势：

- 高内聚 -> 不同业务代码变动互不影响
- 可复用 -> 新的业务(就是新的订阅者)订阅不同接口(主题，就是这里的接口)
- 极易扩展 -> 新增接口(就是新增主题)；新增业务(就是新增订阅者)；

其实说白了，就是分布式架构中使用消息机制MQ解耦业务的优势，是不是这么一想很容易理解了。

**角色介绍**

- Subject：抽象主题，也就是被观察（Observable）的角色，**抽象主题角色把所有观察者对象的引用保存在一个集合中**，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者
- ConcreteSubject：具体主题，该角色将有关状态存入具体的观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发出通知，也可以叫做具体被观察者（ConcreteObservable）
- Observer：抽象观察者，定义了一个更新接口，在得到主题更改的通知时可以更新自己
- ConcreteObserver：具体观察者，实现抽象观察者所定义的接口，在主题发生状态改变时更新自己。

![image.png](https://segmentfault.com/img/bVcStJX)

obserser.go

```go
package observer

import "fmt"

type Subject struct {
    observers []Observer
    context   string
}

func NewSubject() *Subject {
    return &Subject{
        observers: make([]Observer, 0),
    }
}

func (s *Subject) Attach(o Observer) {
    s.observers = append(s.observers, o)
}

func (s *Subject) notify() {
    for _, o := range s.observers {
        o.Update(s)
    }
}

func (s *Subject) UpdateContext(context string) {
    s.context = context
    s.notify()
}

type Observer interface {
    Update(*Subject)
}

type Reader struct {
    name string
}

func NewReader(name string) *Reader {
    return &Reader{
        name: name,
    }
}

func (r *Reader) Update(s *Subject) {
    fmt.Printf("%s receive %s\n", r.name, s.context)
}
```

obserser_test.go

```go
package observer

func ExampleObserver() {
    subject := NewSubject()
    reader1 := NewReader("reader1")
    reader2 := NewReader("reader2")
    reader3 := NewReader("reader3")
    subject.Attach(reader1)
    subject.Attach(reader2)
    subject.Attach(reader3)

    subject.UpdateContext("observer mode")
    // Output:
    // reader1 receive observer mode
    // reader2 receive observer mode
    // reader3 receive observer mode
}
```

### 命令模式

命令模式本质是把某个对象的方法调用封装到对象中，方便传递、存储、调用。

示例中把主板单中的启动(start)方法和重启(reboot)方法封装为命令对象，再传递到主机(box)对象中。于两个按钮进行绑定：

- 第一个机箱(box1)设置按钮1(button1) 为开机按钮2(button2)为重启。
- 第二个机箱(box1)设置按钮2(button2) 为开机按钮1(button1)为重启。

从而得到配置灵活性。

除了配置灵活外，使用命令模式还可以用作：

- 批处理
- 任务队列
- undo, redo

等把具体命令封装到对象中使用的场合



俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”

命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。

**角色**

- **抽象命令角色(Command)：**声明一个接口包含了执行的操作，如图中excute方法
- **具体命令角色(ConcreteCommand)：**定义了接收者对象和命令的绑定、实现【抽象命令角色】定义的执行操作，具体实现是：在接收者调用对应的操作
- **客户端角色(Client)：**创建一个【具体命令角色】，并设置它的接收者
- **调用者角色(Invoker)：**要求命令执行请求，即调用Command.execute方法
- **接收者角色(receiver)：**知道如何执行一个请求相关的操作，真正执行操作的人

![设计模式行为型：命令模式（CommandPattern）](https://pica.zhimg.com/v2-d2f0703304010f280ed54ddbd4f9a20a_1440w.jpg?source=172ae18b)

command.go

```go
package command

import "fmt"

type Command interface {
    Execute()
}

type StartCommand struct {
    mb *MotherBoard
}

func NewStartCommand(mb *MotherBoard) *StartCommand {
    return &StartCommand{
        mb: mb,
    }
}

func (c *StartCommand) Execute() {
    c.mb.Start()
}

type RebootCommand struct {
    mb *MotherBoard
}

func NewRebootCommand(mb *MotherBoard) *RebootCommand {
    return &RebootCommand{
        mb: mb,
    }
}

func (c *RebootCommand) Execute() {
    c.mb.Reboot()
}

type MotherBoard struct{}

func (*MotherBoard) Start() {
    fmt.Print("system starting\n")
}

func (*MotherBoard) Reboot() {
    fmt.Print("system rebooting\n")
}

type Box struct {
    button1 Command
    button2 Command
}

func NewBox(button1, button2 Command) *Box {
    return &Box{
        button1: button1,
        button2: button2,
    }
}

func (b *Box) PressButton1() {
    b.button1.Execute()
}

func (b *Box) PressButton2() {
    b.button2.Execute()
}
```

command_test.go

```go
package command

func ExampleCommand() {
    mb := &MotherBoard{}
    startCommand := NewStartCommand(mb)
    rebootCommand := NewRebootCommand(mb)

    box1 := NewBox(startCommand, rebootCommand)
    box1.PressButton1()
    box1.PressButton2()

    box2 := NewBox(rebootCommand, startCommand)
    box2.PressButton1()
    box2.PressButton2()
    // Output:
    // system starting
    // system rebooting
    // system rebooting
    // system starting
}
```

### 迭代器模式

送代器模式**用于使用相同方式送代不同类型集合或者隐藏集合类型的具体实现**。

可以使用送代器模式使遍历同时应用送代策略，如请求新对象、过滤、处理对象等。



我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”

迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。

迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。

迭代器模式角色组成：

1. **抽象容器角色（Aggregate）**：负责提供创建具体迭代器角色的接口，一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等。
2. **具体容器角色（ConcreteAggregate）**：就是实现抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkedList,Set接口的哈希列表的实现HashSet等。
3. **抽象迭代器角色（Iterator）**：负责定义访问和遍历元素的接口。
4. **具体迭代器角色（ConcreteIterator）**：实现迭代器接口，并要记录遍历中的当前位置。

![迭代器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/202107-23-iterator-pattern.png)

iterator.go

```go
package iterator

import "fmt"

type Aggregate interface {
    Iterator() Iterator
}

type Iterator interface {
    First()
    IsDone() bool
    Next() interface{}
}

type Numbers struct {
    start, end int
}

func NewNumbers(start, end int) *Numbers {
    return &Numbers{
        start: start,
        end:   end,
    }
}

func (n *Numbers) Iterator() Iterator {
    return &NumbersIterator{
        numbers: n,
        next:    n.start,
    }
}

type NumbersIterator struct {
    numbers *Numbers
    next    int
}

func (i *NumbersIterator) First() {
    i.next = i.numbers.start
}

func (i *NumbersIterator) IsDone() bool {
    return i.next > i.numbers.end
}

func (i *NumbersIterator) Next() interface{} {
    if !i.IsDone() {
        next := i.next
        i.next++
        return next
    }
    return nil
}

func IteratorPrint(i Iterator) {
    for i.First(); !i.IsDone(); {
        c := i.Next()
        fmt.Printf("%#v\n", c)
    }
}
```

iterator_test.go

```go
package iterator

func ExampleIterator() {
    var aggregate Aggregate
    aggregate = NewNumbers(1, 10)

    IteratorPrint(aggregate.Iterator())
    // Output:
    // 1
    // 2
    // 3
    // 4
    // 5
    // 6
    // 7
    // 8
    // 9
    // 10
}
```

### 模板方法模式

**模版方法模式使用继承机制，把通用步骤和通用方法放到父类中，把具体实现延迟到子类中实现**。使得实现符合开闭原则。

#### 什么是「模板模式」？

抽象类里定义好**算法的执行步骤**和**具体算法**，以及可能发生变化的算法定义为**抽象方法**。不同的子类继承该抽象类，并实现父类的抽象方法。

模板模式的优势：

- **不变的算法被继承复用：不变的部分高度封装、复用**。
- 变化的算法子类继承并具体实现：变化的部分子类只需要具体实现抽象的部分即可，方便扩展，且可无限扩展。

如实例代码中通用步骤在父类中实现（`准备`、`下载`、`保存`、`收尾`）下载和保存的具体实现留到子类中，并且提供 `保存`方法的默认实现。

因为Golang不提供继承机制，需要使用匿名组合模拟实现继承。

此处需要注意：因为父类需要调用子类方法，所以子类需要匿名组合父类的同时，父类需要持有子类的引用。



看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；

模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。

模板模式包含如下角色：

- 抽象模板（Abstract Template）角色：该角色定义一个或多个抽象操作，以便让子类实现；这些抽象操作是基本操作，是一个顶级逻辑的组成步骤，该角色还需要定义一个或几个模板方法（模板方法的介绍，请看下文）；
- 具体模板（Concrete Template）角色：该角色实现抽象模板中定义的一个或多个抽象方法，每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法的不同实现，从而使得顶级逻辑的实现各不相同。

![UML图](https://brightloong.github.io/images/design-pattern/templateMethod/templateMethod.png)

templatemethod.go

```go
package templatemethod

import "fmt"

type Downloader interface {
    Download(uri string)
}

type template struct {
    implement
    uri string
}

type implement interface {
    download()
    save()
}

func newTemplate(impl implement) *template {
    return &template{
        implement: impl,
    }
}

func (t *template) Download(uri string) {
    t.uri = uri
    fmt.Print("prepare downloading\n")
    t.implement.download()
    t.implement.save()
    fmt.Print("finish downloading\n")
}

func (t *template) save() {
    fmt.Print("default save\n")
}

type HTTPDownloader struct {
    *template
}

func NewHTTPDownloader() Downloader {
    downloader := &HTTPDownloader{}
    template := newTemplate(downloader)
    downloader.template = template
    return downloader
}

func (d *HTTPDownloader) download() {
    fmt.Printf("download %s via http\n", d.uri)
}

func (*HTTPDownloader) save() {
    fmt.Printf("http save\n")
}

type FTPDownloader struct {
    *template
}

func NewFTPDownloader() Downloader {
    downloader := &FTPDownloader{}
    template := newTemplate(downloader)
    downloader.template = template
    return downloader
}

func (d *FTPDownloader) download() {
    fmt.Printf("download %s via ftp\n", d.uri)
}
```

templatemethod_test.go

```go
package templatemethod

func ExampleHTTPDownloader() {
    var downloader Downloader = NewHTTPDownloader()

    downloader.Download("http://example.com/abc.zip")
    // Output:
    // prepare downloading
    // download http://example.com/abc.zip via http
    // http save
    // finish downloading
}

func ExampleFTPDownloader() {
    var downloader Downloader = NewFTPDownloader()

    downloader.Download("ftp://example.com/abc.zip")
    // Output:
    // prepare downloading
    // download ftp://example.com/abc.zip via ftp
    // default save
    // finish downloading
}
```

#### 实战

[参考](https://segmentfault.com/a/1190000022341645?utm_source=sf-similar-article)

### 策略模式

#### 什么是「策略模式」？

「策略模式」比较简单，大家平常工作中应该经常使用到，所以本文作为复习，帮助大家温故知新。我们先来看下定义：

> 不同的算法按照统一的标准封装，客户端根据不同的场景，决策使用何种算法。

上面的概念的关键词：

- 算法：就是行为
- 标准：就是interface
- 客户端：客户端是相对的，谁调用谁就是客户端
- 场景：判断条件
- 决策：判断的过程

概念很容易理解，不多说。

「策略模式」的优势：

- 典型的高内聚：算法和算法之间完全独立、互不干扰
- 典型的松耦合：客户端依赖的是接口的抽象方法
- 沉淀：每一个封装好的算法都是这个技术团队的财富，且未来可以被轻易的修改、复用

定义一系列算法，让这些算法在运行时可以互换，使得分离算法，符合开闭原则。

策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。

策略模式是一种对象行为型模式。



跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。

策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。

**策略模式**主要由这三个角色组成，环境角色(Context)、抽象策略角色(Strategy)和具体策略角色(ConcreteStrategy)。

- 环境角色(Context)：持有一个策略类的引用，提供给客户端使用。
- 抽象策略角色(Strategy)：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
- 具体策略角色(ConcreteStrategy)：包装了相关的算法或行为。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181111152930787.png)

strategy.go

```go
package strategy

import "fmt"

type Payment struct {
    context  *PaymentContext
    strategy PaymentStrategy
}

type PaymentContext struct {
    Name, CardID string
    Money        int
}

func NewPayment(name, cardid string, money int, strategy PaymentStrategy) *Payment {
    return &Payment{
        context: &PaymentContext{
            Name:   name,
            CardID: cardid,
            Money:  money,
        },
        strategy: strategy,
    }
}

func (p *Payment) Pay() {
    p.strategy.Pay(p.context)
}

type PaymentStrategy interface {
    Pay(*PaymentContext)
}

type Cash struct{}

func (*Cash) Pay(ctx *PaymentContext) {
    fmt.Printf("Pay $%d to %s by cash", ctx.Money, ctx.Name)
}

type Bank struct{}

func (*Bank) Pay(ctx *PaymentContext) {
    fmt.Printf("Pay $%d to %s by bank account %s", ctx.Money, ctx.Name, ctx.CardID)

}
```

strategy_test.go

```go
package strategy

func ExamplePayByCash() {
    payment := NewPayment("Ada", "", 123, &Cash{})
    payment.Pay()
    // Output:
    // Pay $123 to Ada by cash
}

func ExamplePayByBank() {
    payment := NewPayment("Bob", "0002", 888, &Bank{})
    payment.Pay()
    // Output:
    // Pay $888 to Bob by bank account 0002
}
```

#### 实战

[参考](https://github.com/TIGERB/easy-tips/tree/master/go/patterns/strategy)

### 状态模式

#### 什么是「状态模式」？

> 不同的算法按照统一的标准封装，根据不同的**内部状态**，决策使用何种算法

##### 「状态模式」和「策略模式」的区别

- 策略模式：依靠客户决策
- 状态模式：依靠内部状态决策

**状态模式用于分离状态和行为**。

状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。



跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。

状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。

状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。

状态模式包含以下主要角色：

- 环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。
- 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。
- 具体状态（Concrete  State）角色：实现抽象状态所对应的行为。

![image](https://zy123a.github.io/zy-blog/images/mode/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png)

state.go

```go
package state

import "fmt"

type Week interface {
    Today()
    Next(*DayContext)
}

type DayContext struct {
    today Week
}

func NewDayContext() *DayContext {
    return &DayContext{
        today: &Sunday{},
    }
}

func (d *DayContext) Today() {
    d.today.Today()
}

func (d *DayContext) Next() {
    d.today.Next(d)
}

type Sunday struct{}

func (*Sunday) Today() {
    fmt.Printf("Sunday\n")
}

func (*Sunday) Next(ctx *DayContext) {
    ctx.today = &Monday{}
}

type Monday struct{}

func (*Monday) Today() {
    fmt.Printf("Monday\n")
}

func (*Monday) Next(ctx *DayContext) {
    ctx.today = &Tuesday{}
}

type Tuesday struct{}

func (*Tuesday) Today() {
    fmt.Printf("Tuesday\n")
}

func (*Tuesday) Next(ctx *DayContext) {
    ctx.today = &Wednesday{}
}

type Wednesday struct{}

func (*Wednesday) Today() {
    fmt.Printf("Wednesday\n")
}

func (*Wednesday) Next(ctx *DayContext) {
    ctx.today = &Thursday{}
}

type Thursday struct{}

func (*Thursday) Today() {
    fmt.Printf("Thursday\n")
}

func (*Thursday) Next(ctx *DayContext) {
    ctx.today = &Friday{}
}

type Friday struct{}

func (*Friday) Today() {
    fmt.Printf("Friday\n")
}

func (*Friday) Next(ctx *DayContext) {
    ctx.today = &Saturday{}
}

type Saturday struct{}

func (*Saturday) Today() {
    fmt.Printf("Saturday\n")
}

func (*Saturday) Next(ctx *DayContext) {
    ctx.today = &Sunday{}
}
```

state_test.go

```go
package state

func ExampleWeek() {
    ctx := NewDayContext()
    todayAndNext := func() {
        ctx.Today()
        ctx.Next()
    }

    for i := 0; i < 8; i++ {
        todayAndNext()
    }
    // Output:
    // Sunday
    // Monday
    // Tuesday
    // Wednesday
    // Thursday
    // Friday
    // Saturday
    // Sunday
}
```

#### 实战

[参考](https://github.com/TIGERB/easy-tips/tree/master/go/patterns/state)

### 备忘录模式

备忘录模式**用于保存程序内部状态到外部，又不希望暴露内部状态的情形**。

程序内部状态使用窄接口船体给外部进行存储，从而不暴露程序实现细节。

备忘录模式同时可以离线保存内部状态，如保存到数据库，文件等。



同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。

备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。

#### 备忘录模式角色介绍

- 发起人角色：Originator，它是一个普通业务类，当需要保存内部状态时被设计为发起人，负责定义状态的备份范围、创建和恢复备忘录数据。
- 备忘录角色：Memento，负责存储发起人对象的内部状态，在需要的时候提供发起人需要的内部状态；一般备忘录类内部属性与发起人类
- 备忘录管理员角色：Caretaker，负责管理、保存和提供备忘录，但是不能对备忘录的内容进行操作或检查。可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。

![img](https://img-blog.csdn.net/20160909151034775)

memento.go

```go
package memento

import "fmt"

type Memento interface{}

type Game struct {
    hp, mp int
}

type gameMemento struct {
    hp, mp int
}

func (g *Game) Play(mpDelta, hpDelta int) {
    g.mp += mpDelta
    g.hp += hpDelta
}

func (g *Game) Save() Memento {
    return &gameMemento{
        hp: g.hp,
        mp: g.mp,
    }
}

func (g *Game) Load(m Memento) {
    gm := m.(*gameMemento)
    g.mp = gm.mp
    g.hp = gm.hp
}

func (g *Game) Status() {
    fmt.Printf("Current HP:%d, MP:%d\n", g.hp, g.mp)
}
```

memento_test.go

```go
package memento

func ExampleGame() {
    game := &Game{
        hp: 10,
        mp: 10,
    }

    game.Status()
    progress := game.Save()

    game.Play(-2, -3)
    game.Status()

    game.Load(progress)
    game.Status()

    // Output:
    // Current HP:10, MP:10
    // Current HP:7, MP:8
    // Current HP:10, MP:10
}
```

### 解释器模式

解释器模式定义一套语言文法，并设计该语言解释器，使用户能使用特定文法控制解释器行为。

解释器模式的意义在于，它分离多种复杂功能的实现，每个功能只需关注自身的解释。

对于调用者不用关心内部的解释器的工作，只需要用简单的方式组合命令就可以。



俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。

解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。

在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。

一般情况下解释器模式包含以下几种角色

- 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。
- 终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。
- 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。
- 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。
- 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。、

![img](http://congspark.com/images/interpreter-fresher/pic01.png)

interpreter.go

```go
package interpreter

import (
    "strconv"
    "strings"
)

type Node interface {
    Interpret() int
}

type ValNode struct {
    val int
}

func (n *ValNode) Interpret() int {
    return n.val
}

type AddNode struct {
    left, right Node
}

func (n *AddNode) Interpret() int {
    return n.left.Interpret() + n.right.Interpret()
}

type MinNode struct {
    left, right Node
}

func (n *MinNode) Interpret() int {
    return n.left.Interpret() - n.right.Interpret()
}

type Parser struct {
    exp   []string
    index int
    prev  Node
}

func (p *Parser) Parse(exp string) {
    p.exp = strings.Split(exp, " ")

    for {
        if p.index >= len(p.exp) {
            return
        }
        switch p.exp[p.index] {
        case "+":
            p.prev = p.newAddNode()
        case "-":
            p.prev = p.newMinNode()
        default:
            p.prev = p.newValNode()
        }
    }
}

func (p *Parser) newAddNode() Node {
    p.index++
    return &AddNode{
        left:  p.prev,
        right: p.newValNode(),
    }
}

func (p *Parser) newMinNode() Node {
    p.index++
    return &MinNode{
        left:  p.prev,
        right: p.newValNode(),
    }
}

func (p *Parser) newValNode() Node {
    v, _ := strconv.Atoi(p.exp[p.index])
    p.index++
    return &ValNode{
        val: v,
    }
}

func (p *Parser) Result() Node {
    return p.prev
}
```

interpreter_test.go

```go
package interpreter

import "testing"

func TestInterpreter(t *testing.T) {
    p := &Parser{}
    p.Parse("1 + 2 + 3 - 4 + 5 - 6")
    res := p.Result().Interpret()
    expect := 1
    if res != expect {
        t.Fatalf("expect %d got %d", expect, res)
    }
}
```

### 职责链模式

#### 原理

职责链模式用于分离不同职责，并且动态组合相关职责。

Golang实现职责链模式时候，因为没有继承的支持，使用链对象包涵职责的方式，即：

- 链对象包含当前职责对象以及下一个职责链。
- 职责对象提供接口表示是否能处理对应请求。
- 职责对象提供处理函数处理相关职责。

同时可在职责链类中实现职责接口相关函数，使职责链对象可以当做一般职责对象是用。



晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！

责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。

职责链模式主要包含以下角色。

1. 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
2. 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
3. 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c20cda8da614029811f7a975d7ad826~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

chain.go

```go
package chain

import "fmt"

type Manager interface {
    HaveRight(money int) bool
    HandleFeeRequest(name string, money int) bool
}

type RequestChain struct {
    Manager
    successor *RequestChain
}

func (r *RequestChain) SetSuccessor(m *RequestChain) {
    r.successor = m
}

func (r *RequestChain) HandleFeeRequest(name string, money int) bool {
    if r.Manager.HaveRight(money) {
        return r.Manager.HandleFeeRequest(name, money)
    }
    if r.successor != nil {
        return r.successor.HandleFeeRequest(name, money)
    }
    return false
}

func (r *RequestChain) HaveRight(money int) bool {
    return true
}

type ProjectManager struct{}

func NewProjectManagerChain() *RequestChain {
    return &RequestChain{
        Manager: &ProjectManager{},
    }
}

func (*ProjectManager) HaveRight(money int) bool {
    return money < 500
}

func (*ProjectManager) HandleFeeRequest(name string, money int) bool {
    if name == "bob" {
        fmt.Printf("Project manager permit %s %d fee request\n", name, money)
        return true
    }
    fmt.Printf("Project manager don't permit %s %d fee request\n", name, money)
    return false
}

type DepManager struct{}

func NewDepManagerChain() *RequestChain {
    return &RequestChain{
        Manager: &DepManager{},
    }
}

func (*DepManager) HaveRight(money int) bool {
    return money < 5000
}

func (*DepManager) HandleFeeRequest(name string, money int) bool {
    if name == "tom" {
        fmt.Printf("Dep manager permit %s %d fee request\n", name, money)
        return true
    }
    fmt.Printf("Dep manager don't permit %s %d fee request\n", name, money)
    return false
}

type GeneralManager struct{}

func NewGeneralManagerChain() *RequestChain {
    return &RequestChain{
        Manager: &GeneralManager{},
    }
}

func (*GeneralManager) HaveRight(money int) bool {
    return true
}

func (*GeneralManager) HandleFeeRequest(name string, money int) bool {
    if name == "ada" {
        fmt.Printf("General manager permit %s %d fee request\n", name, money)
        return true
    }
    fmt.Printf("General manager don't permit %s %d fee request\n", name, money)
    return false
}
```

chain_test.go

```go
package chain

func ExampleChain() {
    c1 := NewProjectManagerChain()
    c2 := NewDepManagerChain()
    c3 := NewGeneralManagerChain()

    c1.SetSuccessor(c2)
    c2.SetSuccessor(c3)

    var c Manager = c1

    c.HandleFeeRequest("bob", 400)
    c.HandleFeeRequest("tom", 1400)
    c.HandleFeeRequest("ada", 10000)
    c.HandleFeeRequest("floar", 400)
    // Output:
    // Project manager permit bob 400 fee request
    // Dep manager permit tom 1400 fee request
    // General manager permit ada 10000 fee request
    // Project manager don't permit floar 400 fee request

}
```

#### 实战

[参考](https://segmentfault.com/a/1190000022341664###)

### 访问者模式

访问者模式可以给一系列对象透明的添加功能，并且把相关代码封装到一个类中。

对象只要预留访问者接口`Accept`则后期为对象添加功能的时候就不需要改动对象。



情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；

访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。

访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。

访问者模式包含以下主要角色:

- 抽象访问者（Visitor）角色：定义了对每一个元素`（Element）`访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。
- 具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。
- 抽象元素（Element）角色：定义了一个接受访问者的方法（`accept`），其意义是指，每一个元素都要可以被访问者访问。
- 具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。
- 对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（`Element`），并且可以迭代这些元素，供访问者访问。

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Visitor_UML_class_diagram.svg/1024px-Visitor_UML_class_diagram.svg.png" alt="img" style="zoom: 67%;" />

visitor.go

```go
package visitor

import "fmt"

type Customer interface {
    Accept(Visitor)
}

type Visitor interface {
    Visit(Customer)
}

type EnterpriseCustomer struct {
    name string
}

type CustomerCol struct {
    customers []Customer
}

func (c *CustomerCol) Add(customer Customer) {
    c.customers = append(c.customers, customer)
}

func (c *CustomerCol) Accept(visitor Visitor) {
    for _, customer := range c.customers {
        customer.Accept(visitor)
    }
}

func NewEnterpriseCustomer(name string) *EnterpriseCustomer {
    return &EnterpriseCustomer{
        name: name,
    }
}

func (c *EnterpriseCustomer) Accept(visitor Visitor) {
    visitor.Visit(c)
}

type IndividualCustomer struct {
    name string
}

func NewIndividualCustomer(name string) *IndividualCustomer {
    return &IndividualCustomer{
        name: name,
    }
}

func (c *IndividualCustomer) Accept(visitor Visitor) {
    visitor.Visit(c)
}

type ServiceRequestVisitor struct{}

func (*ServiceRequestVisitor) Visit(customer Customer) {
    switch c := customer.(type) {
    case *EnterpriseCustomer:
        fmt.Printf("serving enterprise customer %s\n", c.name)
    case *IndividualCustomer:
        fmt.Printf("serving individual customer %s\n", c.name)
    }
}

// only for enterprise
type AnalysisVisitor struct{}

func (*AnalysisVisitor) Visit(customer Customer) {
    switch c := customer.(type) {
    case *EnterpriseCustomer:
        fmt.Printf("analysis enterprise customer %s\n", c.name)
    }
}
```

visitor_test.go

```go
package visitor

func ExampleRequestVisitor() {
    c := &CustomerCol{}
    c.Add(NewEnterpriseCustomer("A company"))
    c.Add(NewEnterpriseCustomer("B company"))
    c.Add(NewIndividualCustomer("bob"))
    c.Accept(&ServiceRequestVisitor{})
    // Output:
    // serving enterprise customer A company
    // serving enterprise customer B company
    // serving individual customer bob
}

func ExampleAnalysis() {
    c := &CustomerCol{}
    c.Add(NewEnterpriseCustomer("A company"))
    c.Add(NewIndividualCustomer("bob"))
    c.Add(NewEnterpriseCustomer("B company"))
    c.Accept(&AnalysisVisitor{})
    // Output:
    // analysis enterprise customer A company
    // analysis enterprise customer B company
}
```

## 相关问题

