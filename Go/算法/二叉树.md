# 二叉树

## 二叉树遍历

**前序遍历**：**先访问根节点**，再前序遍历左子树，再前序遍历右子树。 (**根左右**)

**中序遍历**：先中序遍历左子树，**再访问根节点**，再中序遍历右子树 。(**左根右**)

**后序遍历**：先后序遍历左子树，再后序遍历右子树，**再访问根节点。**(**左右根**)

**递归遍历**

注意点

- 以根访问顺序决定是什么遍历
- 左子树都是优先右子树

```go
func preorderTraversal(root *TreeNode)  {
    if root==nil{
        return
    }
    // 1.
    fmt.Println(root.Val) // 先访问根再访问左右 前序遍历
    preorderTraversal(root.Left)
    // 2.
    // fmt.Println(root.Val) // 中序遍历
    preorderTraversal(root.Right)
    // 2.
    // fmt.Println(root.Val) // 后序遍历    
}
```

### 前序遍历

**递归遍历**

```
func preorderTraversal(root *TreeNode)  {
    if root==nil{
        return
    }
    fmt.Println(root.Val) 
    preorderTraversal(root.Left)
    preorderTraversal(root.Right)
}
```

**非递归遍历**

```go
// V3：通过非递归遍历
func preorderTraversal(root *TreeNode) []int {
    // 非递归
    if root == nil{
        return nil
    }
    result:=make([]int,0)
    stack:=make([]*TreeNode,0)

    for root!=nil || len(stack)!=0{
        for root !=nil{
            // 前序遍历，所以先保存结果
            result=append(result, root.Val)
            stack=append(stack, root)
            root=root.Left
        }
        // pop
        node:=stack[len(stack)-1]
        stack=stack[:len(stack)-1]
        root=node.Right
    }
    return result
}
```

![Tree Traversal | zhendecai](https://raw.githubusercontent.com/jiutiananshu/Picture/master/img/pre-order.png)

```go
// 第二种前序非递归
func preorderTraversal(root *TreeNode) []int {
    // 非递归
    if root == nil{
        return nil
    }
    result:=make([]int,0)
    stack:= []*TreeNode{root}
    for len(stack) != 0{
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        if node != nil{
            result= append(result, node.Val)
            stack = append(stack, node.Right)
            stack = append(stack, node.Left)
        } 
    }
    return result
}
```

<img src="https://raw.githubusercontent.com/jiutiananshu/Picture/master/img/20200804093407910.jpg" alt="image" style="zoom: 50%;" />

### 中序遍历

**递归遍历**

```
func inorderTraversal(root *TreeNode)  {
    if root==nil{
        return
    } 
    preorderTraversal(root.Left)
    fmt.Println(root.Val)
    preorderTraversal(root.Right)
}
```

**非递归遍历**

```go
// 思路：通过stack 保存已经访问的元素，用于原路返回
func inorderTraversal(root *TreeNode) []int {
    result := make([]int, 0)
    if root == nil {
        return result
    }
    stack := make([]*TreeNode, 0)
    for len(stack) > 0 || root != nil {
        for root != nil {
            stack = append(stack, root)
            root = root.Left // 一直向左
        }
        // 弹出
        val := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, val.Val)
        root = val.Right
    }
    return result
}
```



### 后序遍历



### 层序遍历



## 构建二叉树



## 二叉搜索树

二叉搜索树是一种二叉树的树形数据结构，其定义如下：

1. 空树是二叉搜索树。
2. 若二叉搜索树的左子树不为空，则其左子树上所有点的附加权值均小于其根节点的值。
3. 若二叉搜索树的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值。
4. 二叉搜索树的左右子树均为二叉搜索树。

二叉搜索树上的基本操作所花费的时间与这棵树的高度成正比。对于一个有 个结点的二叉搜索树中，这些操作的最优时间复杂度为 ，最坏为 。随机构造这样一棵二叉搜索树的期望高度为 。

## 平衡二叉树

**平衡二叉查找树**：简称平衡二叉树。由前苏联的数学家 **A**delse-**V**elskil 和 **L**andis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。它具有如下几个性质：

1. 可以是空树。
2. 假如不是空树，**任何一个结点的左子树与右子树都是平衡二叉树**，并且**高度之差的绝对值不超过 1**。



## 题目

[前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal)

[中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal)

[ 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list)

[根据二叉树创建字符串](https://leetcode-cn.com/problems/construct-string-from-binary-tree)

[树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof)

[二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof)

[对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof)

[从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof)

[二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree)

[不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)（多少种二叉搜索树）

[上下翻转二叉树](https://leetcode-cn.com/problems/binary-tree-upside-down/)

