# 位运算

在计算机系统中，数值一律用 **补码** 来表示和存储。**补码的优势：** 加法、减法可以统一处理（CPU只有加法器）。因此，以上方法 **同时适用于正数和负数的加法** 。

## 一：表示法：

### 1、正数5的表示法

假设有一个 int 类型的数，值为5，那么，我们知道它在计算机中表示为：

00000000 00000000 00000000 00000101

5转换成二制是101，不过int类型的数占用4字节（32位。32位机器上为32，64位机器上为64），所以前面填了一堆0。

### 2、负数-5的表示法

现在想知道，-5在计算机中如何表示？在计算机中，负数以原码的补码形式表达。

## 二、概念：

### 1、原码：

**一个正数，按照绝对值大小转换成的二进制数；一个负数按照绝对值大小转换成的二进制数，然后最高位补1，称为原码。**
比如 

00000000 00000000 00000000 00000101 是 5的 原码。

10000000 00000000 00000000 00000101 是 -5的 原码。

  备注：

 比如byte类型,用2^8来表示无符号整数的话,是0 - 255了；如果有符号， 最高位表示符号,0为正,1为负,那么,正常的理解就是 -127 至 +127 了.这就是原码了,值得一提的是,原码的弱点,有2个0,即+0和-0（10000000和00000000）；还有就是,进行异号相加或同号相减时,比较笨蛋,先要判断2个数的绝对值大小,然后进行加减操作,最后运算结果的符号还要与大的符号相同；于是,反码产生了。

#### 2、反码

**正数的反码与原码相同**，**负数的反码为对该数的原码除符号位外各位取反[每一位取反(除符号位)]**。

取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）

比如：

正数00000000 00000000 00000000 00000101 的反码还是 00000000 00000000 00000000 00000101

负数10000000 00000000 00000000 00000101 的反码则是 11111111 11111111 11111111 11111010。

反码是相互的，所以也可称：10000000 00000000 00000000 00000101 和 11111111 11111111 11111111 11111010互为反码。

备注：还是有+0和-0,没过多久，反码就成为了过滤产物,也就是,后来补码出现了。

#### 3、补码

**正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1.**

比如：10000000 00000000 00000000 00000101 的补码是：11111111 11111111 11111111 11111010。
那么，补码为：

11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011

备注：1、从补码求原码的方法跟原码求补码是一样的 ，也可以通过完全逆运算来做，先减一，再取反。

 2、**补码却规定0没有正负之分**

所以，-5 在计算机中表达为：11111111 11111111 11111111 11111011。转换为十六进制：0xFFFFFFFB。

## 四、主要知识点

- 正数的反码和补码都与原码**相同**。
- 负数的反码为对该数的原码**除符号位外各位取反**。
- **负数**的补码为对该数的原码**除符号位外各位取反，然后在最后一位加1**

- 源码：优点在于换算简单 缺点在于两个零 加减法需要独立运算
- 反码：有点在于表示清晰 缺点在于两个零 加减法同样需要独立运算
- 补码：优点在于一个零 范围大 减法可以转为加法 缺点在于理解困难

下面是书上原文：

- 原码表示法规定：**用符号位和数值表示带符号数，正数的符号位用“0”表示，负数的符号位用“1”表示**，数值部分用二进制形式表示。
- 反码表示法规定：正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反。
- 补码表示法规定：正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1.
- **正零和负零的补码相同**，[+0]补=[-0]补=0000 0000B



## 五、特殊情况-128

1000 0000,那么,它的原码是什么呢?从补码求原码的方法跟原码求补码是一样的。先保留符号位其它求反: 1111 1111, 再加1，11000 0000, 超过了8位了。对,用8位数的原码在这里已经无法表示了。

那么,回到原码处, 它的原码也是 1000 0000(超出的自动丢失),1000 0000 在原码表示什么呢? -0, 但补码却规定0没有正负之分。

转换一下思路,看看计算机里,是怎么运算的:

对于负数,先取绝对值,然后求反,加一

-128 -> 128 -> 1000 0000 -> 0111 1111 -> 1000 0000

现在明确了吧

所以, 8位有符号的整数取值范围的补码表示

1000 0000 到 0000 0000, 再到 0111 1111

即 -128 到 0, 再到 127

最终 -128 ~ +127

永远记住：程序里的加减法对 二进制是永远有效的。但是并不一定适合于真实世界。

byte m = -128;

byte q = 1;

byte p = (byte)(m - q); //这一步其实编译器会报错，其实是发现越界了，我们强行转化为byte就可以看出结果。

System.out.println( p); p的结果为：127

## 6. 补码（二进制转十进制）

> 表示正数的补码可以直接转成十进制，表示负数的补码想要转回十进制步骤如下：
>
> - 对表示负数的补码取反码加一得到负数的十进制绝对值补码；
> - 再将负数的十进制绝对值补码转成十进制得到负数的十进制绝对值；
> - 最后加上符号位；

## 补码相加

> 无论是正数加正数（十进制加法）还是正数/负数加负数（十进制减法）都可以用补码加补码表示

**正数加正数的补码计算过程示例：**

| 表达式 |                               补码相加 | 二进制结果 | 十进制结果 |
| :----: | -------------------------------------: | :--------: | :--------: |
|  0+0   | 0000 0000 + 0000 0000 —————— 0000 0000 | 0000 0000  |     0      |
|  0+1   | 0000 0000 + 0000 0001 —————— 0000 0001 | 0000 0001  |     1      |
|  1+1   | 0000 0001 + 0000 0001 —————— 0000 0010 | 0000 0010  |     2      |
|  2+1   | 0000 0010 + 0000 0001 —————— 0000 0011 | 0000 0011  |     3      |

**正数加负数的补码计算过程示例：**

| 表达式 |                                 补码相加 | 二进制结果 | 十进制结果 |
| :----: | ---------------------------------------: | :--------: | :--------: |
| 0+(-0) |   0000 0000 + 0000 0000 —————— 0000 0000 | 0000 0000  |     0      |
| 0+(-1) |   0000 0000 + 1111 1111 —————— 1111 1111 | 1111 1111  |     -1     |
| 1+(-1) | 0000 0001 + 1111 1111 —————— 1,0000 0000 | 0000 0000  |     0      |
| 1+(-2) |   0000 0001 + 1111 1110 —————— 1111 1111 | 1111 1111  |     -1     |
| 2+(-2) | 0000 0010 + 1111 1110 —————— 1,0000 0000 | 0000 0000  |     0      |
| 2+(-1) | 0000 0010 + 1111 1111 —————— 1,0000 0001 | 0000 0001  |     1      |

**负数加负数的补码计算过程示例：**

|  表达式   |                                 补码相加 | 二进制结果 | 十进制结果 |
| :-------: | ---------------------------------------: | :--------: | :--------: |
| (-0)+(-0) |   0000 0000 + 0000 0000 —————— 0000 0000 | 0000 0000  |     0      |
| (-1)+(-1) | 1111 1111 + 1111 1111 —————— 1,1111 1110 | 1111 1110  |     -2     |
| (-1)+(-2) | 1111 1111 + 1111 1110 —————— 1,1111,1101 | 1111 1101  |     -3     |

## 二进制、反码、补码

**同样的一串二进制数字，即可以是反码也可以是补码，如果是补码则其可以通过上述规则转成对应的十进制数值，如果是反码则代表其为计算过程中间值，如果想知道反码在十进制中所表示的数值，可以将其视为补码再通过上述规则转成十进制即可。**

**正数示例：**

| 十进制数值 x | x 取补码 fn1(x)=a | x 取反码 fn2(x)=b | b 的十进制形式 y |
| :----------: | :---------------: | :---------------: | :--------------: |
|      0       |     0000 0000     |     1111 1111     |        -1        |
|      1       |     0000 0001     |     1111 1110     |        -2        |
|      2       |     0000 0010     |     1111 1101     |        -3        |
|      3       |     0000 0011     |     1111 1100     |        -4        |
|      4       |     0000 0100     |     1111 1011     |        -5        |

**负数示例：**

| 十进制数值 x | x 取补码 fn1(x)=a | x 取反码 fn2(x)=b | b 的十进制形式 y |
| :----------: | :---------------: | :---------------: | :--------------: |
|      -0      |     0000 0000     |     1111 1111     |        -1        |
|      -1      |     1111 1111     |     0000 0000     |        0         |
|      -2      |     1111 1110     |     0000 0001     |        1         |
|      -3      |     1111 1101     |     0000 0010     |        2         |

**示例汇总：**

| 十进制数值 x | x 取补码 fn1(x)=a | x 取反码 fn2(x)=b | b 的十进制形式 y | y + 1 | 十进制数值 x |
| :----------: | :---------------: | :---------------: | :--------------: | :---: | :----------: |
|      0       |     0000 0000     |     1111 1111     |        -1        |   0   |      0       |
|      1       |     0000 0001     |     1111 1110     |        -2        |  -1   |      1       |
|      2       |     0000 0010     |     1111 1101     |        -3        |  -2   |      2       |
|      3       |     0000 0011     |     1111 1100     |        -4        |  -3   |      3       |
|      -0      |     0000 0000     |     1111 1111     |        -1        |   0   |      -0      |
|      -1      |     1111 1111     |     0000 0000     |        0         |   1   |      -1      |
|      -2      |     1111 1110     |     0000 0001     |        1         |   2   |      -2      |
|      -3      |     1111 1101     |     0000 0010     |        2         |   3   |      -3      |

通过该表格示例可以得出以下两个规律：

### 规律 一

反码所表示的数值与原数值之间规律如下（**y 代表反码之后的十进制值**）：

- **fn2(x) = -x-1**
- **fn2(x) + 1 = -x**
- **y = -x-1**
- **y +1 = -x**

即如果想得到一个十进制正数值的负数形式（1 => -1）或则得到一个十进制负数值的正数形式可以通过对原值取反码加一得到：

| 十进制数值 x | 十进制取反 -x | 过程               |
| ------------ | ------------- | ------------------ |
| 0            | 0             | 取反码(0)+1 = -1+1 |
| 1            | -1            | 取反码(1)+1 = -2+1 |
| 2            | -2            | 取反码(2)+1 = -3+1 |
| 3            | -3            | 取反码(3)+1 = -4+1 |
| -1           | 1             | 取反码(-1)+1 = 0+1 |
| -2           | 2             | 取反码(-2)+1 = 1+1 |
| -3           | 3             | 取反码(-3)+1 = 2+1 |

### 规律 二

将示例汇总表格再进一步简化：

| 十进制数值 x | x 的反码十进制表示形式 y | 翻译 -1        | 翻译 -2         |
| :----------: | :----------------------: | -------------- | --------------- |
|      0       |            -1            | 0 的反码是 -1  | -1 是 0 的反码  |
|      1       |            -2            | 1 的反码是 -2  | -2 是 1 的反码  |
|      2       |            -3            | 2 的反码是 -3  | -3 是 2 的反码  |
|      3       |            -4            | 3 的反码是 -4  | -4 是 3 的反码  |
|      -0      |            -1            | -0 的反码是 -1 | -1 是 -0 的反码 |
|      -1      |            0             | -1 的反码是 0  | 0 是 -1 的反码  |
|      -2      |            1             | -2 的反码是 1  | 1 是 -2 的反码  |
|      -3      |            2             | -3 的反码是 2  | 2 是 -3 的反码  |

可以看出在十进制格式下，原数值与反码的关系：

- 如果我需要 -1 我可以用 0 的反码代替；
- 如果我需要 -4 我可以用 3 的反码代替；
- 规律：
  - **x = |y| -1**
  - **x + y = -1**