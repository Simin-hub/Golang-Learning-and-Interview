# 位运算

在计算机系统中，数值一律用 **补码** 来表示和存储。**补码的优势：** 加法、减法可以统一处理（CPU只有加法器）。因此，以上方法 **同时适用于正数和负数的加法** 。

## 一：表示法：

### 1、正数5的表示法

假设有一个 int 类型的数，值为5，那么，我们知道它在计算机中表示为：

00000000 00000000 00000000 00000101

5转换成二制是101，不过int类型的数占用4字节（32位。32位机器上为32，64位机器上为64），所以前面填了一堆0。

### 2、负数-5的表示法

现在想知道，-5在计算机中如何表示？在计算机中，负数以原码的补码形式表达。

## 二、概念：

### 1、原码：

**一个正数，按照绝对值大小转换成的二进制数；一个负数按照绝对值大小转换成的二进制数，然后最高位补1，称为原码。**
比如 

00000000 00000000 00000000 00000101 是 5的 原码。

10000000 00000000 00000000 00000101 是 -5的 原码。

  备注：

 比如byte类型,用2^8来表示无符号整数的话,是0 - 255了；如果有符号， 最高位表示符号,0为正,1为负,那么,正常的理解就是 -127 至 +127 了.这就是原码了,值得一提的是,原码的弱点,有2个0,即+0和-0（10000000和00000000）；还有就是,进行异号相加或同号相减时,比较笨蛋,先要判断2个数的绝对值大小,然后进行加减操作,最后运算结果的符号还要与大的符号相同；于是,反码产生了。

#### 2、反码

**正数的反码与原码相同**，**负数的反码为对该数的原码除符号位外各位取反[每一位取反(除符号位)]**。

取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）

比如：

正数00000000 00000000 00000000 00000101 的反码还是 00000000 00000000 00000000 00000101

负数10000000 00000000 00000000 00000101 的反码则是 11111111 11111111 11111111 11111010。

反码是相互的，所以也可称：10000000 00000000 00000000 00000101 和 11111111 11111111 11111111 11111010互为反码。

备注：还是有+0和-0,没过多久，反码就成为了过滤产物,也就是,后来补码出现了。

#### 3、补码

**正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1.**

比如：10000000 00000000 00000000 00000101 的补码是：11111111 11111111 11111111 11111010。
那么，补码为：

11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011

备注：1、从补码求原码的方法跟原码求补码是一样的 ，也可以通过完全逆运算来做，先减一，再取反。

 2、**补码却规定0没有正负之分**

所以，-5 在计算机中表达为：11111111 11111111 11111111 11111011。转换为十六进制：0xFFFFFFFB。

## 四、主要知识点

- 正数的反码和补码都与原码**相同**。
- 负数的反码为对该数的原码**除符号位外各位取反**。
- **负数**的补码为对该数的原码**除符号位外各位取反，然后在最后一位加1**

- 源码：优点在于换算简单 缺点在于两个零 加减法需要独立运算
- 反码：有点在于表示清晰 缺点在于两个零 加减法同样需要独立运算
- 补码：优点在于一个零 范围大 减法可以转为加法 缺点在于理解困难

下面是书上原文：

- 原码表示法规定：**用符号位和数值表示带符号数，正数的符号位用“0”表示，负数的符号位用“1”表示**，数值部分用二进制形式表示。
- 反码表示法规定：正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反。
- 补码表示法规定：正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1.
- **正零和负零的补码相同**，[+0]补=[-0]补=0000 0000B



## 五、特殊情况-128

1000 0000,那么,它的原码是什么呢?从补码求原码的方法跟原码求补码是一样的。先保留符号位其它求反: 1111 1111, 再加1，11000 0000, 超过了8位了。对,用8位数的原码在这里已经无法表示了。

那么,回到原码处, 它的原码也是 1000 0000(超出的自动丢失),1000 0000 在原码表示什么呢? -0, 但补码却规定0没有正负之分。

转换一下思路,看看计算机里,是怎么运算的:

对于负数,先取绝对值,然后求反,加一

-128 -> 128 -> 1000 0000 -> 0111 1111 -> 1000 0000

现在明确了吧

所以, 8位有符号的整数取值范围的补码表示

1000 0000 到 0000 0000, 再到 0111 1111

即 -128 到 0, 再到 127

最终 -128 ~ +127

永远记住：程序里的加减法对 二进制是永远有效的。但是并不一定适合于真实世界。

byte m = -128;

byte q = 1;

byte p = (byte)(m - q); //这一步其实编译器会报错，其实是发现越界了，我们强行转化为byte就可以看出结果。

System.out.println( p); p的结果为：127

## 6. 补码（二进制转十进制）

> 表示正数的补码可以直接转成十进制，表示负数的补码想要转回十进制步骤如下：
>
> - 对表示负数的补码取反码加一得到负数的十进制绝对值补码；
> - 再将负数的十进制绝对值补码转成十进制得到负数的十进制绝对值；
> - 最后加上符号位；

## 补码相加

> 无论是正数加正数（十进制加法）还是正数/负数加负数（十进制减法）都可以用补码加补码表示

**正数加正数的补码计算过程示例：**

| 表达式 |                               补码相加 | 二进制结果 | 十进制结果 |
| :----: | -------------------------------------: | :--------: | :--------: |
|  0+0   | 0000 0000 + 0000 0000 —————— 0000 0000 | 0000 0000  |     0      |
|  0+1   | 0000 0000 + 0000 0001 —————— 0000 0001 | 0000 0001  |     1      |
|  1+1   | 0000 0001 + 0000 0001 —————— 0000 0010 | 0000 0010  |     2      |
|  2+1   | 0000 0010 + 0000 0001 —————— 0000 0011 | 0000 0011  |     3      |

**正数加负数的补码计算过程示例：**

| 表达式 |                                 补码相加 | 二进制结果 | 十进制结果 |
| :----: | ---------------------------------------: | :--------: | :--------: |
| 0+(-0) |   0000 0000 + 0000 0000 —————— 0000 0000 | 0000 0000  |     0      |
| 0+(-1) |   0000 0000 + 1111 1111 —————— 1111 1111 | 1111 1111  |     -1     |
| 1+(-1) | 0000 0001 + 1111 1111 —————— 1,0000 0000 | 0000 0000  |     0      |
| 1+(-2) |   0000 0001 + 1111 1110 —————— 1111 1111 | 1111 1111  |     -1     |
| 2+(-2) | 0000 0010 + 1111 1110 —————— 1,0000 0000 | 0000 0000  |     0      |
| 2+(-1) | 0000 0010 + 1111 1111 —————— 1,0000 0001 | 0000 0001  |     1      |

**负数加负数的补码计算过程示例：**

|  表达式   |                                 补码相加 | 二进制结果 | 十进制结果 |
| :-------: | ---------------------------------------: | :--------: | :--------: |
| (-0)+(-0) |   0000 0000 + 0000 0000 —————— 0000 0000 | 0000 0000  |     0      |
| (-1)+(-1) | 1111 1111 + 1111 1111 —————— 1,1111 1110 | 1111 1110  |     -2     |
| (-1)+(-2) | 1111 1111 + 1111 1110 —————— 1,1111,1101 | 1111 1101  |     -3     |

## 二进制、反码、补码

**同样的一串二进制数字，即可以是反码也可以是补码，如果是补码则其可以通过上述规则转成对应的十进制数值，如果是反码则代表其为计算过程中间值，如果想知道反码在十进制中所表示的数值，可以将其视为补码再通过上述规则转成十进制即可。**

**正数示例：**

| 十进制数值 x | x 取补码 fn1(x)=a | x 取反码 fn2(x)=b | b 的十进制形式 y |
| :----------: | :---------------: | :---------------: | :--------------: |
|      0       |     0000 0000     |     1111 1111     |        -1        |
|      1       |     0000 0001     |     1111 1110     |        -2        |
|      2       |     0000 0010     |     1111 1101     |        -3        |
|      3       |     0000 0011     |     1111 1100     |        -4        |
|      4       |     0000 0100     |     1111 1011     |        -5        |

**负数示例：**

| 十进制数值 x | x 取补码 fn1(x)=a | x 取反码 fn2(x)=b | b 的十进制形式 y |
| :----------: | :---------------: | :---------------: | :--------------: |
|      -0      |     0000 0000     |     1111 1111     |        -1        |
|      -1      |     1111 1111     |     0000 0000     |        0         |
|      -2      |     1111 1110     |     0000 0001     |        1         |
|      -3      |     1111 1101     |     0000 0010     |        2         |

**示例汇总：**

| 十进制数值 x | x 取补码 fn1(x)=a | x 取反码 fn2(x)=b | b 的十进制形式 y | y + 1 | 十进制数值 x |
| :----------: | :---------------: | :---------------: | :--------------: | :---: | :----------: |
|      0       |     0000 0000     |     1111 1111     |        -1        |   0   |      0       |
|      1       |     0000 0001     |     1111 1110     |        -2        |  -1   |      1       |
|      2       |     0000 0010     |     1111 1101     |        -3        |  -2   |      2       |
|      3       |     0000 0011     |     1111 1100     |        -4        |  -3   |      3       |
|      -0      |     0000 0000     |     1111 1111     |        -1        |   0   |      -0      |
|      -1      |     1111 1111     |     0000 0000     |        0         |   1   |      -1      |
|      -2      |     1111 1110     |     0000 0001     |        1         |   2   |      -2      |
|      -3      |     1111 1101     |     0000 0010     |        2         |   3   |      -3      |

通过该表格示例可以得出以下两个规律：

### 规律 一

反码所表示的数值与原数值之间规律如下（**y 代表反码之后的十进制值**）：

- **fn2(x) = -x-1**
- **fn2(x) + 1 = -x**
- **y = -x-1**
- **y +1 = -x**

即如果想得到一个十进制正数值的负数形式（1 => -1）或则得到一个十进制负数值的正数形式可以通过对原值取反码加一得到：

| 十进制数值 x | 十进制取反 -x | 过程               |
| ------------ | ------------- | ------------------ |
| 0            | 0             | 取反码(0)+1 = -1+1 |
| 1            | -1            | 取反码(1)+1 = -2+1 |
| 2            | -2            | 取反码(2)+1 = -3+1 |
| 3            | -3            | 取反码(3)+1 = -4+1 |
| -1           | 1             | 取反码(-1)+1 = 0+1 |
| -2           | 2             | 取反码(-2)+1 = 1+1 |
| -3           | 3             | 取反码(-3)+1 = 2+1 |

### 规律 二

将示例汇总表格再进一步简化：

| 十进制数值 x | x 的反码十进制表示形式 y | 翻译 -1        | 翻译 -2         |
| :----------: | :----------------------: | -------------- | --------------- |
|      0       |            -1            | 0 的反码是 -1  | -1 是 0 的反码  |
|      1       |            -2            | 1 的反码是 -2  | -2 是 1 的反码  |
|      2       |            -3            | 2 的反码是 -3  | -3 是 2 的反码  |
|      3       |            -4            | 3 的反码是 -4  | -4 是 3 的反码  |
|      -0      |            -1            | -0 的反码是 -1 | -1 是 -0 的反码 |
|      -1      |            0             | -1 的反码是 0  | 0 是 -1 的反码  |
|      -2      |            1             | -2 的反码是 1  | 1 是 -2 的反码  |
|      -3      |            2             | -3 的反码是 2  | 2 是 -3 的反码  |

可以看出在十进制格式下，原数值与反码的关系：

- 如果我需要 -1 我可以用 0 的反码代替；
- 如果我需要 -4 我可以用 3 的反码代替；
- 规律：
  - **x = |y| -1**
  - **x + y = -1**

## 位操作

Go 编程语言支持以下按位运算符：

```
&   与运算 	0 & 1 = 0    1 & 1 = 1       0 & 0 = 0
 |   或运算   	0 | 1 = 1    1 | 1 = 1       0 | 0 = 0
 ^   异或运算	0 ^ 1 = 1    1 ^ 1 = 0       0 ^ 0 = 0
&^   与非运算	0 &^ 1 = 0   1 &^ 1 = 0     0 &^ 0 = 0     1 &^ 0 = 1
<<   左移
>>	 右移
```

#### & 运算符

在 Go 中， & 运算符在两个整型操作数中执行按位 AND 操作。AND 操作具有以下属性:

```
Given operands a, b
AND(a, b) = 1; only if a = b = 1
               else = 0
```

AND 运算符具有选择性的把**整型数据的位**清除为 0 的好的效果。 例如，我们可以使用 & 运算符去清除（设置）最后 4 个最低有效位（LSB）全部为 0 。

```
func main() {
    var x uint8 = 0xAC    // x = 10101100
    x = x & 0xF0          // x = 10100000
}
```

所有的位运算都支持简写的赋值形式。 例如，前面的例子可以重写为如下。

```
func main() {
    var x uint8 = 0xAC    // x = 10101100
    x &= 0xF0             // x = 10100000
}
```

另外一个巧妙的技巧是：你可以**用 & 操作去测试一个数字是奇数还是偶数。原因是当一个数字的二进制的最低位是 1 的时候，那他就是奇数**。我们可以用一个数字和 1 进行 & 操作，然后在和 1 做 AND 运算，如果的到的结果是 1 ，那么这个原始的数字就是奇数

#### | 操作符

`|` 对其整型操作数执行按位`或`操作。回想一下`或`操作符具备以下性质：

```
Given operands a, b
OR(a, b) = 1; when a = 1 or b = 1
              else = 0 
```

我们可以利用按位`或`操作符为给定的整数有选择地设置单个位。例如，在如下示例中我们使用按位`或`将示例数（从低位到高位（MSB））中的第 3 ，第 7 和第 8 位置为 1 。

```
func main() {
    var a uint8 = 0
    a |= 196
    fmt.Printf("%b", a)
}

// 打印结果  11000100
            ^^   ^    
```

#### ^ 操作符

在 Go 中 按位 `异或` 操作是用 `^` 来表示的。 `异或`运算符有如下的特点：

```
Given operands a, b
XOR(a, b) = 1; only if a != b
     else = 0
```

**`异或`运算的这个特性可以用来把二进制位的一个值变成另外一个值**。举个例子，给到一个 16 进制的值，我们可以使用以下代码切换前 8 位（从 MSB 开始）的值。

```
func main() {
    var a uint16 = 0xCEFF
    a ^= 0xFF00 // same a = a ^ 0xFF00
}

// a = 0xCEFF   (11001110 11111111)
// a ^=0xFF00   (00110001 11111111)
```

在前面的代码片段中，与 1 进行异或的位被翻转（从 0 到 1 或从 1 到 0）。异或 运算的一个实际用途，例如，可以利用 异或运算去比较两个数字的符号是否一样。当 (a ^ b) ≥ 0 （或相反符号的 (a ^ b) < 0 ）为 true 的时候，两个整数 a，b 具有相同的符号，如下面的程序所示：

```
func main() {
    a, b := -12, 25
    fmt.Println("a and b have same sign?", (a ^ b) >= 0)
}
```

**^ 作为取反位运算符 （非）**

不像其他语言 （c/c++，Java，Python，Javascript，等）， **Go 没有专门的一元取反位运算符**。取而代之的是，XOR 运算符 ^，也可作为一元取反运算符作用于一个数字。对于给定位 x，在 Go 中 x = 1 ^ x 可以翻转该位。在以下的代码段中我们可以看到**使用 ^a 获取变量 a 的取反值的操作。**

```
func main() {
    var a byte = 0x0F
    fmt.Printf("%08b\n", a)
    fmt.Printf("%08b\n", ^a)
}

// 打印结果
00001111     // var a
11110000     // ^a
```

#### &^ 操作符

`&^` 操作符意为 `与非`，是 `与` 和 `非` 操作符的简写形式，它们定义如下。

```
Given operands a, b
AND_NOT(a, b) = AND(a, NOT(b))
```

如果第二个操作数为 1 那么它则具有清除第一个操作数中的位的趣味特性。

```
AND_NOT(a, 1) = 0; clears a
AND_NOT(a, 0) = a; 
```

接下来的代码片段使用 `AND NOT` 操作符，将变量值 `1010 1011` 变为 `1010 0000`，清除了操作数上的低四位。

```
func main() {
    var a byte = 0xAB
     fmt.Printf("%08b\n", a)
     a &^= 0x0F
     fmt.Printf("%08b\n", a)
}

// 打印：
10101011
10100000
```

### **<<和>> 操作符**

与其他 C 的衍生语言类似， Go 使用 << 和 >> 来表示左移运算符和右移运算符，如下所示：

```
Given integer operands a and n,
a << n; shifts all bits in a to the left n times
a >> n; shifts all bits in a to the right n times
```

例如，在下面的代码片段中变量 a （00000011）的值将会左移位运算符分别移动三次。每次输出结果都是为了说明左移的目的。

```
func main() {
    var a int8 = 3
    fmt.Printf("%08b\n", a)
    fmt.Printf("%08b\n", a<<1)
    fmt.Printf("%08b\n", a<<2)
    fmt.Printf("%08b\n", a<<3)
}

// 输出的结果:
00000011
00000110
00001100
00011000
```

## 位运算实现基本运算

[参考](https://www.jianshu.com/p/7bba031b11e7)

### 加法

先来个我们最熟悉的十进制的加法运算：

> 13 + 9 = 22

我们像这样来拆分这个运算过程：

1. 不考虑进位，分别对各位数进行相加，结果为sum：
    个位数3加上9为2；十位数1加上0为1； 最终结果为12；
2. 只考虑进位，结果为carry：
    3 + 9 有进位，进位的值为10；
3. 如果步骤2所得进位结果carry不为0，对步骤1所得sum，步骤2所得carry重复步骤1、 2、3；如果carry为0则结束，最终结果为步骤1所得sum：
    这里即是对sum = 12 和carry = 10重复以上三个步骤，(a) 不考虑进位，分别对各位数进行相加:sum = 22; (b) 只考虑进位: 上一步没有进位，所以carry = 0； (c) 步骤2carry = 0，结束，结果为sum = 22.

我们发现这三板斧行得通！

那我们现在还使用上面的三板斧把十进制运算放在二进制中看看是不是也行的通。

13的二进制为0000 1101，9的二进制为0000 1001:

1. **不考虑进位，分别对各位数进行相加**：
    sum = 0000 1101 + 0000 1001 = 0000 0100
2. **考虑进位**：
    有两处进位，第0位和第3位，只考虑进位的结果为：
    carry = 0001 0010
3. 步骤2carry == 0 ?，不为0，重复步骤1 、2 、3；为0则结束，结果为sum：
    本例中，
    (a)不考虑进位sum = 0001 0110;
    (b)只考虑进位carry  = 0;
    (c)carry == 0，结束，结果为sum = 0001 0110
    转换成十进制刚好是22.

我们发现，适用于十进制的三板斧同样适用于二进制！仔细观察者三板斧，大家能不能发现其实**第一步不考虑进位的加法其实就是异或运算**；而第二部**只考虑进位就是与运算并左移一位**--；第三步就是**重复前面两步操作直到第二步进位结果为0**。

这里关于第三步多说一点。为什么要循环步骤1、 2、 3直到步骤2所得进位carry等于0？其实这是因为有的数做加法时会出现连续进位的情况，举例：3 + 9，我们来走一遍上述逻辑：

> a = 0011, b = 1001;
>  start;

> first loop;
>  1.1 sum = 1010
>  1.2 carry = 0010
>  1.3 carry != 0 , go on;

> second loop;
>  2.1 sum = 1000;
>  2.2 carry = 0100;
>  2.3 carry != 0, go on;

> third loop;
>  3.1 sum = 1100;
>  3.2 carry = 0000;
>  3.3 carry == 0, stop; result = sum;

> end

如上面的栗子，有的加法操作是有连续进位的情况的，所以这里要在第三步检测carry是不是为0，如果为0则表示没有进位了，第一步的sum即为最终的结果。

有了上面的分析，我们不难写出如下代码：



```csharp
// 递归写法
func add(a int, b int) int {
    if(b == 0)
        return a
    sum := a ^ b
    carry := (a & b) << 1
    return add(sum, carry)
}

// 迭代写法
func add(a int, b int) int {
  carry:=0
  for b!=0{  //相当于进位不等于0
      carry=(a&b)<<1 //算出进位
      a^=b           //算出不带进位的和
      b=carry        //更新进位
  }
  return a
}
```

我们的计算机其实就是通过上述的位运算实现加法运算的（通过加法器，加法器就是使用上述的方法实现加法的），而程序语言中的+ - * /运算符只不过是呈现给程序员的操作工具，计算机底层实际操作的永远是形如0101的位，所以说位运算真的很重要！

### 减法

我们知道了位运算实现加法运算，那减法运算就相对简单一些了。我们实现了加法运算，自然的，我们会想到把**减法运算11 - 6变形为加法运算11 + (-6)**，即一个正数加上一个负数。是的，很聪明，其实我们的计算机也是这样操作的，那有的人会说为什么计算机不也像加法器一样实现一个减法器呢？对的，这样想当然是合理的，但是考虑到减法比加法来的复杂，实现起来比较困难。为什么呢？我们知道加法运算其实只有两个操作，加、 进位，而减法呢，减法会有借位操作，如果当前位不够减那就从高位借位来做减法，这里就会问题了，借位怎么表示呢？加法运算中，进位通过与运算并左移一位实现，而借位就真的不好表示了。所以我们自然的想到将减法运算转变成加法运算。

怎么实现呢？

刚刚我们说了减法运算可转变成一个正数加上一个负数，那首先就要来看看负数在计算机中是怎么表示的。

+8在计算机中表示为二进制的1000，那-8怎么表示呢？

很容易想到，可以将一个二进制位（bit）专门规定为符号位，它等于0时就表示正数，等于1时就表示负数。比如，在8位机中，规定每个字节的最高位为符号位。那么，+8就是00001000，而-8则是10001000。这只是直观的表示方法，其实**计算机是通过2的补码来表示负数**的，那什么是2的补码（同补码，英文是2's complement，其实应该翻译为2的补码）呢？它是一种用二进制表示有号数的方法，也是一种将数字的正负号变号的方式，求取步骤：

- 第一步，每一个二进制位都取相反值，0变成1，1变成0（即反码）。
- 第二步，将上一步得到的值（反码）加1。

简单来说就是**取反加一**！

关于补码更详细的内容可参[维基百科-补码](https://link.jianshu.com?t=!https://zh.wikipedia.org/wiki/二補數)，这里不再赘述。

其实我们利用的恰巧是补码的可以将数字的正负号变号的功能，这样我们就可以把减法运算转变成加法运算了，因为负数可以通过其对应正数求补码得到。计算机也是通过增加一个补码器配合加法器来做减法运算的，而不是再重新设计一个减法器。

以上，我们很容易写出了位运算做减法运算的代码：



```csharp
/*
* num1: 减数
* num2: 被减数
*/
int substract(int num1, int num2){
    int subtractor = add(~num2, 1);// 先求减数的补码（取反加一）
    int result = add(num1, subtractor); // add()即上述加法运算　　
    return result ;
}
```

### 乘法



### 除法



