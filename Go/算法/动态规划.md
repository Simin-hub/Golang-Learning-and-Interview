# 	动态规划

[参考](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg)

## 介绍

动态规划不是某一种具体的算法，而是一种算法思想：**若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解**。

应用这种算法思想解决问题的可行性，对子问题与原问题的关系，以及子问题之间的关系这两方面有一些要求，它们分别对应了最优子结构和重复子问题。

### 最优子结构

**最优子结构规定的是子问题与原问题的关系**

动态规划要解决的都是一些问题的最优解，即从很多解决问题的方案中找到最优的一个。当我们在求一个问题最优解的时候，如果可以把这个问题分解成多个子问题，然后递归地找到每个子问题的最优解，最后通过一定的数学方法对各个子问题的最优解进行组合得出最终的结果。总结来说就是**一个问题的最优解是由它的各个子问题的最优解决定的。**

将子问题的解进行组合可以得到原问题的解是动态规划可行性的关键。在解题中一般用状态转移方程描述这种组合。例如原问题的解为 f(n)，其中 f(n)也叫状态。状态转移方程 f(n) = f(n - 1) + f(n - 2)描述了一种原问题与子问题的组合关系 。在原问题上有一些选择，不同选择可能对应不同的子问题或者不同的组合方式。例如

![image-20220718110449937](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220718110449937.png)

n = 2k 和 n = 2k + 1 对应了原问题 n 上不同的选择，分别对应了不同的子问题和组合方式。

找到了最优子结构，也就能推导出一个状态转移方程 f(n)，通过这个状态转移方程，我们能很快的写出问题的递归实现方法。

​	![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/1-1.png)

### 重复子问题

**重复子问题规定的是子问题与子问题的关系**。

当我们在递归地寻找每个子问题的最优解的时候，有可能会重复地遇到一些更小的子问题，而且这些子问题会重叠地出现在子问题里，出现这样的情况，会有很多重复的计算，**动态规划可以保证每个重叠的子问题只会被求解一次**。当重复的问题很多的时候，动态规划可以减少很多重复的计算。

重复子问题不是保证解的正确性必须的，但是如果递归求解子问题时，没有出现重复子问题，则没有必要用动态规划，直接普通的递归就可以了。

例如，斐波那契问题的状态转移方程 f(n) = f(n - 1) + f(n - 2)。在求 f(5) 时，需要先求子问题 f(4)和 f(3)f(3，得到结果后再组合成原问题 f(5)f(5) 的解。递归地求 f(4) 时，又要先求子问题 f(3)和 f(2)，这里的 f(3)与求 f(5)时的子问题重复了。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/1-2.png)

**解决动态规划问题的核心：找出子问题及其子问题与原问题的关系**

找到了子问题以及子问题与原问题的关系，就可以递归地求解子问题了。但重叠的子问题使得直接递归会有很多重复计算，于是就想到记忆化递归法：若能事先确定子问题的范围就可以建表存储子问题的答案。

动态规划算法中关于最优子结构和重复子问题的理解的关键点：

1. 证明问题的方案中包含一种选择，选择之后留下一个或多个子问题

2. 设计子问题的递归描述方式
3. 证明对原问题的最优解包括了对所有子问题的最优解
4. 证明子问题是重叠的（这一步不是动态规划正确性必需的，但是如果子问题无重叠，则效率与一般递归是相同的）

## 解决动态规划问题的思考过程

题目：300.最长上升子序列

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例：

```
输入: [10,9,2,5,3,7,101,18]
输出: 4
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是4。
```

### 考虑能否将问题规模减小

将问题规模减小的方式有很多种，**一些典型的减小方式是动态规划分类的依据，例如线性，区间，树形等**。这里考虑**数组上常用**的两种思路：

**每次减少一半**：如果每次将问题规模减少一半，原问题有[10,9,2,5]，和[3,7,101,18]，两个子问题的最优解分别为 [2,5] 和 [3,7,101]，但是找不到好的组合方式将两个子问题最优解组合为原问题最优解 [2,5,7,101]或 [2, 3, 7, 101]。

**每次减少一个**：记 f(n)为以第 n个数结尾的最长子序列，每次减少一个，将原问题分为 f(n-1), f(n-2), ..., f(1)，共 n - 1 个子问题。n - 1 = 7 个子问题以及答案如下：

```
[10, 9, 2, 5, 3, 7, 101] -> [2, 5, 7, 101]
[10, 9, 2, 5, 3, 7] -> [2, 5, 7]
[10, 9, 2, 5, 3] -> [2, 3]
[10, 9, 2, 5] -> [2, 5]
[10, 9, 2] -> [2]
[10, 9] -> [9]
[10] -> [10]
```

已经有 7 个子问题的最优解之后，可以发现一种组合方式得到原问题的最优解：f(6)的结果 [2,5,7], 7 < 18，同时长度也是 f(1)~f(7) 中，结尾小于 18 的结果中最长的。f(7) 虽然长度为 4 比 f(6) 长，但结尾是不小于 18 的，无法组合成原问题的解。

以上组合方式可以写成一个式子，即状态转移方程

![image-20220718151243543](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220718151243543.png)

这种思考如何通过 f(1)...f(n-1) 求出 f(n) 的过程实际就是在思考状态转移方程怎么写。

总结： 解决动态规划问题最难的地方有两点：

- 如何定义 f(n)
- 如何通过 f(1), f(2), … f(n - 1) 推导出 f(n)，即状态转移方程

### 1. 递归

有了状态转移方程，实际上已经可以直接用递归进行实现了。

```
func lengthOfLIS(nums []int) int {
	var f func([]int, int)int
	f = func (a []int, i int)int{
		res := 1
		for j := 0; j < i; j++{
			if a[j] < a[i]{
				res = max(res, f(a, j) + 1)
			}
		}
		return res
	}
	res := 0
    for idx := range nums{
		// 依次判断以 nums[idx] 为结尾的最长升序子序列
		res = max(res, f(nums, idx)) 
	}
	return res
}

func max(a, b int)int{
	if a < b{
		return b
	}
	return a
}
```

### 2. 自顶向下（记忆化）

递归的解法需要非常多的重复计算，如果有一种办法能避免这些重复计算，可以节省大量计算时间。记忆化就是基于这个思路的算法。在递归地求解子问题 f(1), f(2)... 过程中，将结果保存到一个表里，在后续求解子问题中如果遇到求过结果的子问题，直接查表去得到答案而不计算。

```
func lengthOfLIS(nums []int) int {
	var f func([]int, int, []int)int
	f = func (nums []int, i int, dp []int)int{
		if dp[i] != 0{
			return dp[i]
		}
		res := 1
		for j := 0; j < i; j++{
			if nums[j] < nums[i]{
				res = max(res, f(nums, j, dp) + 1)
			}
		}
		dp[i] = res
		return res
	}
	dp := make([]int, len(nums))
	res := 0
    for idx := range nums{
		// 依次判断以 nums[idx] 为结尾的最长升序子序列
		res = max(res, f(nums, idx, dp)) 
	}
	return res
}

func max(a, b int)int{
	if a < b{
		return b
	}
	return a
}
```

**对于这种将问题规模不断减少的做法，我们把它称为自顶向下的方法**。

### 3. 自底向上（迭代）

在自顶向下的算法中，由于递归的存在，程序运行时有额外的栈的消耗。

有了状态转移方程，我们就知道**如何从最小的问题规模入手，然后不断地增加问题规模，直到所要求的问题规模为止**。在这个过程中，我们同样地可以记忆每个问题规模的解来避免重复的计算。这种方法就是自底向上的方法，由于避免了递归，这是一种更好的办法。

但是迭代法需要有一个明确的迭代方向，例如线性，区间，树形，状态压缩等比较主流的动态规划问题中，迭代方向都有相应的模式。参考后面的例题。但是有一些问题迭代法方向是不确定的，这时可以退而求其次用记忆化来做，参考后面的例题。

### 动态规划的解题步骤

做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚`dp[i]`表示的是什么。

**这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中**。

状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。

**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. `确定dp数组（dp table）以及下标的含义`
2. 确定递推公式
3. dp数组**如何初始化**
4. 确定遍历顺序
5. 举例推导dp数组

一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？

**因为一些情况是递推公式决定了dp数组要如何初始化！**

后面的讲解中我都是围绕着这五点来进行讲解。

可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。

其实 确定递推公式 仅仅是解题里的一步而已！

一些同学知道递推公式，但搞不清楚dp数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。

后序的讲解的大家就会慢慢感受到这五步的重要性了。

### 动态规划应该如何debug

相信动规的题目，很大部分同学都是这样做的。

看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp数组的初始化，递推公式，遍历顺序，处于一种黑盒的理解状态。

写动规题目，代码出问题很正常！

**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**

一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。

这是一个很不好的习惯！

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。

如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

**这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了**。

这也是我为什么在动规五步曲里强调推导dp数组的重要性。

举个例子哈：在「代码随想录」刷题小分队微信群里，一些录友可能代码通过不了，会把代码抛到讨论群里问：我这里代码都已经和题解一模一样了，为什么通过不了呢？

发出这样的问题之前，其实可以自己先思考这三个问题：

- 这道题目我举例推导状态转移公式了么？
- 我打印dp数组的日志了么？
- 打印出来了dp数组和我想的一样么？

**如果这灵魂三问自己都做到了，基本上这道题目也就解决了**，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。

然后在问问题，目的性就很强了，群里的小伙伴也可以快速知道提问者的疑惑了。

**注意这里不是说不让大家问问题哈， 而是说问问题之前要有自己的思考，问题要问到点子上！**

**大家工作之后就会发现，特别是大厂，问问题是一个专业活，是的，问问题也要体现出专业！**

如果问同事很不专业的问题，同事们会懒的回答，领导也会认为你缺乏思考能力，这对职场发展是很不利的。

所以大家在刷题的时候，就锻炼自己养成专业提问的好习惯。

## 动态规划与其它算法的关系

### 分治

**解决分治问题的时候，思路就是想办法把问题的规模减小**，有时候减小一个，有时候减小一半，然后将每个小问题的解以及当前的情况组合起来得出最终的结果。例如归并排序和快速排序，归并排序将要排序的数组平均地分成两半，快速排序将数组随机地分成两半。然后不断地对它们递归地进行处理。

这里存在有最优的子结构，即原数组的排序结果是在子数组排序的结果上组合出来的，但是不存在重复子问题，因为不断地对待排序的数组进行对半分的时候，两半边的数据并不重叠，**分别解决左半边和右半边的两个子问题的时候，没有子问题重复出现，这是动态规划和分治的区别**。

### 贪心

#### 关于最优子结构

- 贪心**：每一步的最优解一定包含上一步的最优解，上一步之前的最优解无需记录**
- 动态规划：**全局最优解中一定包含某个局部最优解，但不一定包含上一步的局部最优解**，因此需要记录之前的所有的局部最优解

#### 关于子问题最优解组合成原问题最优解的组合方式

- 贪心：如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可，这里的最优是贪心意义上的最优。此时不需要知道一个节点的所有子树情况，于是构不成一棵完整的树
- 动态规划：动态规划需要对每一个子树求最优解，直至下面的每一个叶子的值，最后得到一棵完整的树，在所有子树都得到最优解后，将他们组合成答案

#### 结果正确性

- **贪心不能保证求得的最后解是最佳的**，复杂度低
- **动态规划本质是穷举法，可以保证结果是最佳的**，复杂度高

![image-20220718160014006](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220718160014006.png)

## 满足两个条件

- 满足以下条件之一
  - 求最大/最小值（Maximum/Minimum ）
  - 求是否可行（Yes/No ）
  - 求可行个数（Count(*) ）
- 满足不能排序或者交换（Can not sort / swap ）

## 四点要素

### 1.**状态 State**

- 灵感，创造力，存储小规模问题的结果

**状态定义** 就是定义子问题，**如何表示目标规模的问题和更小规模的问题**。例如常见的方法：定义状态 dp[n]，表示规模为 n 的问题的解，dp[n - 1] 就表示规模为 n - 1 的子问题的解。在实战中 dp[n] 的具体含义需要首先整理清楚再往下做。

### 2.方程 Function

- 状态之间的联系，怎么通过小的状态，来算大的状态

**状态转移** 就是**子问题之间的关系**，例如定义好状态 dp[n]，此时子问题是 dp[n-1] 等，并且大规模的问题的解依赖小规模问题的解，此时需要知道怎样通过小规模问题的解推出大规模问题的解。这一步就是列状态转移方程的过程。一般的状态转移方程可以写成如下形式


dp[n] = f(dp[i]) 其中 i < n

### 3.初始化 Intialization

- 最极限的小状态是什么, 起点

### 4.答案 Answer

- 最大的那个状态是什么，终点

## 常见类型

### 线性动态规划

线性动态规划的主要特点是**状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解**。

这里问题规模为 i 的含义是考虑前 i 个元素 [0..i] 时问题的解。

状态定义：

```
dp[n] := [0..n] 上问题的解
```


状态转移：

```
dp[n] = f(dp[n-1], ..., dp[0])
```


从以上状态定义和状态转移可以看出，**大规模问题的状态只与较小规模的问题有关**，而问题规模完全用一个变量 i 表示，i 的大小表示了问题规模的大小，因此从小到大推 i 直至推到 n，就得到了大规模问题的解，这就是线性动态规划的过程。

按照问题的输入格式，**线性动态规划解决的问题主要是单串，双串，矩阵上的问题**，因为在单串，双串，矩阵上问题规模可以完全用位置表示，并且位置的大小就是问题规模的大小。因此从前往后推位置就相当于从小到大推问题规模。

线性动态规划是动态规划中最基本的一类。问题的形式、dp 状态和方程的设计、以及与其它算法的结合上面变化很多。按照 dp 方程中各个维度的含义，可以大致总结出几个主流的问题类型，见后面的小节。除此之外还有很多没有总结进来的变种问题，小众问题，和困难问题，这些问题的解法更多地需要结合自己的做题经验去积累，除此之外，常见的，主流的问题和解法都可以总结成下面的四个小类别。

#### 单串

**单串 dp[i] 线性动态规划最简单的一类问题**，输入是一个串，状态一般定义为 dp[i] := 考虑[0..i]上，原问题的解，其中 i 位置的处理，根据不同的问题，主要有两种方式：

- 第一种是 i 位置**必须取**，此时状态可以进一步描述为 dp[i] := 考虑[0..i]上，且取 i，原问题的解；

- 第二种是 i 位置**可以取可以不取**

大部分的问题，对 i 位置的处理是第一种方式，例如力扣：

- 70 爬楼梯问题
- 801 使序列递增的最小交换次数
- 790 多米诺和托米诺平铺
- 746 使用最小花费爬楼梯

线性动态规划中单串 dp[i] 的问题，状态的推导方向以及推导公式如下

![状态推导方向1](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/2-2-1.png)

##### 1. 依赖比 i 小的 O(1) 个子问题

`dp[n]` 只**与常数个小规模子问题有关**，状态的推导过程 `dp[i] = f(dp[i - 1], dp[i - 2], ...)`。时间复杂度 O(n)，空间复杂度 O(n) 可以优化为 O(1)，例如上面提到的 70, 801, 790, 746 都属于这类。

如图所示，虽然紫色部分的 `dp[i-1], dp[i-2], ..., dp[0]` 均已经计算过，但计算橙色的当前状态时，仅用到 dp[i-1]，这属于比 i 小的 O(1) 个子问题。

例如，当 `f(dp[i-1], ...) = dp[i-1] + nums[i]` 时，当前状态 `dp[i]` 仅与 `dp[i-1]` 有关。这个例子是一种数据结构前缀和的状态计算方式，关于前缀和的详细内容请参考下一章。

##### 2. 依赖比 i 小的 O(n) 个子问题

`dp[n]` 与**此前的更小规模的所有子问题** `dp[n - 1], dp[n - 2], ..., dp[1]` 都可能有关系。

状态推导过程如下：

```
dp[i] = f(dp[i - 1], dp[i - 2], ..., dp[0])
```


依然如图所示，计算橙色的当前状态 `dp[i]` 时，紫色的此前计算过的状态 `dp[i-1], ..., dp[0]` 均有可能用到，在计算 `dp[i]` 时需要将它们遍历一遍完成计算。

其中 f 常见的有 max/min，可能还会对 `i-1,i-2,...,0` 有一些筛选条件，但推导 `dp[n]` 时依然是 `O(n)` 级的子问题数量。

例如：

- 139 单词拆分
- 818 赛车

以 min 函数为例，这种形式的问题的代码常见写法如下

```
for i = 1, ..., n
    for j = 1, ..., i-1
        dp[i] = min(dp[i], f(dp[j]))
```


时间复杂度 O(n^2)，空间复杂度 O(n)

##### 单串 dp[i] 经典问题

以下内容将涉及到的知识点对应的典型问题进行讲解，题目和解法具有代表性，可以从一个问题推广到一类问题。

###### 依赖比 i 小的 O(1) 个子问题

[53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

> 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

一个数组有很多个子数组，求哪个子数组的和最大。可以按照子数组的最后一个元素来分子问题，确定子问题后设计状态

```
dp[i] := [0..i] 中，以 nums[i] 结尾的最大子数组和
```


状态的推导是按照 i 从 0 到 n - 1 按顺序推的，推到 `dp[i]`，时，`dp[i - 1], ..., dp[0]` 已经计算完。因为子数组是连续的，所以子问题 `dp[i]` 其实只与子问题 `dp[i - 1]` 有关。如果 `[0..i-1]` 上以 `nums[i-1]` 结尾的最大子数组和(缓存在 `dp[i-1]` )为非负数，则以 `nums[i]` 结尾的最大子数组和就在 `dp[i-1]` 的基础上加上 `nums[i]` 就是 `dp[i]` 的结果否则以 i 结尾的子数组就不要 i-1 及之前的数，因为选了的话子数组的和只会更小。

按照以上的分析，状态的转移可以写出来，如下

```
dp[i] = nums[i] + max(dp[i - 1], 0)
```


这个是单串 dp[i] 的问题，状态的推导方向，以及推导公式如下

![状态推导方向1](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/2-2-1.png)

```
func maxSubArray(nums []int) int {
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    res := nums[0]
    for i := 1; i < len(nums); i++{
        dp[i] = max(dp[i-1] + nums[i], nums[i])
        res = max(res, dp[i])
    }
    return res
}

func max(a, b int)int{
	if a < b{
		return b
	}
	return a
}
```

在本题中，`f(dp[i-1], ..., dp[0])` 即为 `max(dp[i-1], 0) + nums[i]`，`dp[i]` 仅与 `dp[i-1]` 1 个子问题有关。因此虽然紫色部分的子问题已经计算完，但是推导当前的橙色状态时，只需要 `dp[i-1]` 这一个历史状态。

```
func maxSubArray(nums []int) int {
    res, pre := nums[0], nums[0]
    for i := 1; i < len(nums); i++{
        pre = max(pre + nums[i], nums[i])
        res = max(res, pre)
    }
    return res
}

func max(a, b int)int{
	if a < b{
		return b
	}
	return a
}
```

###### 依赖比 i 小的 O(n) 个子问题

[300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

> 给定一个无序的整数数组，找到其中最长上升子序列的长度。

输入是一个单串，首先思考单串问题中设计状态 `dp[i]` 时拆分子问题的方式：枚举子串或子序列的结尾元素来拆分子问题，设计状态 `dp[i] := 在子数组 [0..i]` 上，且选了 `nums[i]` 时，的最长上升子序列。

因为子序列需要上升，因此以 i 结尾的子序列中，`nums[i] `之前的数字一定要比 `nums[i]` 小才行，因此目标就是先找到以此前比 `nums[i]` 小的各个元素，然后每个所选元素对应一个以它们结尾的最长子序列，从这些子序列中选择最长的，其长度加 1 就是当前的问题的结果。如果此前没有比 `nums[i]` 小的数字，则当前问题的结果就是 1 。

按照以上的分析，状态的转移方程可以写出来，如下

![image-20220718163010050](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220718163010050.png)

其中 $0 \leq j < i, nums[j] < nums[i]0≤j<i,nums[j]<nums[i]$。

本题依然是单串 dp[i] 的问题，状态的推导方向，以及推导公式与上一题的图示相同，

状态的推导依然是按照 i 从 0 到 n-1 推的，计算 `dp[i]` 时，`dp[i-1], dp[i-2], ..., dp[0]` 依然已经计算完。

但本题与上一题的区别是推导 `dp[i]` 时，`dp[i-1]. dp[i-2], ..., dp[0`] 均可能需要用上，即，因此计算当前的橙色状态时，紫色部分此前计算过的状态都可能需要用上。

##### 单串相关练习题

- 最经典单串 LIS 系列
  - [最长上升子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)
  - [最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)
  - [俄罗斯套娃信封问题 —— LIS](https://leetcode.cn/problems/russian-doll-envelopes)
  
- 最大子数组和系列
  - [最大子序和](https://leetcode.cn/problems/maximum-subarray)
  - [乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/submissions/)
  - [环形子数组的最大和 —— 环形数组的处理](https://leetcode.cn/problems/maximum-sum-circular-subarray/)
  - 最大子矩阵 —— 思路类似一维的最大子数组和
  - 矩形区域不超过 K 的最大数值和 —— 在上一题基础上加了一个 K
  
- 打家劫舍系列

  打家劫舍主要是**不相邻子序列的最大和问题**，以及若干变形

  - [打家劫舍](https://leetcode.cn/problems/house-robber/)
  - [打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)
  - [删除与获得点数](https://leetcode.cn/problems/delete-and-earn/)
  - [3n 块披萨](https://leetcode.cn/problems/pizza-with-3n-slices/)

- 变形：需要两个位置的情况
  - [最长的斐波那契子序列的长度](https://leetcode.cn/problems/Q91FMA/) —— `dp[i][j]:= 以 j, i 结尾，转移时在 [0..j] 中找满足条件的 k 这一步可以二分或哈希表`
  - [最长等差数列](https://leetcode.cn/problems/longest-arithmetic-subsequence/) —— `dp[i][j]:= 以 j, i 结尾，转移时在 [0..j] 中找满足条件的 k 这一步用哈希表，键为数组值，值为保存下标的平衡树`
  
- 与其它算法配合
  - 形成字符串的最短路径 —— DP + 二分，贪心
  - 最大整除子集 —— 先对数组排序
  
- 其它单串 dp[i] 问题
  - 最长有效括号
  - 等差数列划分
  - 解码方法
  - 分割回文串 II
  - 比特位计数
  - 使序列递增的最小交换次数
  - 最低加油次数
  - 两个字符串的删除操作
  
- 带维度单串 `dp[i][k]`
  - 最大平均值和的分组 —— k 是个数
  - 鸡蛋掉落 —— k 是次数，k 上有二分
  - 粉刷房子 —— k 是颜色
  - 粉刷房子 II —— k 是颜色
  - 奇偶跳 —— k 表示当前的奇偶状态
  - 青蛙过河 —— k 表示上一步的跳的步数
  - 安排邮筒 —— k 是个数，前缀和维护状态转移时的查询
  - 抛掷硬币 —— k 是个数
  - 分割数组的最大值 —— k 是份数
  - 给房子涂色 III —— 有两个指标 k 颜色；t 街区数
  
- 股票系列
  - 买卖股票的最佳时机
  - 买卖股票的最佳时机 II
  - 买卖股票的最佳时机 III
  - 买卖股票的最佳时机 IV
  - 最佳买卖股票时机含冷冻期
  - 买卖股票的最佳时机含手续费

#### 双串

有两个输入从串，长度分别为 m, n，此时子问题需要用 i, j 两个变量表示，分别代表第一个串和第二个串考虑的位置 `dp[i][j]:=第一串考虑[0..i]，第二串考虑[0..j]时，原问题的解`

较大规模的子问题只与常数个较小规模的子问题有关，其中较小规模可能是 i 更小，或者是 j 更小，也可以是 i，j 同时变小。

其中一种最常见的状态转移形式：推导 `dp[i][j] `时，`dp[i][j] `仅与 `dp[i-1][j]`, `dp[i][j-1]`, `dp[i-1][j-1]`，例如

- 72 编辑距离
- 712 两个字符串的最小 ASCII 删除和

线性动态规划中双串 `dp[i][j]` 的问题，状态的推导方向以及推导公式如下

![状态推导方向2](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/2-2-2.png)

如图所示，绿色部分的 `dp[i-1 ~ 0][j-1 ~ 0]` 均已经计算过，但计算橙色的当前状态时，仅用到 `dp[i-1][j]`, `dp[i][j-1]`, `dp[i-1][j-1]`，即比 i, j 小的 O(1)O(1) 个子问题。

这种形式的线性 DP 的代码常见写法

```
for i = 1..m
    for j = 1..n
        dp[i][j] = f(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])
```


时间复杂度 O(mn)，空间复杂度 O(mn)

以上是 O(1) 转移的情况，即计算 `dp[i][j]` 时，虽然绿色部分的子问题均已经计算完，但只需要用到 `dp[i-1][j]`, `dp[i][j-1]`, `dp[i-1][j-1]`。也可能出现更高复杂度的转移，类似单串中依赖比 i 小的 O(n) 个子问题的情况。

##### 双串 `dp[i][j]` 经典问题

以下将涉及到的知识点对应的典型问题进行讲解，题目和解法具有代表性，可以从一个问题推广到一类问题。

[最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

> 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

输入是双串，首先思考双串问题中设计状态 `dp[i][j]` 时拆分子问题的方式：枚举第一串的子序列的结尾和第二串的子序列的结尾来拆分子问题，设计状态 `dp[i][j] := text1 考虑 [0..i], text2 考虑 [0..j] 时，原问题的解，即 LCS 长度`

这个是单串 `dp[i][j]` 的问题，状态的推导方向，以及推导公式如下

![状态推导方向2](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/06/2-2-2.png)

状态的推导是按照 i 从 0 到 n - 1、j 从 0 到 m - 1 顺序推的，推到 `dp[i][j]` 时，`dp[i - 1 .. 0][j - 1 .. 0]` 均已经计算完。

因为两个子序列需要相同，若两个串的末尾元素相同，则可以选择 text1[i] 和 text2[j]，此时再根据此前已经 `text1[0..i-1]` 和 `text[0..j-1]` 的 LCS 长度。若两个串的末尾元素不同，则 text1[i] 和 text2[j] 中只能选一个，

- 若选了 text1[i]，则 text2 只能取到 j-1，此时 `dp[i-1][j]` 的结果就是当前状态 dp[i][j] 的结果。
- 若选了 text2[j]，则 text1 只能取到 i-1，此时 `dp[i][j-1]` 的结果就是当前状态 dp[i][j] 的结果。

两个结果要取一个最长的。

按照以上的分析，状态的转移方程可以写出来，如下

```
dp[i][j] =
1. dp[i-1][j-1] + 1  (text1[i] == text2[j])
2. max(dp[i][j-1], dp[i-1][j])  (text1[i] != text2[j])
两者取较大值
```

[编辑距离](https://leetcode-cn.com/problems/edit-distance)

> 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
>
> 你可以对一个单词进行如下三种操作：
>
> 插入一个字符
>
> 删除一个字符
>
> 替换一个字符

输入是双串，首先思考双串问题中设计状态 dp[i][j] 时拆分子问题的方式：枚举第一串的子序列的结尾和第二串的子序列的结尾来拆分子问题，设计状态 `dp[i][j] := word1 考虑 [0..i], word2 考虑 [0..j] 时，原问题的解，即 word1 转换成 word2 的最少操作数`

这个是单串 `dp[i][j]` 的问题，状态的推导方向，以及推导公式与上一题的图示相同

同样地，状态的推导是按照 i 从 0 到 n - 1、j 从 0 到 m - 1 顺序推的，推到 `dp[i][j]` 时，`dp[i - 1 .. 0][j - 1 .. 0]` 均已经计算完。

因为操作之后两个 word 需要相同，如果两个串的末尾元素 word1[i] 和 word2[j] 不相同，则可以在 word1 的末尾元素上使用插入，删除，替>换这三种操作，操作数都要 + 1，如果两个串的末尾元素 word1[i] 和 word2[j] 相同，依然可以在 word1 的末尾元素上使用插入，删除，替换这三种操作，但是此时如果使用改，则操作数不 +1，因为两个末尾元素已经相等了。

按照以上的分析，状态的转移方程可以写出来，如下

```
dp[i][j] =
1. dp[i][j-1] + 1  (最后一步是插入)
2. dp[i-1][j] + 1  (最后一步是删)
3. dp[i-1][j-1] + 1  (最后一步是改，且 word1[i] != word2[j])
4. dp[i-1][j-1]  (最后一步是改，且 word1[i] == word2[j])
取较小值

作者：FennelDumplings
链接：https://leetcode.cn/leetbook/read/dynamic-programming-1-plus/5pqqrh/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

##### 双串相关练习题

- 最经典双串 LCS 系列
  - 最长公共子序列
  - 两个字符串的最小 ASCII 删除和 —— LCS，len 和 ascii 各一个 dp
  - 最长重复子数组 —— 最长公共子串，注意与最长公共子序列的区别
- 字符串匹配系列
  - 编辑距离
  - 通配符匹配
  - 正则表达式匹配
- 其它双串 `dp[i][j]` 问题
  - 交错字符串
  - 不同的子序列
- 带维度双串 `dp[i][j][k]`
  - 扰乱字符串

#### 矩阵

输入是一个矩阵，宽和高分别为 m, n，用两个维度表示问题规模 `dp[i][j]:=第一维度考虑[0..i], 第二维度考虑[0..j]，原问题的解`

这样的状态定义，i 减小，j 减小均可以得到小规模子问题，两个维度均从小到大按顺序推，单独看各自维度，均是一个类似 上 的单串 `dp[i]` 问题，同样有单串中的两种情况，即转移时要考虑 O(1)个小规模子问题，和转移时要考虑 O(n) 个子问题。

两个维度均只需考虑 O(1) 个子问题是最简单的情况，一般 `dp[i][j]` 就只与 `dp[i-1][j], dp[i][j-1], dp[i-1][j-1]` 有关，例如 64，但是也有可能出现需要其它位置的状态的情况，需要结合题目分析，这里分析的计算 dp[i][j] 需要哪些状态，决定了状态推导的方向。

线性动态规划中矩阵 `dp[i][j]` 的问题，状态的推导方向以及推导公式与双串 `dp[i][j]` 相同，但是物理意义不一样，且求 dp[i][j] 时所需的子问题的变化相对更多。

##### 矩阵 `dp[i][j]` 经典问题

以下将涉及到的知识点对应的典型问题进行讲解，题目和解法具有代表性，可以从一个问题推广到一类问题。

[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

> 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

输入是矩阵，首先思考矩阵问题中设计状态 dp[i][j] 时拆分子问题的方式：枚举右下角的点的子序列的结尾和第二串的子序列的结尾来拆分子问题，设计状态 `dp[i][j] := 从 (0,0) 走到 (i,j)，原问题的解，即 (0,0) 走到 (i,j) 最小的路径和`

这个是单串 `dp[i][j]` 的问题，状态的推导方向，以及推导公式与上一题的图示相同，状态的推导是`按照 i 从 0 到 n - 1、j 从 0 到 m - 1 顺序推的，推到 dp[i][j] 时，dp[i - 1 .. 0][j - 1 .. 0] 均已经计算完`。

因为行走的路线只能向左或向下，因此计算 `dp[i][j] 时只需要 dp[i-1][j] 和 dp[i][j-1]` 的状态。当前位置可能从上面走来，此时就取 `dp[i-1][j] 加上当前点的值 nums[i][j]`，当前位置也可能从左边走来，此时就取 `dp[i][j-1] 加上当前点的值 nums[i][j]`。除了这两种情况，没有其它情况可以到达当前点 (i, j) 了。

按照以上的分析，状态的转移方程可以写出来，如下

```
dp[i][j] =
1. dp[i-1][j] + nums[i][j]  (从上边走来)
2. dp[i][j-1] + nums[i][j]  (从左边走来)
取较小值
```

##### 矩阵相关练习题

- `矩阵 dp[i][j]`
  - 三角形最小路径和
  - 最小路径和
  - 地下城游戏
  - 下降路径最小和
  - 最大正方形
  - 下降路径最小和 II
- `矩阵 dp[i][j][k]`
  - 最大矩形
  - 矩形区域不超过 K 的最大数值和 —— k 为宽度
  - 最大子矩阵 —— 思路类似一维的最大子数组和
  - 切披萨的方案数 —— 需要二维前缀和判断两个状态之间能否转移

#### 无串线性问题

线性动态规划有一类问题是没有显式的数组或字符串的。但在计算中依然可以分成若干子问题，且有动态规划的三条性质。因此也可以用动态规划来解。

- 只有两个键的键盘
- 丑数 II
- 完全平方数
- 整数拆分

#### 总结

线性动态规划是动态规划中最基础的一类，它的状态一般物理意义很明确，易于分析。在初学动态规划时，通过线性动态规划的大量练习，可以不断加深动态规划的概念理解，例如动态规划中最重要的三个概念：最优子结构，重复子问题，无后效性。下面对动态规划的三个基本概念做个简要回顾，在线性动态规划的题目练习中可以不断地加深理解，之后再学习其它的动态规划类型就会容易很多。

最优子结构：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构。
无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
重复子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）
线性动态规划是动态规划中变化最多的一类。

首先线性动态规划针对的问题是最常见的数组，字符串，矩阵等，这三种数据结构本身就是线性的，因此出现这些类型的输入的时候，如果要用到动态规划，首先考虑线性动态规划就很合理了，因此很多问题不论最后正解是不是线性动态规划，都会首先想一下线性动态规划是否可行。

其次由于大部分问题的数据都是以这三种形式给出的，因此题目的变化会非常多，很多常见的输入形式以及问题都非常经典，都存在经典的状态设计。因此不考虑一些比较 Trick 的解法，仅仅是经典问题的经典状态设计，就比其它种类的动态规划问题多很多了。

例如单个数组或字符串上设计一维状态，两个数组或字符串上设计两维状态，以及矩阵上设计两维状态等等，同时以上三种情况的状态设计都有可能再加上额外的指标的状态，就是前面例题中的 k，这里面变化就很多了，比如有的题目在 k 这一维上要使用二分，贪心的策略，有的题目需要 DP 状态与数据结构配合来解决问题。

除此之外还有一类问题没有显式的数组，字符串，但是在求解的时候依然满足前面提到的动态规划三条基本概念，可以用动态规划求解，这种问题通常也是线性动态规划。如此多的变化仅仅本小节例举的题目是远远不够的，下一小节是线性动态规划的练习题，涉及到对线性动态规划的更多的变化。

### 前缀和

考虑以下问题：

给定长度 n 的序列a:$ a_{0}, a_{1}, ..., a_{n-1}$，给每个前缀求一次和，$S_{0} = 0, S_{i}=\sum^{i-1}_{j=0}{a_{j}}$。这些前缀和维护在一个长度 n + 1 数组 S 里, 称为**前缀和数组**。

有两类在数组 a 上的求和需求

- 前缀和：求 a[0..i] 的和
- 区间和：求区间 a[L, R] 的和

对于前缀和，S[i + 1] 刚好就是答案，因为这就是前缀和的定义：$S_{i + 1}=\sum^{i}_{j=0}a_{j}$

对于区间和，解决此问题最直观的方法是枚举 [L, R] 上的所有元素求和：$sum(L, R) = \sum_{idx = L}^{R}nums[idx] $。这种方法虽然直观，但是不足是查询一次需要 O(N) 的时间，并且每来一个新的查询，就要重新枚举元素求和。通过简单的画图推导可以得到答案为$S[R + 1] - S[L]$

如果查询次数很多，当新查询来时，此前的查询计算的中间结果很多是可以直接用的，新的查询不必重新枚举，例如 此前查询过 `sum(5, 10)`，现在来了新查询 `sum(4, 8)` 在计算新查询时，5 ~ 8 这一段在计算此前的查询 sum(5, 10) 的时候已经计算过了，新查询的计算过程可以写成 `nums[4] + sum(5, 8)` ，而不用全部枚举。

如果已经有了 **前缀和数组**，那么通过简单的画图推导可以知道，两个前缀和 S[R + 1] 和 S[L] 的差刚好就是　[L, R] 上的区间和。已有前缀和数组之后，这一步操作就是 O(1) 的。

现将前缀和数组预处理出来，然后**在每次查询中直接通过前缀和数组来计算**而不是通过原数组，这是一种缓存中间结果的思想，如果把这一思想执行彻底，可以将所有可能的问题 `sum(i, j) 其中 0<=i<=j<=n-1`，将计算它们所需的所有中间结果先算一次缓存下来。这里提到的是缓存所有所需的中间结果，而不是子问题的中间结果，因为计算 sum(i, j) 需要的中间结果是前 i-1i−1 个数的和 sum(0,i) 和前 jj个数的和 sum(0,j+1)。最终 `sum(i,j) = sum(0,j+1) - sum(0,i)` 这对于所有的区间查询都是适用的。

以上**将中间结果缓存思路与动态规划中缓存子问题的解的思路是一致的**。

定义 sums[k] 为 [0..k-1] 的和，其中 sums[0] 表示数组中没有数字被选中，sums[1] 表示只选中第一个数 `nums[0]`。 预先计算 `0 ~ k (0<=k<=n-1)(0<=k<=n−1)` 的和，这一系列的和都是从 0 开始的，因此称为前缀和。公式如下：

![image-20220718202353844](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220718202353844.png)

此后的区间查询都可以利用公式 `sum(i, j) = sums(0, j + 1) - sum(0, i)`

在上一章中，我们把线性动态规划中几种主流问题及其对应的 dp 状态设计做了总结。其中最基础的一种是单串 dp[i]，并且只与子问题 i - 1 有关，即 `dp[i] = f(dp[i-1])`。前缀和就是这种情况，sums[i] 只与 sums[i-1] 有关。推导前缀和数组的过程是 O(N)O(N) 的，如果区间和的查询次数达到了 O(N) 那么计算区间和的时间复杂度是摊销 O(1) 的。

以上就是前缀和的基础介绍了，其中比较关键的有两点

- **预处理前缀和的过程是最简单且最经典的单串动态规划问题**。
- 先**将所有位置的前缀和预处理出来，然后再处理区间和的查询，这是一种先缓存中间结果再处理查询的思路**，因为这些中间结果在查询时需要反复用到，缓存之后就不用反复计算了，因此花时间预处理这些信息是有效的。

**前缀和**除了**求区间和**之外，还有一些其它的应用：

1. 在用 `dp` 的方式推 sums[i] 的时候，**有时求完 sums[i] 需要查询以前算过的结果计算某种指标**，需要用其它数据结构将前面的计算结果维护起来，例如哈希表等等，在求每个位置的前缀和的过程中，查询数据结构并更新答案，这是前缀和的一大类问题，变化比较多，力扣上这类题也有很多，在本章最后一节中汇总了一些题目，在下一节也选择了典型题目做讲解。
2. 前缀和的逆运算是差分，对原序列求出其差分序列，然后在对得到的差分序列求其前缀和序列，可以得到原序列，这在处理一些区间修改的问题时很有用，参考后面小节的题目讲解。
3. 前缀和还可以推广到二维上，并用于快速求矩形和，二维前缀和的计算过程是最经典的矩阵上的线性动态规划，参考后面一节的题目和讲解。

#### 区间和

利用前缀和求区间和的思想，以及求前缀和的过程在上一节中已经重点介绍，这里主要回顾一下前缀和中的动态规划思想，如下：

```
状态定义：sums[i] := [0..i-1] 的和
状态转移：sums[i] = a[i - 1] + sums[i - 1]
初始化：sums[0] = 0
```


这是最简单的单串线性动态规划，其思想在上一章重点介绍。求解该动态规划问题后得到数组 sums 。然后区间和问题就变成了两个前缀和的差的问题。

```
int rangeRum(int L, int R)
{
    return sums[R + 1] - sums[L];
}
```



### 区间动态规划

区间 DP 是状态的定义和转移都与区间有关，其中区间用两个端点表示。

状态定义 `dp[i][j] = [i..j]` 上原问题的解。i 变大，j 变小都可以得到更小规模的子问题。

对于单串上的问题，我们可以对比一下线性动态规划和区间动态规划。线性动态规划, 一般是定义 `dp[i]`， 表示考虑到前 i 个元素，原问题的解，i 变小即得到更小规模的子问题，推导状态时候是从前往后，即 i 从小到大推的。区间动态规划，一般是定义 `dp[i][j]`，表示考虑 [i..j] 范围内的元素，原问题的解增加 i，减小 j 都可以得到更小规模的子问题。推导状态一般是按照区间长度从短到长推的。

区间动态规划的状态设计，状态转移都与线性动态规划有明显区别，但是由于这两种方法都经常用在单串问题上，拿到一个单串的问题时，往往不能快速地判断到底是用线性动态规划还是区间动态规划，这也是区间动态规划的难点之一。

状态转移，推导状态 `dp[i][j]` 时，有两种常见情况

1. **`dp[i][j]` 仅与常数个更小规模子问题有关**
一般是与 `dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1]` 有关。

`dp[i][j] = f(dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1])`

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/4-1-1.png)

代码常见写法

```
for len = 1..n
    for i = i..len
        j = i + len - 1
        dp[i][j] = max(dp[i][j], f(dp[i+1][j], dp[i][j-1], dp[i+1][j-1]))
```

时间复杂度和空间复杂度均为 O(n^{2})

例如力扣第 516 题，详细过程参考下一节。

2.`dp[i][j] 与 O(n)` 个更小规模子问题有关

一般是枚举 [i,j] 的分割点，将区间分为 [i,k] 和 [k+1,j]，对每个 k 分别求解（下面公式的 f），再汇总（下面公式的 g）。

`dp[i][j] = g(f(dp[i][k], dp[k + 1][j]))` 其中 k = i .. j-1。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/4-1-2.png)

代码常见写法, 以下代码以 f 为 max 为例

```
for len = 1..n
    for i = i..len
        j = i + len - 1
        for k = i..j
            dp[i][j] = max(dp[i][j], f(dp[i][k], dp[k][j]))
```

时间复杂度可以达到 O(n^3)，空间复杂度还是 O(n^2)

例如力扣第 664 题，详细过程参考下一节

**总结**

区间动态规划一般用在单串问题上，以区间 [i, j] 为单位思考状态的设计和转移。它与线性动态规划在状态设计和状态转移上都有明显的不同，但由于这两个方法都经常用在单串问题上，导致我们拿到一个单串的问题时，经常不能快速反映出应该用哪种方法。这是区间动态规划的难点之一，但是这个难点也是好解决的，就是做一定数量的练习题，因为区间动态规划的题目比线性动态规划少很多，并且区间动态规划的状态设计和转移都比较朴素，变化也比线性动态规划少很多，所以通过不多的题目数量就可以把区间动态规划常见的方法和变化看个大概了。

- 后续节介绍区间动态规划的几个典型例题，学习区间动态规划问题常见的模式。
- 并且配有力扣上出现的区间动态规划的练习题，加深理解。

## 前缀和详解

### 数据结构维护前缀和

在上一节中提到，在用 `dp` 的方式推 sums[i] 的时候，有时求完 sums[i] 需要查询以前算过的结果计算某种指标，需要用其它数据结构将前面的计算结果维护起来，以便高效查询。以下几个问题就是以上思路的直接应用。

将前缀和维护在数据结构中，**以便于后续的 多次 查询**，最常见的是维护在**哈希表**中。

力扣上这种题目非常多，更多题目详见本章后续节。下面考虑几个经典问题：

**第一问：$a_{0},a_{1},...,a_{n-1}$上有没有一个区间，其和为 target 。**

计算前缀和数组 sums[i] 。当扫描到 i 时， $a_{0}, a_{1}, ..., a_{i-1}$ 的前缀和都已经求过了，在计算的过程中将前缀和维护在数据结构中，以便于后续的多次查询，本题在之后要查询前缀和的值是否存在，因此维护在unordered_set(哈希表)里。

求完当前值 a[i] 对应的前缀和 S[i+1], 在插入到 unordered_set 之前先问：`S[i+1] - target 在 unordered_set` 中是否出现。

如果出现，说明存在以 ii 结尾的某个区间，和为 target, 则找到答案。如果不出现，则没有以 ii 结尾的区间，和为 target，继续枚举 i + 1i+1。

上面的问题还可以有变种：

**第二问：$a_{0},a_{1},...,a_{n-1}$上有多少个区间，其和为 target** 。

按照第一问的思路，把 unordered_set 改成 unordered_map 就可以

参考题目：[560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

**第三问：$a_{0},a_{1},...,a_{n-1}$上有没有一个区间，其和大于/小于 target** 。

整体思路与第一问相同，但是维护前缀和的数据结构需要**从哈希表变为线段树**

参考题目：[327. 区间和的个数](https://leetcode-cn.com/problems/count-of-range-sum/)

**第四问: 一棵树上有没有某个路径，其和为 target**

这是第一问的树形版本，dfs（前序遍历）时，栈里存的是当前节点到根的链，这条链上的和可以作为前缀和维护在 unordered_map 里。从左子树跳到右子树的时候，左子树的所有节点对应的前缀和要先从 unordered_map 中删掉。

参考题目： **437. 路径总和 III**

数据结构维护前缀和相关练习题：

- `HashMap` 维护 (1)，键是前缀和（状态）的值，值为第一次出现时的索引
- `HashMap` 维护 (2)，键是前缀和（前缀状态）的值，值为出现次数
- `HashMap` 维护 (3)，键是前缀和模 K 的余数（可以理解为前缀状态，状态为前缀和模K）
- 前缀和（积）与后缀和（积）均需要
- 二维前缀和

## 背包问题

![416.分割等和子集1](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/20210117171307407.png)

### 01 背包

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

#### 二维dp数组01背包

依然动规五部曲分析一波。

##### 确定dp数组以及下标的含义

对于背包问题，有一种写法， 是使用二维数组，即**`dp[i][j]` 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。

只看这个二维数组的定义，大家一定会有点懵，看下面这个图：

![动态规划-背包问题1](https://img-blog.csdnimg.cn/20210110103003361.png)

**要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的**，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。

##### 确定递推公式

再回顾一下`dp[i][j]`的含义：**从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。

那么可以有两个方向推出来`dp[i][j]`，

- **不放物品i**：由`dp[i - 1][j]`推出，即背包容量为j，里面不放物品i的最大价值，此时`dp[i][j]`就是`dp[i - 1][j]`。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)
- **放物品i**：由`dp[i - 1][j - weight[i]]`推出，`dp[i - 1][j - weight[i]]` 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么`dp[i - 1][j - weight[i]] + value[i]` （物品i的价值），就是背包放物品i得到的最大价值

所以递归公式： `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`

##### dp数组如何初始化

**关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱**。

首先从`dp[i][j]`的定义出发，如果背包容量j为0的话，即`dp[i][0]`，无论是选取哪些物品，背包价值总和一定为0。如图：

![动态规划-背包问题2](https://img-blog.csdnimg.cn/2021011010304192.png)

在看其他情况。

状态转移方程 `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`; 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。

`dp[0][j]`，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。

那么很明显当 j < weight[0]的时候，`dp[0][j]` 应该是 0，因为背包容量比编号0的物品重量还小。

当j >= weight[0]时，`dp[0][j]` 应该是value[0]，因为背包容量放足够放编号0物品。

代码初始化如下：

```text
for (int j = 0 ; j < weight[0]; j++) {  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。
    dp[0][j] = 0;
}
// 正序遍历
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}
```

此时dp数组初始化情况如图所示：

![动态规划-背包问题7](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/20210110103109140.png)

`dp[0][j]` 和 `dp[i][0]` 都已经初始化了，那么其他下标应该初始化多少呢？

其实从递归公式： `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])` 可以看出`dp[i][j]` 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。

**初始-1，初始-2，初始100，都可以！**

但只不过一开始就统一把dp数组统一初始为0，更方便一些。

如图：

![动态规划-背包问题10](https://code-thinking.cdn.bcebos.com/pics/动态规划-背包问题10.jpg)

最后初始化代码如下：

```text
// 初始化 dp
vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}
```

**费了这么大的功夫，才把如何初始化讲清楚，相信不少同学平时初始化dp数组是凭感觉来的，但有时候感觉是不靠谱的**。

##### 确定遍历顺序

在如下图中，可以看出，有两个遍历的维度：物品与背包重量

![动态规划-背包问题3](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/2021011010314055.png)

那么问题来了，**先遍历 物品还是先遍历背包重量呢？**

**其实都可以！！ 但是先遍历物品更好理解**。

那么我先给出先遍历物品，然后遍历背包重量的代码。

```text
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j]; 
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

    }
}
```

**先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）**

例如这样：

```text
// weight数组的大小 就是物品个数
for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}
```

为什么也是可以的呢？

**要理解递归的本质和递推的方向**。

`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]`); 递归公式中可以看出`dp[i][j]`是靠`dp[i-1][j]`和`dp[i - 1][j - weight[i]]`推导出来的。

`dp[i-1][j]和dp[i - 1][j - weight[i]]` 都在`dp[i][j]`的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：

![动态规划-背包问题5](https://img-blog.csdnimg.cn/202101101032124.png)

再来看看先遍历背包，再遍历物品呢，如图：

![动态规划-背包问题6](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/20210110103244701.png)

**大家可以看出，虽然两个for循环遍历的次序不同，但是`dp[i][j]`所需要的数据就是左上角，根本不影响`dp[i][j]`公式的推导！**

但先遍历物品再遍历背包这个顺序更好理解。

**其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了**。

##### 举例推导dp数组

来看一下对应的dp数组的数值，如图：

![动态规划-背包问题4](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/20210118163425129.jpg)

最终结果就是`dp[2][4]`。

建议大家此时自己在纸上推导一遍，看看dp数组里每一个数值是不是这样的。

**做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！**

很多同学做dp题目，遇到各种问题，然后凭感觉东改改西改改，怎么改都不对，或者稀里糊涂就改过了。

主要就是自己没有动手推导一下dp数组的演变过程，如果推导明白了，代码写出来就算有问题，只要把dp数组打印出来，对比一下和自己推导的有什么差异，很快就可以发现问题了。

##### 代码实现

```
func test_2_wei_bag_problem1(weight, value []int, bagweight int) int {
	// 定义dp数组
	dp := make([][]int, len(weight))
	for i, _ := range dp {
		dp[i] = make([]int, bagweight+1)
	}
	// 初始化
	for j := bagweight; j >= weight[0]; j-- {
		dp[0][j] = dp[0][j-weight[0]] + value[0]
	}
	// 递推公式
	for i := 1; i < len(weight); i++ {
		//正序,也可以倒序
	    for j := 0; j <= bagweight; j++ {
	        if j < weight[i] {
	            dp[i][j] = dp[i-1][j]
	        } else {
	            dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])
	        }
	    }		
	}
	return dp[len(weight)-1][bagweight]
}

func max(a,b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	weight := []int{1,3,4}
	value := []int{15,20,30}
	test_2_wei_bag_problem1(weight,value,4)
}
```

#### 一维dp数组（滚动数组）

对于背包问题其实状态都是可以压缩的。

在使用二维数组的时候，递推公式：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`

**其实可以发现如果把`dp[i - 1]`那一层拷贝到`dp[i]`上，表达式完全可以是：`dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])`**

**与其把`dp[i - 1`]这一层拷贝到`dp[i]`上，不如只用一个一维数组了**，只用`dp[j]`（一维数组，也可以理解是一个滚动数组）。

这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。

读到这里估计大家都忘了 dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量。

**`dp[i][j]` 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。

一定要时刻记住这里i和j的含义，要不然很容易看懵了。

动规五部曲分析如下：

##### 确定dp数组的定义

在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

##### 一维dp数组的递推公式

`dp[j]`为 容量为j的背包所背的最大价值，那么如何推导`dp[j]`呢？

`dp[j]`可以通过`dp[j - weight[i]]`推导出来，`dp[j - weight[i]]`表示容量为`j - weight[i]`的背包所背的最大价值。

`dp[j - weight[i]] + value[i]` 表示 容量为 `j - 物品i重量 的背包 加上 物品i的价值`。（也就是容量为j的背包，放入物品i了之后的价值即：`dp[j]`）

此时`dp[j]`有两个选择，一个是取自己`dp[j]` 相当于 二维dp数组中的`dp[i-1][j]`，即不放物品i，一个是取`dp[j - weight[i]] + value[i]`，即放物品i，指定是取最大的，毕竟是求最大价值，

所以递归公式为：

```text
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

可以看出相对于二维dp数组的写法，就是把`dp[i][j]`中i的维度去掉了。

##### 一维dp数组如何初始化

**关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱**。

dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。

那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？

看一下递归公式：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`

dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。

**这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了**。

那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。

##### 一维dp数组遍历顺序

代码如下：

```text
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

**这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！**

二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。

为什么呢？

**倒序遍历是为了保证物品i只被放入一次！**。但如果一旦正序遍历了，那么物品0就会被重复加入多次！

举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15

如果正序遍历

dp[1] = dp[1 - weight[0]] + value[0] = 15

dp[2] = dp[2 - weight[0]] + value[0] = 30

此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。

为什么倒序遍历，就可以保证物品只放入一次呢？

倒序就是先算dp[2]

dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）

dp[1] = dp[1 - weight[0]] + value[0] = 15

所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。

**那么问题又来了，为什么二维dp数组历的时候不用倒序呢？**

因为对于二维dp，`dp[i][j]`都是通过上一层即`dp[i - 1][j]`计算而来，本层的`dp[i][j]`并不会被覆盖！

（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）

**再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？**

不可以！

因为**一维dp的写法，背包容量一定是要倒序遍历**（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。

倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。

（这里如果读不懂，就在回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！）

**所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！**，这一点大家一定要注意。

##### 举例推导dp数组

一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：

![动态规划-背包问题9](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/20210110103614769.png)

##### 代码

```
func test_1_wei_bag_problem(weight, value []int, bagWeight int) int {
	// 定义 and 初始化
	dp := make([]int,bagWeight+1)
	// 递推顺序
	for i := 0 ;i < len(weight) ; i++ {
		// 这里必须倒序,区别二维,因为二维dp保存了i的状态
		for j:= bagWeight; j >= weight[i] ; j-- {
			// 递推公式
			dp[j] = max(dp[j], dp[j-weight[i]]+value[i])
		}
	}
	//fmt.Println(dp)
	return dp[bagWeight]
}

func max(a,b int) int {
	if a > b {
		return a
	}
	return b
}


func main() {
	weight := []int{1,3,4}
	value := []int{15,20,30}
	test_1_wei_bag_problem(weight,value,4)
}
```

### 完全背包

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

同样leetcode上没有纯完全背包问题，都是需要完全背包的各种应用，需要转化成完全背包问题，所以我这里还是以纯完全背包问题进行讲解理论和原理。

在下面的讲解中，我依然举这个例子：

背包最大重量为4。

物品为：

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

**每件商品都有无限个！**

问背包能背的物品最大价值是多少？

01背包和完全背包唯一不同就是体现在遍历顺序上，所以本文就不去做动规五部曲了，我们直接针对遍历顺序经行分析！

关于01背包我如下两篇已经进行深入分析了：

- [动态规划：关于01背包问题，你该了解这些！(opens new window)](https://programmercarl.com/背包理论基础01背包-1.html)
- [动态规划：关于01背包问题，你该了解这些！（滚动数组）(opens new window)](https://programmercarl.com/背包理论基础01背包-2.html)

首先在回顾一下01背包的核心代码

```cpp
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。

而**完全背包的物品是可以添加多次的，所以要从小到大去遍历**，即：

```cpp
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

至于为什么，我在[动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)](https://programmercarl.com/背包理论基础01背包-2.html)中也做了讲解。

dp状态图如下：

![动态规划-完全背包](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/20210126104510106.jpg)

相信很多同学看网上的文章，关于完全背包介绍基本就到为止了。

**其实还有一个很重要的问题，为什么遍历物品在外层循环，遍历背包容量在内层循环？**

这个问题很多题解关于这里都是轻描淡写就略过了，大家都默认 遍历物品在外层，遍历背包容量在内层，好像本应该如此一样，那么为什么呢？

难道就不能遍历背包容量在外层，遍历物品在内层？

看过这两篇的话：

- [动态规划：关于01背包问题，你该了解这些！(opens new window)](https://programmercarl.com/背包理论基础01背包-1.html)
- [动态规划：关于01背包问题，你该了解这些！（滚动数组）(opens new window)](https://programmercarl.com/背包理论基础01背包-2.html)

就知道了，01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。

**在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓！**

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**

因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。

遍历物品在外层循环，遍历背包容量在内层循环，状态如图：

![动态规划-完全背包1](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/20210126104529605.jpg)

遍历背包容量在外层循环，遍历物品在内层循环，状态如图：

![动态规划-完全背包2](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/20210729234011.png)

看了这两个图，大家就会理解，完全背包中，两个for循环的先后循序，都不影响计算dp[j]所需要的值（这个值就是下标j之前所对应的dp[j]）。

先遍历背包在遍历物品，代码如下：

```cpp
// 先遍历背包，再遍历物品
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
    cout << endl;
}
```

### 背包递推公式

问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ，对应题目如下：

- [动态规划：416.分割等和子集(opens new window)](https://programmercarl.com/0416.分割等和子集.html)
- [动态规划：1049.最后一块石头的重量 II(opens new window)](https://programmercarl.com/1049.最后一块石头的重量II.html)

问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，对应题目如下：

- [动态规划：494.目标和(opens new window)](https://programmercarl.com/0494.目标和.html)
- [动态规划：518. 零钱兑换 II(opens new window)](https://programmercarl.com/0518.零钱兑换II.html)
- [动态规划：377.组合总和Ⅳ(opens new window)](https://programmercarl.com/0377.组合总和Ⅳ.html)
- [动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)](https://programmercarl.com/0070.爬楼梯完全背包版本.html)

问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); ，对应题目如下：

- [动态规划：474.一和零(opens new window)](https://programmercarl.com/0474.一和零.html)

问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); ，对应题目如下：

- [动态规划：322.零钱兑换(opens new window)](https://programmercarl.com/0322.零钱兑换.html)
- [动态规划：279.完全平方数(opens new window)](https://programmercarl.com/0279.完全平方数.html)

### 遍历顺序

#### [#](https://programmercarl.com/背包总结篇.html#_01背包)01背包

在[动态规划：关于01背包问题，你该了解这些！ (opens new window)](https://programmercarl.com/背包理论基础01背包-1.html)中我们讲解二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

和[动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)](https://programmercarl.com/背包理论基础01背包-2.html)中，我们讲解一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。

**一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！**

#### [#](https://programmercarl.com/背包总结篇.html#完全背包)完全背包

说完01背包，再看看完全背包。

在[动态规划：关于完全背包，你该了解这些！ (opens new window)](https://programmercarl.com/背包问题理论基础完全背包.html)中，讲解了纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

相关题目如下：

- 求组合数：[动态规划：518.零钱兑换II(opens new window)](https://programmercarl.com/0518.零钱兑换II.html)
- 求排列数：[动态规划：377. 组合总和 Ⅳ (opens new window)](https://mp.weixin.qq.com/s/Iixw0nahJWQgbqVNk8k6gA)、[动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)](https://programmercarl.com/0070.爬楼梯完全背包版本.html)

如果求最小数，那么两层for循环的先后顺序就无所谓了，相关题目如下：

- 求最小数：[动态规划：322. 零钱兑换 (opens new window)](https://programmercarl.com/0322.零钱兑换.html)、[动态规划：279.完全平方数(opens new window)](https://programmercarl.com/0279.完全平方数.html)

**对于背包问题，其实递推公式算是容易的，难是难在遍历顺序上，如果把遍历顺序搞透，才算是真正理解了**。

### [#](https://programmercarl.com/背包总结篇.html#总结)总结

**这篇背包问题总结篇是对背包问题的高度概括，讲最关键的两部：递推公式和遍历顺序，结合力扣上的题目全都抽象出来了**。

**而且每一个点，我都给出了对应的力扣题目**。

最后如果你想了解多重背包，可以看这篇[动态规划：关于多重背包，你该了解这些！ (opens new window)](https://programmercarl.com/背包问题理论基础多重背包.html)，力扣上还没有多重背包的题目，也不是面试考察的重点。

如果把我本篇总结出来的内容都掌握的话，可以说对背包问题理解的就很深刻了，用来对付面试中的背包问题绰绰有余！

背包问题总结：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/背包问题1.jpeg)

## 题目

[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

