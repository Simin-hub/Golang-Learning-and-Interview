# 基础数据类型

## 动态语言、静态语言、强类型语言、弱类型语言

[参考](http://c.biancheng.net/view/8803.html)

**静态/动态语言**应该放在一起提及，它们是从同一种维度来评价类型系统；而**强类型/弱类型语言**应该放在一起提及，它们是从另外一种不同的维度来评价类型系统。

**静态语言并不意味着强类型，动态语言也不意味着弱类型**，一种编程语言的类型系统可以是静态/动态和强/弱的任意组合，例如：

- C/C++/Java 是静态语言 + 强类型；
- JavaScript/PHP 是动态语言 + 弱类型；
- Python 是动态语言 + 强类型。

静态/动态语言，从「**如何得到数据的类型**」这一维度来评价类型系统。

强类型/弱类型语言，从**编程语言如何处理运算过程中的值**进行判定。

### 什么是数据类型？

在很多编程语言（比如 C/C++、Java、C# 等）中，定义变量时除了需要指明变量的名字，还需要告诉计算机它是什么类型，比如简单的整数、浮点数、字符串，还有复杂的类、结构体、数组。

编程语言中的数据最终都要放到内存中，**在内存中存取数据**要明确三件事情：**数据存储地址、数据的长度以及数据的处理方式**。

- 数据存储地址决定了数据放在哪里；
- 数据长度决定了当前数据使用了多少个字节的内存；
- 数据处理方式不仅让计算机能够正确转换数据的内容，不至于导致“乱码”，还让计算机知道如何处理基于该数据的各种运算，比如加减乘除。

**变量名不仅仅是为数据起了一个好记的名字，还告诉我们数据的存储地址，使用数据时，只要提供变量名即可**，**变量名会自动转换成数据在内存中的地址**。而**数据类型则指明了数据的长度和处理方式**，它确定了除地址以外的其它所有信息。

诸如`int n;`、`char c;`、`float money;`这样的变量定义形式就确定了数据在内存中的所有要素。

每种编程语言都有一个数据类型系统，没有它的话，计算机将不知道如何处理我们程序中的数据，这包括：

- 计算机不知道数据的长度，不知道该操作多少个字节；
- 计算机不知道如何将值存储到内存，不知道如何解析内存中的值；
- 计算机不知道如何运算数据。

我们可以在不了解底层类型系统的情况下开始编程，这就是高级语言的美妙之处。但是，了解我们程序中的数据将给编程带来巨大的优势，如下所示：

#### 1) 可以更少地使用内存资源

当数据量比较大时，采用长度较小且够用的数据类型，将节省成百上千个字节的内存空间。

#### 2) 可以读懂报错信息

比如将两份数据相加时可能报错，因为其中一个是数字类型，一个是字符串类型，虽然人类眼睛看起来都是数字，但是计算机不允许对字符串类型执行相加操作，这告诉我们，不能使用引号来包围数字。

#### 3) 改变规则

一旦你知道数据类型是如何工作的，你就可以像电影《黑客帝国》中的 Neo 一样，知道如何改变规则。比如将一个字符和一个整数相加，就可以得到另一个字符。

### 静态类型语言和动态类型语言

静态类型和动态类型应该放在一起提及，它们从「**如何得到数据的类型**」这一维度来评价类型系统。

#### 1) 静态类型语言

静态类型指的是**在创建一份数据（变量、参数、返回值等）时需要显式指明该数据的类型**。通常情况下，这些数据的类型一旦被定义，**在程序的整个生命周期也不再改变**。

请看下面的一个例子：

```
int myNumber = 42;             //整数类型
string name = "Rocky Balboa";  //字符串类型
final double PI = 3.141592;    //双精度浮点类型
// add() 函数包含两个整数类型的参数，返回值也是整数类型
public int add(int a, int b) {    return a + b;}
```

这是一段 Java 代码，它定义了几个变量，以及一个求和函数。如您所见，我们已经明确地指明了要处理的数据类型，包括整数、双精度浮点数、字符串。如果没有给编译器这些提示，编译器将不知道如何处理 myNumber，它只是一个对我们有意义的名称，但是计算机不理解它。

静态类型的编程语言有很多，常见的有 C/C++、Java、C#、Go 等。

#### 2) 动态类型语言

让我们再对比一下动态类型的语言，请看下面的例子：

```
$myNumber = 42;           //整数类型
$name = "Rocky Balboa";   //字符串类型
$PI = 3.141592;           //单精度浮点类型// 
add() 包含两个参数和一个返回值function add($a, $b) {    return $a + $b;}
```

这是一段 PHP 代码，如您所见，我们并**没有使用任何明确的数据类型**，这就是一种典型的动态类型语言。

动态类型的编程语言在创建数据时往往不需要指明该数据的类型，而且**数据的类型也会随着值的改变而改变，给数据赋予不同的值，数据将得到不同的类型**。

有的读者可能会问，不给数据指明类型，编程语言是如何知道它的类型的呢？编程语言会根据赋予数据的值进行猜测或者推断。对于上面的第一行代码，PHP 知道 42 是一个整数，将 42 赋值给变量 $myNumber，PHP 也会推断出 $myNumber 是一个整数类型。

add() 函数包含的参数类型，会根据调用 add() 时传递的值进行推断；add() 函数包含的返回值类型，会根据`$a + $b`的运算结果进行推断。这意味着，add() 可以接受两个整数并返回一个整数，或者接受两个浮点数并返回一个浮点数。

**对动态类型语言，类型是推断出来的，甚至可以在程序运行期间更改**。我们可以给上面的程序中增加一行代码，把`"c.biancheng.net"`赋值给 $myNumber 变量，这样 PHP 将把 $myNumber 变量切换为字符串类型。

常见的动态类型语言有 JavaScript、PHP、Python、Ruby 等。

#### 静态类型和动态类型各有什么优势？

**对于静态类型语言，我们需要预先明确地告诉编译器要处理的数据的类型，这样在程序部署之前就能发现代码中的错误或者疏忽**。比如我们将一个变量定义为整数，将另一个变量定义为字符串，如果我们尝试将两个变量相加，那么编译器在编译期间可能就会捕获这种语法错误，并且不会让我们完成程序的构建。

这很好，因为越早发现错误，您的代码就越强大，您将来修复它的成本就越低。在部署之前修复问题，要比部署之后修复问题容易得多。

那么，使用静态类型是不是就一定正确呢？好吧，使用静态类型的负担就是，在使用数据之前你必须明确地将它定义好。你必须输入更多的代码，你必须事先知道正在使用的数据的类型，你必须知道你的操作过程中会发生什么。

然而由于我们的疏忽或者知识缺陷，这有时候是比较困难的。例如在 C/C++ 中，你必须知道`1/3`得到的是整数 0，而不是浮点数 0.3333...，这对初学者来说是一个坑。

在这方面，动态类型语言就为我们提供了更多灵活性，程序员经常称动态语言“更具表现力”。例如在 PHP 中，`1/3`将会得到 0.3333...，这在很多时候都是我们期望的结果。

然而问题在于，解释器有时候会对数据类型做出错误的猜测，你必须知道这种情况，否则这将成为一个潜在的危险，因为解释器不会给出错误提示。

由于我们不能捕获所有的潜在危险，因此使用动态语言编写的代码往往更加脆弱，也更容易出错。

**动态语言中的数据类型通常在程序运行期间才能确定，这使得程序在被部署到生产环境之前很难捕获太多错误**。程序可能在你的本地机器上正常工作，但是生产环境可能略有不同，解释器就会产生一些不同的猜测，这将导致潜在的风险。

JavaScript 被认为是一种典型的动态语言。随着 TypeScript（JavaScript 的超集）的诞生，程序员也想在定义变量时能够声明它的类型，以使 JavaScript 变得更加静态。

JavaScript 臭名昭著的地方之一就是在处理数据及其类型时会做一些糟糕的猜测。随着 JavaScript 越来越流行，人们已经不限于在浏览器上使用它了，大名鼎鼎的 Node.js 使得人们可以在脱离浏览器，直接在机器上运行 JavaScript。此时程序员意识到为 JavaScript 增加静态类型的好处，这样能够消除 JavaScript 在处理数据类型时所做的一些错误猜测。

将动态语言 JavaScript 变得更像静态语言，可以及时发现错误，并生成更加健壮的代码。在 Node.js 的帮助下，JavaScript 越来越多地渗透到服务器端编程，让 JavaScript 变得静态就显得尤为重要。

#### 总结

静态语言为我们提供了一个更加严格的编程环境，并且通常会生成更加健壮的代码。动态语言为编写代码带来了灵活性，同时也提高了编写代码的效率，但是如果你不注意数据的类型，可能就会导致代码更容易出错。

### 强类型语言和弱类型语言

正如前面提到的，人们经常混淆静态/动态类型和强/弱类型的概念，倾向于将静态类型等同于强类型，将动态类型等同于弱类型，实际上这是不对的。

**强/弱类型指的是编程语言如何处理运算过程中的值**。当值的类型不符合运算规则时，编程语言究竟是做出一些猜测，临时转换值的类型以帮助人们解决问题，还是停止运行，提醒人们不应该这样做？

#### 1) 强类型语言

让我们从一个例子入手解释一下：

```
int main() {
    int a = 5;
    std::string b = "5";

    // 编译器会报错
    std::cout << (a + b);
    return 0;
}
```

这是一段 C++ 代码，我们尝试将一个整数和一个字符串相加，很显然这是没有意义的，编译器会停止构建，并抛出一条错误信息。

在这个例子中，我们将变量 b 定义为字符串类型，但是在使用 b 的时候，我们对它施加了一种不匹配的运算（字符串类型不支持算数求和运算）。

C++ 也可以在后台默默地做一些猜测，临时将字符串`"5"`转换成整数`5`，这样以上代码就能行得通；但是 C++ 并不会这样做，它会立即标记此处的问题（也即报错），并放弃构建，交给程序员自己处理。

这就是**强类型语言的典型特征，它们不会处理与类型定义明显矛盾的运算，而是把它标记为一个问题，并作为错误抛出**。通常人们认为 C/C++、Java、C#、Python、Go 都是强类型语言，它们都不允许上述代码中的行为。

现在虽然有办法削弱 C++ 的强类型系统，让 C++ 能够容忍一些与类型定义不匹配的运算，但是这超出了本文的讨论范围，所以不再赘述。

#### 2) 弱类型语言

和强类型语言不一样，**当我们执行一些与类型定义不匹配的运算时，弱类型语言尝试提供帮助，它可能会临时转换值的类型，让它符合当前运算**。

下面的例子中，我们使用 JavaScript 代码执行与上述 C++ 代码类似的操作：

```
var a = 5;
var b = "5";

console.log( a+b );
```

如果你对 JavaScript 特性有所了解，就会知道这段代码不会报错，而是正常运行，它会在控制台上显示 10，这也许正是你所期望的。

对于相加运算，如果`+`两边的值的类型不一样，那么 JavaScript 将尝试转换其中一个值的类型，让它和另一个值的类型相同，然后再进行运算，并给出运算结果。这里之所以显示 10，是因为 JavaScript 将变量 b 的值转换为整数类型，得到一个数字 5，然后再和变量 a 相加，结果就是 10。

PHP 也是一种典型的弱类型语言，对 PHP 执行类似的操作，它的结果是怎样的呢？请看下面的代码：

```
$a = 5;
$b = "5";

echo $a + $b;
```

运行结果：
55

你对这个结果可能会比较惊讶，认为它和预期的不一样，这是因为 PHP 对值的类型进行了不同的转换。PHP 会将变量 `$a` 的值转换为字符串类型，然后再和变量 `$b` 的字符串拼接起来，得到一个新的字符串。

字符串拼接工作非常简单，就是将字符串中的内容直接连接起来。

如您所见，PHP 和 JavaScript 虽然都是弱类型语言，但是当它们遇到和类型定义明显矛盾的运算时，可能会做出不同的猜测或者转换，这种猜测有时让人匪夷所思。

类型系统的“强/弱”指的是当编程语言遇到与类型定义不匹配的运算时，尝试猜测或者转换的力度/程序。它不是一条明确的界限，而是一个范围。

- **强类型语言在遇到与类型定义明显矛盾的运算时，一般会当做一种语法错误，而不会尝试对值的类型进行转换。**
- **弱类型语言恰好相反，会猜测程序员的意图，并对其中一些值的类型进行转换，以让程序继续执行。**

强/弱类型是一个相对概念，将两种语言放在一起对比时，才更容易发现孰强孰弱。

#### 强类型和弱类型各有什么优势？

**强类型语言是严谨的，它要确保程序员明确地知道自己在做什么**。如果发生错误，**强类型语言认为这是程序员不了解当前的运算规则导致的，或者程序员对正在处理的问题含混不清**。

例如，将整数`5`和字符串`"5"`相加对计算机来说是一种没有意义的操作，如果你没有意识到，那么强类型语言就明确地提示你。强类型语言会强迫你必须了解运算规则，并明确地告诉计算机你想做什么（通常使用强制类型转换），不能含混不清。

强类型使得程序被部署到生产环境时更加强壮，不易出错；但是，我们需要付出更多成本，这包括花费更所时间编写代码，以及解决更多细枝末节的问题。

相反的，弱类型语言消除了强类型语言的严格性，在较大程度上允许程序构建并正常运行，因此弱类型语言更有灵活性和表达性。

弱类型语言不利的一方面是，它可能错误地猜测程序员的意图，并得到不被期望的运行结果。

JavaScript 是一种弱类型语言（恰好也是动态语言），但是可以使用 TypeScript 增强，以使程序更加健壮。TypeScript 改变了类型系统，它允许程序员在定义变量时增加显式类型声明，这样 JavaScript 就能获得强类型语言的好处，在编译时捕获更多错误，并防止一些模糊的猜测被带入到生产环境。

此外，支持 TypeScript 的编辑器也可以你编写代码时就给出错误提示，VS Code 编辑器就是一个典型的例子。

#### 强度等级

现在我们已经比较深入地研究了强类型和弱类型，但是还有一点需要注意，与静态/动态之间存在一条明确的界限不同，语言的强/弱是一个范围，语言可以表现出不同程序的强/弱。有些文章说 C++ 是强类型，也有文章说 C++ 是弱类型，这就是原因所在。

让编程语言的强/弱变成一个范围的原因是，有些语言提供了一些工具或特性来帮助及时地转换类型，比如 C/C++ 中的`void*`指针，它可以指向不同类型的数据，并随时准备转换成某种具体类型的数据。

人们通常认为，Java 拥有比 C/C++ 更强的类型，而 C/C++ 显然又比 JavaScript 拥有更强的类型。

在十年的编程生涯中，我发现了解编程语言强/弱的每一个细微差别并不那么重要，只要你了解一些基本知识，并能分辨出强/弱之间的差异，就能为给定的项目和要求选择合适的编程语言。

### 选择合适的语言

为项目选择编程语言时的考虑因素有很多，你可能有很多理由选择某种语言，也有很多理由拒绝另外的语言。但是，类型系统往往是人们考虑的次要因素，它被更重要的因素掩盖，例如：

- 开发人员对某种语言是否熟悉；
- 哪种语言提供了更强大的、能适用于当前项目的功能；
- 是否拥有提高开发效率的工具，比如周边框架（库）、强大的 IDE 等。

处于上下游链条的关键位置的项目，往往要求内存严格、高效，并且要尽早发现错误，如果你正在开发这样的项目，你可能需要频繁查看内存中的内容，此时使用静态语言更有帮助。

很多关键的算法不应该让编程语言做出过多猜测，而且指令要严格，不能含混，此时应该考虑强类型语言。

很多 3A 大作游戏就使用静态+强类型语言，例如 C++。

如果你希望快速且灵活地开发完成一个项目，并且不受太多约束，那么动态+弱类型语言将是不错的选择。比如，很多中小型网站就使用 PHP 开发。

某些动态的强类型语言也能提供足够的便利性，比如 Python，很多人使用它来开发小工具，或者 Web 项目，或者机器学习项目。

### 总结

本文尽量全面地介绍了动态/静态和强/弱之间的基本差异，并对它们的优缺点进行了对比，当涉及类型系统时，我认为你应该知道如何为你的项目选择合适的语言了。

如果你觉得本文信息量丰富，不能 Get 所有细节，那么我希望你铭记两个观点：

- 静态不一定意味着强，动态也不一定以为着弱，一种编程语言可以是静态/动态和强/弱的任意组合；
- 强和弱之间没有明确的界限，它是一个范围，是一个相对概念，将两种语言对比时才更容易发现孰强孰弱。


下图使用象限示意图汇总了常用编程语言的不同分类：



![常用编程语言的静态/动态/强/弱类型分类](http://c.biancheng.net/uploads/allimg/210713/1-210G3130955C3.png)

## 数据类型

Method 、Bool 、String 、Array 、Slice 、Struct 、Pointer 、Function 、Interface 、Map 、Channel

### 值类型和引用类型

- 值类型分别有：int系列、float系列、bool、string、array和struct体
- 引用类型有：指针pointer、slice切片、管道channel、接口interface、map、function等

值类型的特点是：变量直接存储值，内存通常在栈中分配

引用类型的特点是：变量存储的是一个地址，这个地址对应的空间里才是真正存储的值，内存通常在堆中分配

## 全局变量和局部变量

作用域和生命期有着本质的区别：

- **作用域是编译期概念**
- **生命期是运行时概念**

**局部变量**

- 在C语言中写在{}中或者函数中或者函数的形参, 就是局部变量
- Go语言中的局部变量和C语言一样

**全局变量**

- 在C语言中写在函数外面的就是全局变量
- Go语言中的全局变量和C语言一样

**局部变量和全局变量的作用域**

- 在C语言中局部变量的作用域是**从定义的那一行开始, 直到遇到 } 结束或者遇到return为止**
- Go语言中局部变量的作用域和C语言一样
- 在C语言中全局变量的作用域是从定义的那一行开始, 直到文件末尾为止
- Go语言中的全局变量, **只要定义了, 在定义之前和定义之后都可以使用**

**局部变量和全局变量的生命周期**

- 在C语言中**局部变量, 只有执行了才会分配存储空间, 只要离开作用域就会自动释放, C语言的局部变量存储在栈区**
- Go语言局部变量的生命周期和C语言一样
- 在C语言中**全局变量, 只要程序一启动就会分配存储空间, 只有程序关闭才会释放存储空间, C语言的全局变量存储在静态区(数据区)**
- Go语言全局变量的生命周期和C语言一样

**局部变量和全局变量的注意点**

- 在C语言中相同的作用域内, 不能出现同名的局部变量
- Go语言和C语言一样, **相同的作用域内, 不能出现同名的局部变量**

```
package main
import "fmt"
func main() {
    var num int; // 局部变量
    //var num int; // 报错,不能出现同名局部变量
}
```

- 在C语言中相同的作用域内, 可以出现同名的全局变量
- 在Go语言中**相同的作用域内, 不能出现同名的全局变量**
  例：

```
package main
import "fmt"
var value int // 全局变量
//var value int // 报错,不能出现同名全局变量
func main() {
}
```

**特殊点**

- 在C语言中**局部变量**没有初始化存储的是垃圾数据, 在Go语言中局部变量没有初始化, 会默认初始化为0
- 在C语言中**全局变量**没有初始化存储的是0, Go语言和C语言一样
- 在Go语言中, 如果定义了一个**局部变量**, 但是**没有使用**这个局部变量, **编译会报错**
- 在Go语言中, 如果定义了一个**全局变量**, 但是**没有使用**这个全局变量, **编译不会报错**

**注意点**

- 相同的作用域内, 无论是全局变量还是局部变量, 都不能出现同名的变量
- 变量离开作用域就不能使用
- 局部变量如果没有使用, 编译会报错, 全局变量如果没有使用, 编译不会报错
- **:=只能用于局部变量, 不能用于全局变量**

```
num := 666  //只能用于局部变量
fmt.Printf("%d\n", num)
```

- :=如果用于同时定义多个变量, 会有退化赋值现象，如果通过:=定义多个变量, 但是**多个变量中有的变量已经在前面定义过了, 那么只会对没有定义过的变量执行:=, 而定义过的变量只执行=操作**

```
num2 := 123
num2, value2 := 456, 789
fmt.Printf("%d, %d", num2, value2)        //456, 789
```

## 标志符的可见性

> Go的标志符，这个翻译觉得怪怪的，不过还是按这个起了标题，可以理解为Go的变量、类型、字段等。这里的可见性，也就是说那些方法、函数、类型或者变量字段的可见性，比如哪些方法不想让另外一个包访问，我们就可以把它们声明为非公开的；如果需要被另外一个包访问，就可以声明为公开的，和Java语言里的作用域类似。
>
> 在Go语言中，没有特别的关键字来声明一个方法、函数或者类型是否为公开的，Go语言提供的是**以大小写的方式进行区分的，如果一个类型的名字是以大写开头，那么其他包就可以访问；如果以小写开头，其他包就不能访问**。

```
package common

type count int
package main

import (
    "flysnow.org/hello/common"
    "fmt"
)

func main() {
    c:=common.count(10)
    fmt.Println(c)
}
```

这是一个定义在common包里的类型count,因为它的名字以小写开头，所以我们不能在其他包里使用它，否则就会报编译错误。

```
./main.go:9: cannot refer to unexported name common.count
```

因为这个类型没有被导出，如果我们改为大写，就可以正常编译运行了，大家可以自己试试。

现在这个类型没有导出，不能使用，现在我们修改下例子，增加一个函数，看看是否可行。

```
package common

type count int

func New(v int) count {
    return count(v)
}
func main() {
    c:=common.New(100)
    fmt.Println(c)
}
```

这里我们在common包里定义了一个导出的函数New ，该函数返回一个count类型的值。New函数可以在其他包访问，但是count类型不可以，现在我们在main包里调用这个New函数，会发现是可以正常调用并且运行的，但是有个前提，必须使用:=这样的操作符才可以，因为它可以推断变量的类型。

这是一种非常好的能力，试想，我们在和其他人进行函数方法通信的时候，只需约定好接口，就可以了，至于内部实现，使用方是看不到的，隐藏了实现。

```
package common

import "fmt"

func NewLoginer() Loginer{
    return defaultLogin(0)
}

type Loginer interface {
    Login()
}

type defaultLogin int

func (d defaultLogin) Login(){
    fmt.Println("login in...")
}
func main() {
    l:=common.NewLoginer()
    l.Login()
}
```

以上例子，我们对于函数间的通信，通过Loginer接口即可，在main函数中，使用者只需要返回一个Loginer接口，至于这个接口的实现，使用者是不关心的，所以接口的设计者可以把defaultLogin类型设计为不可见，并让它实现接口Loginer，这样我们就隐藏了具体的实现。如果以后重构这个defaultLogin类型的具体实现时，也不会影响外部的使用者，极为方便，这也就是面向接口的编程。

假如一个导出的结构体类型里，有一个未导出的字段，会出现怎样的问题。

```
type User struct {
    Name string
    email string
}
```

当我们在其他包声明和初始化User的时候，字段email是无法初始化的，因为它没有导出，无法访问。此外，一个导出的类型，包含了一个未导出的方法也一样，也是无法访问的。

我们再扩展，导出和未导出的类型相互嵌入，会有什么什么样的发现？

```
type user struct {
    Name string
}

type Admin struct {
    user
}
```

被嵌入的user是未导出的，但是它的外部类型Admin是导出的，所以外部可以声明初始化Admin。

```
func main() {
    var ad common.Admin
    ad.Name="张三"
    fmt.Println(ad)
}
```

这里因为user是未导出的，所以我们不能再使用字面值直接初始化user了，所以只能先定义一个Admin类型的变量，再对Name字段初始化。这里Name可以访问是因为它是导出的，在user嵌入到Admin中时，它已经被提升为Admin的字段，所以它可以被访问。

如果我们还想使用:=操作符怎么做呢？

```
ad:=common.Admin{}
```

字面值初始化的时候什么都不做就好了，因为user未导出，所以我们不能直接使用字面值初始化Name字段。

还有要注意的是，因为user未导出，所以我们不能通过外部类型访问内部类型了，也就是说ad.user这样的操作，都会编译不通过。

最后，我们做个总结，导出还是未导出，是通过名称首字母的大小写决定的，它们决定了是否可以访问，也就是标志符的可见性。

对于.操作符的调用，比如调用类型的方法，包的函数，类型的字段，外部类型访问内部类型等等，我们要记住：**.操作符前面的部分导出了，.操作符后面的部分才有可能被访问；如果.前面的部分都没有导出，那么即使.后面的部分是导出的，也无法访问。**

| 例子 |可否访问 |
|---|---|
|Admin.User.Name | 是 |
|Admin.User.name | 否 |
|Admin.user.Name | 否 |
|Admin.user.name | 否|

以上表格中Admin 为外部类型,User(user)为内部类型,Name(name)为字段，以此来更好的理解最后的总结，当然方法也适用这个表格。

## 常量

go语言常量要是编译时就能确定的数据。在 Go 语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型；

**存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型**。

## string类型

### 底层数据结构

string我们看起来是一个整体，但是本质上是一片连续的内存空间，我们也可以将它理解成一个由字符组成的数组，相比于切片仅仅少了一个Cap属性。

在运行中, Go `string` 值传递的是 [reflect.StringHeader](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fgo1.16.7%2Fsrc%2Freflect%2Fvalue.go%23L1976), 内存大小是16字节. 即再长的字符串传递的都是16字节.

字符串其实是一个结构体，因此字符串的赋值操作也就是`reflect.StringHeader`结构体的复制过程，并不会涉及底层字节数组的复制

由于Go语言的源代码要求是UTF8编码，导致Go源代码中出现的字符串面值常量一般也是UTF8编码的。源代码中的文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。

```go
type StringHeader struct {  // 16 字节
	Data uintptr
	Len  int
}
```

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bccf540ddf44adf93f7e243204d56fe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

1、相比于切片**少了一个容量的cap字段**，就意味着**string是不能发生地址空间扩容**；

2、可以把string当成一个**只读**的切片类型；

3、**string本身的切片是只读**的，所以**不会直接向字符串直接追加元素改变其本身的内存空间**，所有在字符串上的写入操作都是通过拷贝实现的。

### 字符串无法直接修改

Go 语言的字符串无法直接修改每一个字符元素，只能通过重新构造新的字符串并赋值给原来的字符串变量实现。

#### 为什么不可修改

一个[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)是一个**不可改变的字节序列**，字符串可以包含**任意的数据**，但是通常是用来包含可读的文本，字符串是 UTF-8 字符的一个序列(**当字符为 ASCII 码表上的字符时则占用 1 个字节，其它字符根据需要占用 2-4 个字节**)。

由于该编码对占用字节长度的不定性，在Go语言中字符串也可能根据需要占用 1 至 4 个字节，这与其它编程语言如 C++、Java 或者 Python 不同(Java 始终使用 2 个字节)。**Go语言这样做不仅减少了内存和硬盘空间占用**，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。

`string` 类型是不包含内存空间，只有一个内存的指针。

GO 中的 `string`类型一般是指向字符串字面量

字符串字面量存储位置是在虚拟内存分区的**只读段**上面，而不是堆或栈上

**因此，GO 的 `string` 类型不可修改的**

### 字符串转成byte数组，会发生内存拷贝吗？

[参考](https://mp.weixin.qq.com/s/qmlPuGVISx8NYp2b9LrqnA)

字符串转成切片，会产生拷贝。严格来说，只要是发生**类型强转**都会发生内存拷贝。那么问题来了。

频繁的内存拷贝操作听起来对性能不大友好。**有没有什么办法可以在字符串转成切片的时候不用发生拷贝呢？**

### []byte转string

`src/runtime/string.go`

```
type stringStruct struct {
	str unsafe.Pointer
	len int
}

func slicebytetostring(buf *tmpBuf, b []byte) (str string) {
	l := len(b)
	if l == 0 {
		return ""
	}
	if l == 1 {
		stringStructOf(&str).str = unsafe.Pointer(&staticbytes[b[0]])
		stringStructOf(&str).len = 1
		return
	}
	var p unsafe.Pointer
	// 判断传入的缓冲区大小，决定是否重新分配内存
	if buf != nil && len(b) <= len(buf) {
		p = unsafe.Pointer(buf)
	} else {
		// 重新分配内存
		p = mallocgc(uintptr(len(b)), nil, false)
	}
	// 将输出的str转化成stringStruct结构
	// 并且赋值
	stringStructOf(&str).str = p
	stringStructOf(&str).len = len(b)
	// 将[]byte中的内容，复制到内存空间p中
	memmove(p, (*(*slice)(unsafe.Pointer(&b))).array, uintptr(len(b)))
	return
}

// 转换成
func stringStructOf(sp *string) *stringStruct {
	return (*stringStruct)(unsafe.Pointer(sp))
}
```

总结下流程：

1、根据传入的内存大小，判断是否需要分配重新分配内存；

2、构建stringStruct，分类长度和内存空间;

3、赋值[]byte里面的数据到新构建stringStruct的内存空间中。

### string转[]byte

```
src/runtime/string.go
func stringtoslicebyte(buf *tmpBuf, s string) []byte {
	var b []byte
	if buf != nil && len(s) <= len(buf) {
		*buf = tmpBuf{}
		b = buf[:len(s)]
	} else {
		b = rawbyteslice(len(s))
	}
	copy(b, s)
	return b
}

// 为[]byte重新分配一段内存
func rawbyteslice(size int) (b []byte) {
	cap := roundupsize(uintptr(size))
	p := mallocgc(cap, nil, false)
	if cap != uintptr(size) {
		memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size))
	}

	*(*slice)(unsafe.Pointer(&b)) = slice{p, size, int(cap)}
	return
}
```

1、判断传入的缓存区大小，如果内存够用就使用传入的缓冲区存储 []byte；

2、传入的缓存区的大小不够，调用 `runtime.rawbyteslice`创建指定大小的[]byte；

3、将string拷贝到切片。

### 字符串的拼接

#### +方式进行拼接

```go
func main() {
	s := "hai~"
	s += "hello world"
	fmt.Println(s)
}
```

一个拼接语句的字符串编译时都会被存放到一个切片中，**拼接过程需要遍历两次切片**，第一次遍历获取总的字符串长度，据此申请内存，第二次遍历会把字符串逐个拷贝过去。

所以，这种方式拼接只要性能问题是在copy上，适合短小的、常量字符串（明确的，非变量）。

#### fmt 拼接

```go
func main() {
	s := fmt.Sprintf("%s%s%d", "hello", "world", 2021)
	fmt.Println(s)
}
```

fmt可以方便对各种类型的数据进行拼接，转换成string,具体详见[printf的用法](https://github.com/boilingfrog/Go-POINT/blob/master/golang/printf/main.go)

#### Join 拼接

```go
func main() {
	var s []string

	s = append(s, "hello")
	s = append(s, "world")

	fmt.Println(strings.Join(s, ""))
}
```

#### buffer 拼接

```go
func main() {
	var b bytes.Buffer
	b.WriteString("hello")
	b.WriteString("world")
	fmt.Println(b.String())
}
```

#### builder 拼接

```go
func main() {
	var b bytes.Buffer
	b.WriteString("hello")
	b.WriteString("world")
	fmt.Println(b.String())
}
```

#### 测试下几种方法的性能

压力测试

```go
package main

import (
	"bytes"
	"fmt"
	"strings"
	"testing"
)

func String() string {
	var s string
	s += "hello" + "\n"
	s += "world" + "\n"
	s += "今天的天气很不错的"
	return s
}

func BenchmarkString(b *testing.B) {
	for i := 0; i < b.N; i++ {
		String()
	}
}

func StringFmt() string {
	return fmt.Sprintf("%s %s %s", "hello", "world", "今天的天气很不错的")
}

func BenchmarkStringFmt(b *testing.B) {
	for i := 0; i < b.N; i++ {
		StringFmt()
	}
}

func StringJoin() string {
	var s []string
	s = append(s, "hello ")
	s = append(s, "world ")
	s = append(s, "今天的天气很不错的 ")

	return strings.Join(s, "")
}

func BenchmarkStringJoin(b *testing.B) {
	for i := 0; i < b.N; i++ {
		StringJoin()
	}
}

func StringBuffer() string {
	var s bytes.Buffer
	s.WriteString("hello ")
	s.WriteString("world ")
	s.WriteString("今天的天气很不错的 ")

	return s.String()
}

func BenchmarkStringBuffer(b *testing.B) {
	for i := 0; i < b.N; i++ {
		StringBuffer()
	}
}

func StringBuilder() string {
	var s strings.Builder
	s.WriteString("hello ")
	s.WriteString("world ")
	s.WriteString("今天的天气很不错的 ")

	return s.String()
}

func BenchmarkStringBuilder(b *testing.B) {
	for i := 0; i < b.N; i++ {
		StringBuilder()
	}
}
```

看下执行的结果

```go
$ go test string_test.go  -bench=. -benchmem -benchtime=3s
goos: darwin
goarch: amd64
BenchmarkString-4               28862838               115 ns/op              64 B/op          2 allocs/op
BenchmarkStringFmt-4            20697505               169 ns/op              48 B/op          1 allocs/op
BenchmarkStringJoin-4           11304583               293 ns/op             160 B/op          4 allocs/op
BenchmarkStringBuffer-4         31151836               104 ns/op             112 B/op          2 allocs/op
BenchmarkStringBuilder-4        29142151               120 ns/op              72 B/op          3 allocs/op
PASS
ok      command-line-arguments  17.740s
```

`ns/op` 平均一次执行的时间

`B/op` 平均一次真申请的内存大小

`allocs/op` 平均一次，申请的内存次数

从上面我们就能直观的看出差距，不过差距不大，当然具体的性能信息要结合当前go版本，具体讨论。

看上去很low的+拼接方式，在性能上倒是还不错。

go101中评论

> 标准编译器对使用+运算符的字符串衔接做了特别的优化。 所以，一般说来，在被衔接的字符串的数量是已知的情况下，使用+运算符进行字符串衔接是比较高效的。

我的版本是`go version go1.13.15 darwin/amd64`

## 字符类型

我们在go中经常遇到rune和byte两种字符串类型，作为go中字符串的两种类型：

### byte

**byte 也叫 uint8。代表了 ASCII 码的一个字符**。

对于英文，一个ASCII表示一个字符，根据[ASCII表](https://baike.baidu.com/item/ASCII?fr=aladdin#reference-[1]-15482-wrap)。我们知道

A对应的十进制编码是`65`。我们看看byte打印的结果

```go
func main() {
	s := "A"
	fmt.Print("打印下[]byte(s)，结果十进制：")
	fmt.Println([]byte(s))

	fmt.Print("打印下[]byte(s)中存储的类型，存储的是十六进制：")
	fmt.Printf("%#v\n", []byte(s))

	s1 := "世界"
	fmt.Print("打印下[]byte(s1)，结果十进制：")
	fmt.Println([]byte(s1))

	fmt.Print("打印下[]byte(s1)中存储的类型，存储的是十六进制：")
	fmt.Printf("%#v\n", []byte(s1))

	fmt.Print("打印下s1的十六进制：")
	fmt.Printf("%x\n", s1)
}
```

结果

```scss
打印下[]byte(s)，结果十进制：[65]
打印下[]byte(s)中存储的类型，存储的是十六进制：[]byte{0x41}
打印下[]byte(s1)，结果十进制：[228 184 150 231 149 140]
打印下[]byte(s1)中存储的类型，存储的是十六进制：[]byte{0xe4, 0xb8, 0x96, 0xe7, 0x95, 0x8c}
打印下s1的十六进制：e4b896e7958c
```

对于ASCII一个索引位表示一个字符（也就是英文）

对于非ASCII，索引更新的步长将超过1个字节，中文的是三个字节表示一个中文。

### rune

**rune 等价于 int32 类型，UTF8编码的Unicode码点**。

```go
func main() {
	s := "哈哈"
	fmt.Println([]rune(s))

	s1 := "A"
	fmt.Println([]rune(s1))
}
```

打印下结果

```csharp
[21704 21704]
[65]
```

我们可以看到里面对应的是UTF-8的十进制数字。对于英文来讲UTF-8的码点，就是对应的ASCII。

![img](https://img2020.cnblogs.com/blog/1237626/202101/1237626-20210123233020437-1210283360.jpg)

```go
// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is
// used, by convention, to distinguish byte values from 8-bit unsigned
// integer values.
type byte = uint8

// rune is an alias for int32 and is equivalent to int32 in all ways. It is
// used, by convention, to distinguish character values from integer values.
type rune = int32
```

关于Unicode和UTF8的区别和联系，以及ASCII码的联系，参考[字符编码-字库表,字符集,字符编码](https://www.cnblogs.com/ricklz/p/14271477.html#utf-8和unicode的关系)

### 内存泄露的场景

不正确的使用会导致短暂的内存泄露

```go
var s0 string // 一个包级变量

func main() {
	s := bigString() // 申请一个大string
	// 如果f函数的执行链路很长，申请的大s的内存将得不到释放，直到f函数执行完成被gc
	f(s)
}

func f(s1 string) {
	s0 = s1[:50]
	// 目前，s0和s1共享着承载它们的字节序列的同一个内存块。
	// 虽然s1到这里已经不再被使用了，但是s0仍然在使用中，
	// 所以它们共享的内存块将不会被回收。虽然此内存块中
	// 只有50字节被真正使用，而其它字节却无法再被使用。
}

func bigString() string {
	var buf []byte
	for i := 0; i < 10; i++ {
		buf = append(buf, make([]byte, 1024*1024)...)
	}
	return string(buf)
}
```

上面的例子，**一个大的变量s1，另一个字符串s0对这个变量进行了部分引用**，新申请的变量s0和老的变量s1共用同一块内存。所以虽然大变量s1不用了，但是也不能马上被gc。

解决方法

思路是发生一次copy,类似go中闭包的解决方法

**strings.Builder**

```go
func f(s1 string) {
	var b strings.Builder
	b.Grow(50)
	b.WriteString(s1[:50])
	s0 = b.String()
}
```

感觉有点繁琐，当前也可以使用`strings.Repeat`, 从Go 1.12开始，此函数也是用`strings.Builder`实现的。

```go
func Repeat(s string, count int) string {
	if count == 0 {
		return ""
	}

	if count < 0 {
		panic("strings: negative Repeat count")
	} else if len(s)*count/count != len(s) {
		panic("strings: Repeat count causes overflow")
	}

	n := len(s) * count
	var b Builder
	b.Grow(n)
	b.WriteString(s)
	for b.Len() < n {
		if b.Len() <= n/2 {
			b.WriteString(b.String())
		} else {
			b.WriteString(b.String()[:n-b.Len()])
			break
		}
	}
	return b.String()
}
```

使用demo

```go
func main() {
	res := strings.Repeat("你好", 1)
	fmt.Println(res)
}
```

### string和[]byte如何取舍

- string 擅长的场景：

需要字符串比较的场景；

不需要nil字符串的场景；

- []byte擅长的场景：

修改字符串的场景，尤其是修改粒度为1个字节；

函数返回值，需要用nil表示含义的场景；

需要切片操作的场景；

所以底层实现会发现有很多`[]byte`

### 总结

1、字符串不允许修改,string不包含内存空间，只有一个内存的指针，这样做的好处是string变得非常轻量，可以很方便的进行传递而不用担心内存拷贝；

2、我们阅读go源码，会发现很多地方使用`[]byte`，使用`[]byte`能更方便的修改字符串；

3、go中的[]byte存储的是十六进制的ascii码，对于英文一个ascii码表示一个字母，对于中文是三个ascii码表示一个字母；

4、对于[]rune来讲，里面存储的是`UTF8`编码的`Unicode`码点，关于`UTF8`和`Unicode`区别，`Unicode`是字符集，`UTF8`是字符集编码，是`Unicode`规则字库的一种实现形式；

5、字符串的不正确使用会发生内存泄露；

6、对于字符串的拼接，+拼接是一种看上去low，但是对于短小的、常量字符串（明确的，非变量），效率还不错的方法；

## array

[array,slice](https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html)

`array` 和 `slice` 看似相似，却有着极大的不同，但他们之间还有着千次万缕的联系 `slice` 是引用类型、是 `array` 的引用，相当于动态数组，
这些都是 `slice` 的特性，但是 `slice` 底层如何表现，内存中是如何分配的，特别是在程序中大量使用 `slice` 的情况下，怎样可以高效使用 `slice`？

在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储，利用元素的索引（index）可以计算出该元素对应的存储地址。
数组设计之初是在形式上依赖内存分配而成的，所以必须在使用前预先请求空间。这使得数组有以下特性:

1. **请求空间以后大小固定，不能再改变**（数据溢出问题）；
2. 在内存中有**空间连续性的表现**，中间不会存在其他程序需要调用的数据，为此数组的专用内存空间；
3. 在旧式编程语言中（如有中阶语言之称的C），程序不会对数组的操作做下界判断，也就有潜在的越界操作的风险（比如会把数据写在运行中程序需要调用的核心部分的内存上）。

总结一下数组有一下特性：

- 分配在连续的内存地址上
- 元素类型一致，元素存储宽度一致
- 空间大小固定，不能修改
- 可以通过索引计算出元素对应存储的位置（只需要知道数组内存的起始位置和数据元素宽度即可）
- 会出现数据溢出的问题（下标越界）

数组的长度也是其类型的一种，例如：

```go
a := [4]int{}
b := [3]int{}
```

`a`和`b`并不相等。

不允许动态给数组长度

```
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	n:= 10
	var arr = [n]int{}
	fmt.Println(arr)
}
```

这是错误的

### 数组可变和不可变

[参考](https://learnku.com/go/t/27971)

文章中的 数组是可变的 应该怎么样去理解呢？

对索引项为 i 的数组元素赋值可以这么操作：arr[i] = value

但是事实上这个赋值

```
func main() {
  var arr [2]int
  arr[0] = 1
  arr[1] = 2
  arr[2] = 3
  fmt.Println(arr)
}
```

会报错的 invalid array index 2

文章中所说的如下：

第一个元素是 arr1[0]，第三个元素是 arr1[2]；总体来说索引 i 代表的元素是 arr1[i]，最后一个元素是 arr1[len(arr1)-1]。

对索引项为 i 的数组元素赋值可以这么操作：arr[i] = value，**所以数组是 可变的**。

只有有效的索引可以被使用，当使用等于或者大于 len(arr1) 的索引时：如果编译器可以检测到，会给出索引超限的提示信息；如果检测不到的话编译会通过而运行时会 panic:（参考 第 13 章）

```
runtime error: index out of range
```

**数组的可变是可以改变数组内的值，不可变是指数组的长度和容量**

## slice

`slice` 是在 `array` 的基础上实现的

`slice` 的类型规范是[]T，`slice` T元素的类型。与数组类型不同，`slice` 类型没有指定的长度。

**`slice` 申明的几种方法：**

> `s := []int{1, 2, 3}` 简短的赋值语句
>
> `var s []int` `var` 申明
>
> `make([]int, 3, 8)` 或 `make([]int, 3)` `make` 内置方法创建
>
> `s := ss[:5] `从切片或者数组创建

**`slice` 有两个内置函数来获取其属性：**

> `len` 获取 `slice` 的长度
>
> `cap` 获取 `slice` 的容量

### slice底层结构

```
//runtime/slice.go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```

- `slice` 是的起始位置是引用数组元素位置的指针。
- `slice` 的长度是引用数组元素起始位置到结束位置的长度。
- `slice` 的容量是引用数组元素起始位置到数组末尾的长度。

![slice](https://blog.thinkeridea.com/assets/image/20190111/slice_1.jpg)

### 初始化

Slice在初始化时需要初始化指针，长度和容量，**容量未指定时将自动初始化为长度的大小。可以通过直接获取数组的引用、获取数组/slice的切片构建或是make函数初始化数组**。下面给出一些slice初始化的方式示例。

```go
s := []int{1,2,3}	//通过数组的引用初始化，值为[1,2,3],长度和容量为3

arr := [5]int{1,2,3,4,5}
s := arr[0:3]	//通过数组的切片初始化，值为[1,2,3]，长度为3，容量为5

s := arr[1:3]	//通过数组的切片初始化，值为[2,3]，长度为2，容量为5

s := make([]int, 3)	//通过make函数初始化，值为[0,0,0]，长度和容量为3

s := make([]int, 3, 5)	//通过make函数初始化，值为[0,0,0]，长度为3，容量为5
```

**当通过数组初始化切片时**

切片内的指针指向开始的的地址，例如第6行中，指针指向2所在的地址

**当通过现有切片初始化新切片时**

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/a0eca91a66cd494d966e8882b1817243%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1304%3A0%3A0%3A0.awebp)



这样的初始化方式可能会导致内存被**过度占用**，如只需要使用一个极大的数组中的几个元素，但是由于需要指向整个数组，所以整个数组在GC时都无法被释放，一直占用内存空间。故使用切片操作进行初始化时，最好使用`append`函数将切片出来的数据复制到一个新的slice中，从而避免内存占用陷阱。

### make slice

slice描述了Array的一部分，从slice的结构可以看到大致的关系了，现在从底层的创建过程来确认两者的关系。

**makeslice**

slice的array确实是数组吗？先看下slice与array的创建过程：

```go
// path: src/runtime/slice.go
func makeslice(et *_type, len, cap int) unsafe.Pointer {
    // 计算占用空间和是否溢出
	mem, overflow := math.MulUintptr(et.size, uintptr(cap))
    
   // 一些边界条件处理 
	if overflow || mem > maxAlloc || len < 0 || len > cap {
		mem, overflow := math.MulUintptr(et.size, uintptr(len))
		if overflow || mem > maxAlloc || len < 0 {
           // panic： len 超出范围 
			panicmakeslicelen()
		}
        // panic: cap 超出范围 
		panicmakeslicecap()
	}

	return mallocgc(mem, et, true)
}
```

makeslice分配的内存大小为类型et的`size * cap`，创建时会判断是否超过允许的分配的最大内存。

**newarray**

```go
// newarray allocates an array of n elements of type typ.
func newarray(typ *_type, n int) unsafe.Pointer {
    if n == 1 {
        return mallocgc(typ.size, typ, true)
    }
    mem, overflow := math.MulUintptr(typ.size, uintptr(n))
    if overflow || mem > maxAlloc || n < 0 {
        panic(plainError("runtime: allocation size out of range"))
    }
    return mallocgc(mem, typ, true)
}
```

`newarray`分配的内存大小为`size * len`，与`makeslice`比，主要少了cap相关的检查。两者结合看，`slice`在make时会先创建`cap`大小的`array`，这是Slice与Array的最直接的联系。

**slice与array的关系**

从makeslice的源码结合newarray来看，makeslice除校验cap外，实际就是在创建一个大小为cap的数组。

如果觉得两者的关系还不够直观，我们从reflect/value.go中的MakeSlice的源码看下：

```go
// SliceHeader is the runtime representation of a slice.
// It cannot be used safely or portably and its representation may
// change in a later release.
// Moreover, the Data field is not sufficient to guarantee the data
// it references will not be garbage collected, so programs must keep
// a separate, correctly typed pointer to the underlying data.
type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}

// sliceHeader is a safe version of SliceHeader used within this package.
type sliceHeader struct {
    Data unsafe.Pointer
    Len  int
    Cap  int
}
// MakeSlice creates a new zero-initialized slice value
// for the specified slice type, length, and capacity.
func MakeSlice(typ Type, len, cap int) Value {
    if typ.Kind() != Slice {
        panic("reflect.MakeSlice of non-slice type")
    }
    if len < 0 {
        panic("reflect.MakeSlice: negative len")
    }
    if cap < 0 {
        panic("reflect.MakeSlice: negative cap")
    }
    if len > cap {
        panic("reflect.MakeSlice: len > cap")
    }

    s := sliceHeader{unsafe_NewArray(typ.Elem().(*rtype), cap), len, cap}
    return Value{typ.(*rtype), unsafe.Pointer(&s), flagIndir | flag(Slice)}
}
```

`sliceHeader`是slice在运行时的表示，`sliceHeader`在构造时，先通过`unsafe_NewArray`创建Data。而`unsafe_NewArray`就是调用的`newarray`，因此`MakeSlice`就是创建一个持有cap大小的数组的`sliceHeader`。

```go
//go:linkname reflect_unsafe_NewArray reflect.unsafe_NewArray
func reflect_unsafe_NewArray(typ *_type, n int) unsafe.Pointer {
    return newarray(typ, n)
}
```

**当make slice 得到的是一个`SliceHeader`结构体**（这与map和channel不同，map和channel是指针）。

### append

[参考](https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html)

[参考2](https://www.zhihu.com/question/27161493?sort=created)

`slice` 是如何增长的，用 `unsafe` 分析一下看看：

```
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	s := make([]int, 9, 10)

	// 引用底层的数组地址
	fmt.Printf("%x\n", *(*uintptr)(unsafe.Pointer(&s)))

	s = append(s, 1)

	// 引用底层的数组地址
	fmt.Printf("%x\n", *(*uintptr)(unsafe.Pointer(&s)))

	s = append(s, 1)

	// 引用底层的数组地址
	fmt.Printf("%x\n", *(*uintptr)(unsafe.Pointer(&s)))
}
```

以上代码的输出([Go Playground](https://play.golang.org/p/3c4ek4-0ft5)):

> c000082e90
>
> 9 10
>
> c000082e90
>
> 10 10
>
> c00009a000
>
> 11 20

从结果上看前两次地址是一样的，初始化一个长度为9，容量为10的 `slice`，当第一次 `append` 的时候容量是足够的，所以底层引用数组地址未发生变化，此时 `slice` 的长度和容量都为10，之后再次 `append` 的时候发现底层数组的地址不一样了，因为 `slice` 的长度超过了容量，但是新的 `slice` 容量并不是11而是20，这要说 `slice` 的机制了，因为数组长度不可变，想扩容 `slice`就必须分配一个更大的数组，并把之前的数据拷贝到新数组，如果一次只增加1个长度，那就会那发生大量的内存分配和数据拷贝，这个成本是很大的，所以 `slice` 是有一个增长策略的。

`Go` 标准库 `runtime/slice.go` 当中有详细的 `slice` 增长策略的逻辑：

```
func growslice(et *_type, old slice, cap int) slice {
    .....
    
    // 计算新的容量，核心算法用来决定slice容量增长
	newcap := old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
		if old.len < 1024 {
			newcap = doublecap
		} else {
			for 0 < newcap && newcap < cap {
				newcap += newcap / 4
			}
			if newcap <= 0 {
				newcap = cap
			}
		}
	}

    // 根据et.size调整新的容量
	var overflow bool
	var lenmem, newlenmem, capmem uintptr
	switch {
	case et.size == 1:
		lenmem = uintptr(old.len)
		newlenmem = uintptr(cap)
		capmem = roundupsize(uintptr(newcap))
		overflow = uintptr(newcap) > maxAlloc
		newcap = int(capmem)
	case et.size == sys.PtrSize:
		lenmem = uintptr(old.len) * sys.PtrSize
		newlenmem = uintptr(cap) * sys.PtrSize
		capmem = roundupsize(uintptr(newcap) * sys.PtrSize)
		overflow = uintptr(newcap) > maxAlloc/sys.PtrSize
		newcap = int(capmem / sys.PtrSize)
	case isPowerOfTwo(et.size):
		var shift uintptr
		if sys.PtrSize == 8 {
			// Mask shift for better code generation.
			shift = uintptr(sys.Ctz64(uint64(et.size))) & 63
		} else {
			shift = uintptr(sys.Ctz32(uint32(et.size))) & 31
		}
		lenmem = uintptr(old.len) << shift
		newlenmem = uintptr(cap) << shift
		capmem = roundupsize(uintptr(newcap) << shift)
		overflow = uintptr(newcap) > (maxAlloc >> shift)
		newcap = int(capmem >> shift)
	default:
		lenmem = uintptr(old.len) * et.size
		newlenmem = uintptr(cap) * et.size
		capmem = roundupsize(uintptr(newcap) * et.size)
		overflow = uintptr(newcap) > maxSliceCap(et.size)
		newcap = int(capmem / et.size)
	}

    ......
	
	var p unsafe.Pointer
	if et.kind&kindNoPointers != 0 {
		p = mallocgc(capmem, nil, false)  // 分配新的内存
		memmove(p, old.array, lenmem) // 拷贝数据
		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)
	} else {
		p = mallocgc(capmem, et, true) // 分配新的内存
		if !writeBarrier.enabled {
			memmove(p, old.array, lenmem)
		} else {
			for i := uintptr(0); i < lenmem; i += et.size {
				typedmemmove(et, add(p, i), add(old.array, i)) // 拷贝数据
			}
		}
	}

	return slice{p, old.len, newcap} // 新slice引用新的数组，长度为旧数组的长度，容量为新数组的容量
}
```

基本呢就三个步骤，**计算新的容量、分配新的数组、拷贝数据到新数组**，社区很多人分享 `slice` 的增长方法，实际都不是很精确，因为大家只分析了计算 `newcap` 的那一段，也就是上面注释的第一部分，下面的 `switch` 根据 `et.size` 来调整 `newcap` 一段被直接忽略，社区的结论是：”**如果 `selic` 的容量小于1024个元素，那么扩容的时候 `slice` 的 `cap` 就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一**” 大多数情况也确实如此，但是根据 `newcap` 的计算规则，如果新的容量超过旧的容量2倍时会直接按新的容量分配，真的是这样吗?

```
package main

import (
	"fmt"
)

func main() {
	s := make([]int, 10, 10)
	fmt.Println(len(s), cap(s))
	s2 := make([]int, 40)

	s = append(s, s2...)
	fmt.Println(len(s), cap(s))

}
```

以上代码的输出([Go Playground](https://play.golang.org/p/x8kN4V5R7YW)):

> 10 10
>
> 50 52

这个结果有点出人意料， 如果是2倍增长应该是 `10 * 2 * 2 * 2` 结果应该是80， 如果说新的容量高于旧容量的两倍但结果也不是50，实际上 `newcap` 的结果就是50，那段逻辑很好理解，但是`switch` 根据 `et.size` 来调整 `newcap` 后就是52了，这段逻辑走到了 `case et.size == sys.PtrSize` 这段，详细的以后做源码分析再说。

**总结 **

- **当 `slice` 的长度超过其容量，会分配新的数组，并把旧数组上的值拷贝到新的数组**
- **逐个元素添加到 `slice` 并超过其容量**， 如果 `selic` 的容量小于1024个元素，那么扩容的时候 `slice` 的 `cap` 就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。
- **批量添加元素**，当新的容量高于旧容量的两倍，就会分配比新容量稍大一些，并不会按上面第二条的规则扩容。
- 当 `slice` 发生扩容，引用新数组后，`slice` 操作不会再影响旧的数组，而是新的数组（社区经常讨论的传递 `slice` 容量超出后，修改数据不会作用到旧的数据上），所以往往设计函数如果会对长度调整都会返回新的 `slice`，例如 `append` 方法。

**当slice为多维时**

进行append时，是进行浅拷贝

[参考2](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/by-jiu-tian-5-7h2i/)

[参考](https://www.1024sou.com/article/532888.html)

### copy

[参考](http://c.biancheng.net/view/29.html)

slice通过copy进行深拷贝，使用`=`是进行反复浅拷贝

copy() 函数的使用格式如下：

```
copy(destSlice, srcSlice []T) int
```

其中 srcSlice 为数据来源切片，destSlice 为复制的目标（也就是将 srcSlice 复制到 destSlice），目标切片必须分配过空间且足够承载复制的元素个数，并且来源和目标的类型必须一致，copy() 函数的返回值表示实际发生复制的元素个数。

**如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制。**

### slice 的三种状态

[参考](https://juejin.cn/post/6844903712654098446)

`slice` 有三种状态：零切片、空切片、nil切片。

零切片就是nil切片

```
var s1 []int // nil 切片
var s2 = []int{} // 空切片
var s3 = make([]int, 0) // 空切片
var s4 = *new([]int) // nil 切片

var a1 = *(*[3]int)(unsafe.Pointer(&s1))
var a2 = *(*[3]int)(unsafe.Pointer(&s2))
var a3 = *(*[3]int)(unsafe.Pointer(&s3))
var a4 = *(*[3]int)(unsafe.Pointer(&s4))
fmt.Println(a1)
fmt.Println(a2)
fmt.Println(a3)
fmt.Println(a4)

---------------------
[0 0 0]
[824634199592 0 0]
[824634199592 0 0]
[0 0 0]
```

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/1670b6d164141b26%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A1304%3A0%3A0%3A0.awebp)

空切片指向的 `zerobase` 内存地址是一个神奇的地址，从 Go 语言的源代码中可以看到它的定义

```
//// runtime/malloc.go

// base address for all 0-byte allocations
var zerobase uintptr

// 分配对象内存
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
	...
	if size == 0 {
		return unsafe.Pointer(&zerobase)
	}
    ...
}

//// runtime/slice.go
// 创建切片
func makeslice(et *_type, len, cap int) slice {
  ...
     p := mallocgc(et.size*uintptr(cap), et, true)
	 return slice{p, len, cap}
}
复制代码
```

最后一个问题是：「 nil 切片」和 「空切片」在使用上有什么区别么？

答案是完全没有任何区别！No！不对，还有一个小小的区别！请看下面的代码

```
package main

import "fmt"

func main() {
	var s1 []int
	var s2 = []int{}

	fmt.Println(s1 == nil)
	fmt.Println(s2 == nil)

	fmt.Printf("%#v\n", s1)
	fmt.Printf("%#v\n", s2)
}

-------
true
false
[]int(nil)
[]int{}
```

所以为了避免写代码的时候把脑袋搞昏的**最好办法是不要创建「 空切片」，统一使用「 nil 切片」**，同时要避免将切片和 nil 进行比较来执行某些逻辑。这是官方的标准建议。

> The former declares a nil slice value, while the latter is non-nil but zero-length. They are functionally equivalent—their len and cap are both zero—but the nil slice is the preferred style.

「空切片」和「 nil 切片」有时候会隐藏在结构体中，这时候它们的区别就被太多的人忽略了，下面我们看个例子

```
type Something struct {
	values []int
}

var s1 = Something{}
var s2 = Something{[]int{}}
fmt.Println(s1.values == nil)
fmt.Println(s2.values == nil)

--------
true
false
```

可以发现这**两种创建结构体的结果是不一样的**！

「空切片」和「 nil 切片」还有一个极为不同的地方在于 JSON 序列化

```
type Something struct {
	Values []int
}

var s1 = Something{}
var s2 = Something{[]int{}}
bs1, _ := json.Marshal(s1)
bs2, _ := json.Marshal(s2)
fmt.Println(string(bs1))
fmt.Println(string(bs2))

---------
{"Values":null}
{"Values":[]}
```

Ban! Ban! Ban! **它们的 json 序列化结果居然也不一样**！

### slice比较

比较两个slice包含的元素是否完全相等的情况：

- `reflect.DeepEqual`
- 循环遍历

### slice 并发问题

**在切片中并不会引发panic**，如果程序无意中对切片使用了并发读写，严重的话会导致获取的数据和之后存储的数据错乱，所以这里要格外小心，可以通过加锁来避免。

再来看并发 append slice 的情况，使用 10 个 goroutine 并发 append 10000 个数字到 slice s 中，最终 s 正确长度为 100000

测试代码：

```
package main

import (
    "sync"
    "testing"
)

func TestSlice(t *testing.T) {
    s := []int{}
    var wg sync.WaitGroup

    // 外部变量记录每个 goroutine append 的数量
    count := 0
    // 10 个 goroutine 并发 append 10000 个数字到 slice s 中，最终 s 正确长度为 10 * 10000 = 100000
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i, count int) {
            for j := 0; j < 10000; j++ {
                s = append(s, j)
                count++
            }
            t.Logf("G%d append count:%d\n", i, count)
            wg.Done()
        }(i, count)
    }
    wg.Wait()

    if len(s) != 100000 {
        t.Errorf("s.len:%d != 100000", len(s))
    }
}
```

同样，循环次数如果很少时也有可能是正常的结果，数量较大时就能明显观察到错误。

执行测试：

```
go test -v -race -run TestSlice
=== RUN   TestSlice
==================
WARNING: DATA RACE
Read at 0x00c00000e048 by goroutine 10:
    ...
...
==================
    slice_test.go:22: G9 append count:10000
    slice_test.go:22: G0 append count:10000
    slice_test.go:22: G3 append count:10000
    slice_test.go:22: G2 append count:10000
    slice_test.go:22: G8 append count:10000
    slice_test.go:22: G4 append count:10000
    slice_test.go:22: G6 append count:10000
    slice_test.go:22: G5 append count:10000
    slice_test.go:22: G1 append count:10000
    slice_test.go:22: G7 append count:10000
    slice_test.go:29: s.len:26101 != 100000
    testing.go:1093: race detected during execution of test
--- FAIL: TestSlice (0.28s)
=== CONT
    testing.go:1093: race detected during execution of test
FAIL
```

在 append 出加锁后，修复问题：

```
package main

import (
    "sync"
    "testing"
)

func TestSlice(t *testing.T) {
    s := []int{}
    var wg sync.WaitGroup
    // 锁
    var mu sync.Mutex

    // 外部变量记录每个 goroutine append 的数量
    count := 0
    // 10 个 goroutine 并发 append 10000 个数字到 slice s 中，最终 s 正确长度为 10 * 10000 = 100000
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i, count int) {
            for j := 0; j < 10000; j++ {
                // append slice 加锁解决并发安全问题
                mu.Lock()
                s = append(s, j)
                mu.Unlock()
                count++
            }
            t.Logf("G%d append count:%d\n", i, count)
            wg.Done()
        }(i, count)
    }
    wg.Wait()

    if len(s) != 100000 {
        t.Errorf("s.len:%d != 100000", len(s))
    }
}
```

运行测试：

```
go test -v -race -run TestSlice
=== RUN   TestSlice
    slice_test.go:25: G6 append count:10000
    slice_test.go:25: G0 append count:10000
    slice_test.go:25: G9 append count:10000
    slice_test.go:25: G5 append count:10000
    slice_test.go:25: G8 append count:10000
    slice_test.go:25: G7 append count:10000
    slice_test.go:25: G2 append count:10000
    slice_test.go:25: G3 append count:10000
    slice_test.go:25: G1 append count:10000
    slice_test.go:25: G4 append count:10000
--- PASS: TestSlice (0.05s)
PASS
```

#### 问题分析

先说结论：因为**并发的 append 操作的是同一个底层数组，导致同一个数组下标的元素被多次覆盖**。

slice 底层是使用数组保存数据，数组是一段连续的内存空间

```
[]int{} -> *array -> [连续内存空间]
            |
            len
            |
            cap
```

slice 实现原理参考：https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/

append 处理流程：

```
// append(slice, 1, 2, 3)
ptr, len, cap := slice
newlen := len + 3
if newlen > cap {
    ptr, len, cap = growslice(slice, newlen)
    newlen = len + 3
}
*(ptr+len) = 1
*(ptr+len+1) = 2
*(ptr+len+2) = 3
return makeslice(ptr, newlen, cap)
```

在程序中先声明了一个 slice s 然后并发的不断向其中添加元素， append 追加元素实际是将每个元素依次赋值给对应的数组中的内存指针（即将内存空间的指针指向对应的元素）， **并发情况下，所有 goroutine 都操作的时同一个数组，同一个指针可能多次指向了不同的元素，最后导致元素个数和预期不一致**。

## map

[参考地址](https://golang.design/go-questions/map/principal/)

map 的设计也被称为 “The dictionary problem”，它的任务是设计一种数据结构用来维护一个集合的数据，并且可以同时对集合进行增删查改的操作。最主要的数据结构有两种：`哈希查找表（Hash table）`、`搜索树（Search tree）`。

哈希查找表用一个哈希函数将 key 分配到不同的桶（bucket，也就是数组的不同 index）。这样，开销主要在哈希函数的计算以及数组的常数访问时间。在很多场景下，哈希查找表的性能很高。

哈希查找表一般会**存在“碰撞”的问题**，就是说不同的 key 被哈希到了同一个 bucket。**一般有两种应对方法：`链表法`和`开放地址法`。`链表法`将一个 bucket 实现成一个链表，落在同一个 bucket 中的 key 都会插入这个链表。`开放地址法`则是碰撞发生后，通过一定的规律，在数组的后面挑选“空位”，用来放置新的 key。**

搜索树法一般采用自平衡搜索树，包括：AVL 树，红黑树。面试时经常会被问到，甚至被要求手写红黑树代码，很多时候，面试官自己都写不上来，非常过分。

**自平衡搜索树法的最差搜索效率是 O(logN)，而哈希查找表最差是 O(N)**。当然，哈希查找表的平均查找效率是 O(1)，如果哈希函数设计的很好，最坏的情况基本不会出现。还有一点，遍历自平衡搜索树，返回的 key 序列，一般会按照从小到大的顺序；而哈希查找表则是乱序的。

### map的初始化

使用 `make` 创建哈希，Go 语言编译器都会在类型检查期间将它们转换成 `runtime.makemap`，使用字面量初始化哈希也只是语言提供的辅助工具，最后调用的都是 `runtime.makemap`：

[参考](https://github.com/Simin-hub/Learning-Programming/blob/main/Go/%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.md#make)

```
// path: src/runtime/map.go
func makemap(t *maptype, hint int, h *hmap) *hmap {
	...
   // 初始化 Hmap
   if h == nil {
      h = new(hmap)
   }
    
   // 生成 hash 种子
   h.hash0 = fastrand()
    
   // 计算 桶 的数量
   B := uint8(0)
   for overLoadFactor(hint, B) {
      B++
   }
   h.B = B
   if h.B != 0 {
      var nextOverflow *bmap
       
      // 创建 桶
      h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
      ...
   }
   return h
}
```

make 是得到了一个指向 `hmap` 结构的指针

### map 的底层

**Go 语言采用的是哈希查找表**，并且使用链表解决哈希冲突。

### map 内存模型 

在源码中，表示 map 的结构体是 hmap，它是 hashmap 的“缩写”：

```go
// A header for a Go map.
type hmap struct {
    // 元素个数，调用 len(map) 时，直接返回此值
	count     int
	flags     uint8
	// buckets 的对数 log_2
	B         uint8
	// overflow 的 bucket 近似数
	noverflow uint16
	// 计算 key 的哈希的时候会传入哈希函数
	hash0     uint32
    // 指向 buckets 数组，大小为 2^B
    // 如果元素个数为0，就为 nil
	buckets    unsafe.Pointer
	// 等量扩容的时候，buckets 长度和 oldbuckets 相等
	// 双倍扩容的时候，buckets 长度会是 oldbuckets 的两倍
	oldbuckets unsafe.Pointer
	// 指示扩容进度，小于此地址的 buckets 迁移完成
	nevacuate  uintptr
	extra *mapextra // optional fields
}
```

说明一下，`B` 是 buckets 数组的长度的对数，也就是说 buckets 数组的长度就是 2^B。bucket 里面存储了 key 和 value，后面会再讲。

buckets 是一个指针，最终它指向的是一个结构体：

```
type bmap struct {
	tophash [bucketCnt]uint8
}
```

但这只是表面(src/runtime/hashmap.go)的结构，编译期间会给它加料，动态地创建一个新的结构：

```
type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}
```

`bmap` 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。

来一个整体的图：

![hashmap bmap](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/0.png)

当 map 的 key 和 value 都不是指针，并且 size 都小于 128 字节的情况下，会把 bmap 标记为不含指针，这样可以避免 gc 时扫描整个 hmap。但是，我们看 **bmap 其实有一个 overflow 的字段，是指针类型的，破坏了 bmap 不含指针的设想，这时会把 overflow 移动到 extra 字段来。**

```
type mapextra struct {
	// overflow[0] contains overflow buckets for hmap.buckets.
	// overflow[1] contains overflow buckets for hmap.oldbuckets.
	overflow [2]*[]*bmap

	// nextOverflow 包含空闲的 overflow bucket，这是预分配的 bucket
	nextOverflow *bmap
}
```

bmap 是存放 k-v 的地方，我们把视角拉近，仔细看 bmap 的内部组成。

![bmap struct](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/1.png)

上图就是 bucket 的内存模型，`HOB Hash` 指的就是 top hash。 注意到 key 和 value 是各自放在一起的，并不是 `key/value/key/value/...` 这样的形式。源码里说明这样的好处是在某些情况下可以省略掉 padding 字段，节省内存空间。

例如，有这样一个类型的 map：

```
map[int64]int8
```

如果按照 `key/value/key/value/...` 这样的模式存储，那在每一个 key/value 对之后都要额外 padding 7 个字节；而将所有的 key，value 分别绑定到一起，这种形式 `key/key/.../value/value/...`，则只需要在最后添加 padding。

每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 `overflow` 指针连接起来。

### 创建 map

从语法层面上来说，创建 map 很简单：

```
ageMp := make(map[string]int)
// 指定 map 长度
ageMp := make(map[string]int, 8)

// ageMp 为 nil，不能向其添加元素，会直接panic,可以取值，但为默认值
var ageMp map[string]int
```

通过汇编语言可以看到，实际上**底层调用的是 `makemap` 函数**，主要做的工作就是初始化 `hmap` 结构体的各种字段，例如计算 B 的大小，设置哈希种子 hash0 等等。

```golang
func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap {
	// 省略各种条件检查...

	// 找到一个 B，使得 map 的装载因子在正常范围内
	B := uint8(0)
	for ; overLoadFactor(hint, B); B++ {
	}

	// 初始化 hash table
	// 如果 B 等于 0，那么 buckets 就会在赋值的时候再分配
	// 如果长度比较大，分配内存会花费长一点
	buckets := bucket
	var extra *mapextra
	if B != 0 {
		var nextOverflow *bmap
		buckets, nextOverflow = makeBucketArray(t, B)
		if nextOverflow != nil {
			extra = new(mapextra)
			extra.nextOverflow = nextOverflow
		}
	}

	// 初始化 hamp
	if h == nil {
		h = (*hmap)(newobject(t.hmap))
	}
	h.count = 0
	h.B = B
	h.extra = extra
	h.flags = 0
	h.hash0 = fastrand()
	h.buckets = buckets
	h.oldbuckets = nil
	h.nevacuate = 0
	h.noverflow = 0

	return h
}
```

【引申1】slice 和 map 分别作为函数参数时有什么区别？

注意，**这个函数返回的结果：`*hmap`，它是一个指针**，而我们之前讲过的 **`makeslice` 函数返回的是 `Slice` 结构体**：

```
func makeslice(et *_type, len, cap int) slice
```

回顾一下 slice 的结构体定义：

```
// runtime/slice.go
type slice struct {
    array unsafe.Pointer // 元素指针
    len   int // 长度 
    cap   int // 容量
}
```

结构体内部包含底层的数据指针。

**makemap 和 makeslice 的区别，带来一个不同点：当 map 和 slice 作为函数参数时，在函数参数内部对 map 的操作会影响 map 自身；而对 slice 却不会（之前讲 slice 的文章里有讲过）**。

主要原因：**一个是指针（`*hmap`），一个是结构体（`slice`）**。Go 语言中的函数传参都是值传递，在函数内部，参数会被 copy 到本地。`*hmap`指针 copy 完之后，仍然指向同一个 map，因此函数内部对 map 的操作会影响实参。而 slice 被 copy 后，会成为一个新的 slice，对它进行的操作不会影响到实参。

### 哈希函数 

map 的一个关键点在于，哈希函数的选择。在程序启动时，会检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。这是在函数 `alginit()` 中完成，位于路径：`src/runtime/alg.go` 下。

> hash 函数，有加密型和非加密型。 加密型的一般用于加密数据、数字摘要等，典型代表就是 md5、sha1、sha256、aes256 这种； 非加密型的一般就是查找。在 map 的应用场景中，用的是查找。 选择 hash 函数主要考察的是两点：性能、碰撞概率。

之前我们讲过，表示类型的结构体：

```
type _type struct {
	size       uintptr
	ptrdata    uintptr // size of memory prefix holding all pointers
	hash       uint32
	tflag      tflag
	align      uint8
	fieldalign uint8
	kind       uint8
	alg        *typeAlg
	gcdata    *byte
	str       nameOff
	ptrToThis typeOff
}
```

其中 `alg` 字段就和哈希相关，它是指向如下结构体的指针：

```
// src/runtime/alg.go
type typeAlg struct {
	// (ptr to object, seed) -> hash
	hash func(unsafe.Pointer, uintptr) uintptr
	// (ptr to object A, ptr to object B) -> ==?
	equal func(unsafe.Pointer, unsafe.Pointer) bool
}
```

typeAlg 包含两个函数，hash 函数计算类型的哈希值，而 equal 函数则计算两个类型是否“哈希相等”。

对于 string 类型，它的 hash、equal 函数如下：

```golang
func strhash(a unsafe.Pointer, h uintptr) uintptr {
	x := (*stringStruct)(a)
	return memhash(x.str, h, uintptr(x.len))
}

func strequal(p, q unsafe.Pointer) bool {
	return *(*string)(p) == *(*string)(q)
}
```

根据 key 的类型，_type 结构体的 alg 字段会被设置对应类型的 hash 和 equal 函数。

### key 定位过程

key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。还记得前面提到过的 B 吗？如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 = 32。

例如，现在有一个 key 经过哈希函数计算后，得到的哈希结果是：

```
10010111 | 000011110110110010001111001010100010010110010101010 │ 01010
```

用最后的 5 个 bit 位，也就是 `01010`，值为 10，也就是 10 号桶。这个操作实际上就是取余操作，但是取余开销太大，所以代码实现上用的**位操作**代替。

再用哈希值的高 8 位，找到此 key 在 bucket 中的位置，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。

buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。

这里参考曹大 github 博客里的一张图，原图是 ascii 图，geek 味十足，可以从参考资料找到曹大的博客，推荐大家去看看。

![mapacess](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/2.png)

上图中，假定 B = 5，所以 bucket 总数就是 2^5 = 32。首先计算出待查找 key 的哈希，使用低 5 位 `00110`，找到对应的 6 号 bucket，使用高 8 位 `10010111`，对应十进制 151，在 6 号 bucket 中寻找 tophash 值（HOB hash）为 151 的 key，找到了 2 号槽位，这样整个查找过程就结束了。

**如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。**

**遍历所有的 bucket，这相当于是一个 bucket 链表。**

**当定位到一个具体的 bucket 时，里层循环就是遍历这个 bucket 里所有的 cell，或者说所有的槽位，也就是 bucketCnt=8 个槽位。整个循环过程：**

![mapacess loop](https://golang.design/go-questions/map/assets/3.png)

再说一下 minTopHash，当一个 cell 的 tophash 值小于 minTopHash 时，标志这个 cell 的迁移状态。因为这个状态值是放在 tophash 数组里，为了和正常的哈希值区分开，会给 key 计算出来的哈希值一个增量：minTopHash。这样就能区分正常的 top hash 值和表示状态的哈希值。

下面的这几种状态就表征了 bucket 的情况：

```golang
// 空的 cell，也是初始时 bucket 的状态
empty          = 0
// 空的 cell，表示 cell 已经被迁移到新的 bucket
evacuatedEmpty = 1
// key,value 已经搬迁完毕，但是 key 都在新 bucket 前半部分，
// 后面扩容部分会再讲到。
evacuatedX     = 2
// 同上，key 在后半部分
evacuatedY     = 3
// tophash 的最小正常值
minTopHash     = 4
```

源码里判断这个 bucket 是否已经搬迁完毕，用到的函数：

```
func evacuated(b *bmap) bool {
	h := b.tophash[0]
	return h > empty && h < minTopHash
}
```

只取了 tophash 数组的第一个值，判断它是否在 0-4 之间。对比上面的常量，当 top hash 是 `evacuatedEmpty`、`evacuatedX`、`evacuatedY` 这三个值之一，说明此 bucket 中的 key 全部被搬迁到了新 bucket。

### Get

Go 语言中读取 map 有两种语法：带 comma 和 不带 comma。当要查询的 key 不在 map 里，带 comma 的用法会返回一个 bool 型变量提示 key 是否在 map 中；而不带 comma 的语句则会返回一个 key 对应 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。

```
package main

import "fmt"

func main() {
	ageMap := make(map[string]int)
	ageMap["qcrao"] = 18

    // 不带 comma 用法
	age1 := ageMap["stefno"]
	fmt.Println(age1)

    // 带 comma 用法
	age2, ok := ageMap["stefno"]
	fmt.Println(age2, ok)
}
```

以前一直觉得好神奇，怎么实现的？这其实是编译器在背后做的工作：分析代码后，将两种语法对应到底层两个不同的函数。

```
// src/runtime/hashmap.go
func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer
func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)
```

源码里，函数命名不拘小节，直接带上后缀 1，2，完全不理会《代码大全》里的那一套命名的做法。从上面两个函数的声明也可以看出差别了，`mapaccess2` 函数返回值多了一个 bool 型变量，两者的代码也是完全一样的，只是在返回值后面多加了一个 false 或者 true。

另外，根据 key 的不同类型，编译器还会将查找、插入、删除的函数用更具体的函数替换，以优化效率：

| key 类型 | 查找                                                         |
| -------- | ------------------------------------------------------------ |
| uint32   | mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer |
| uint32   | mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool) |
| uint64   | mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer |
| uint64   | mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool) |
| string   | mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer |
| string   | mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool) |

这些函数的参数类型直接是具体的 uint32、unt64、string，在函数内部由于提前知晓了 key 的类型，所以内存布局是很清楚的，因此能节省很多操作，提高效率。

### 遍历

本来 map 的遍历过程比较简单：遍历所有的 bucket 以及它后面挂的 overflow bucket，然后挨个遍历 bucket 中的所有 cell。每个 bucket 中包含 8 个 cell，从有 key 的 cell 中取出 key 和 value，这个过程就完成了。

但是，现实并没有这么简单。还记得前面讲过的扩容过程吗？**扩容过程不是一个原子的操作，它每次最多只搬运 2 个 bucket，所以如果触发了扩容操作，那么在很长时间里，map 的状态都是处于一个中间态：有些 bucket 已经搬迁到新家，而有些 bucket 还待在老地方**。

因此，**遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，这是难点所在。**

```
package main

import "fmt"

func main() {
	ageMp := make(map[string]int)
	ageMp["qcrao"] = 18

	for name, age := range ageMp {
		fmt.Println(name, age)
	}
}
```

执行命令：

```shell
go tool compile -S main.go
```

得到汇编命令。这里就不逐行讲解了，可以去看之前的几篇文章，说得很详细。

关键的几行汇编代码如下：

```golang
// ......
0x0124 00292 (test16.go:9)      CALL    runtime.mapiterinit(SB)

// ......
0x01fb 00507 (test16.go:9)      CALL    runtime.mapiternext(SB)
0x0200 00512 (test16.go:9)      MOVQ    ""..autotmp_4+160(SP), AX
0x0208 00520 (test16.go:9)      TESTQ   AX, AX
0x020b 00523 (test16.go:9)      JNE     302

// ......
```

这样，关于 map 迭代，底层的函数调用关系一目了然。先是调用 `mapiterinit` 函数初始化迭代器，然后循环调用 `mapiternext` 函数进行 map 迭代。

![map iter loop](https://golang.design/go-questions/map/assets/4.png)

迭代器的结构体定义：

```golang
type hiter struct {
	// key 指针
	key         unsafe.Pointer
	// value 指针
	value       unsafe.Pointer
	// map 类型，包含如 key size 大小等
	t           *maptype
	// map header
	h           *hmap
	// 初始化时指向的 bucket
	buckets     unsafe.Pointer
	// 当前遍历到的 bmap
	bptr        *bmap
	overflow    [2]*[]*bmap
	// 起始遍历的 bucket 编号
	startBucket uintptr
	// 遍历开始时 cell 的编号（每个 bucket 中有 8 个 cell）
	offset      uint8
	// 是否从头遍历了
	wrapped     bool
	// B 的大小
	B           uint8
	// 指示当前 cell 序号
	i           uint8
	// 指向当前的 bucket
	bucket      uintptr
	// 因为扩容，需要检查的 bucket
	checkBucket uintptr
}
```

`mapiterinit` 就是对 hiter 结构体里的字段进行初始化赋值操作。

前面已经提到过，即使是**对一个写死的 map 进行遍历，每次出来的结果也是无序的**。下面我们就可以近距离地观察他们的实现了。

```golang
// 生成随机数 r
r := uintptr(fastrand())
if h.B > 31-bucketCntBits {
	r += uintptr(fastrand()) << 31
}

// 从哪个 bucket 开始遍历
it.startBucket = r & (uintptr(1)<<h.B - 1)
// 从 bucket 的哪个 cell 开始遍历
it.offset = uint8(r >> h.B & (bucketCnt - 1))
```

例如，B = 2，那 `uintptr(1)<<h.B - 1` 结果就是 3，低 8 位为 `0000 0011`，将 r 与之相与，就可以得到一个 `0~3` 的 bucket 序号；bucketCnt - 1 等于 7，低 8 位为 `0000 0111`，将 r 右移 2 位后，与 7 相与，就可以得到一个 `0~7` 号的 cell。

于是，在 `mapiternext` 函数中就会从 it.startBucket 的 it.offset 号的 cell 开始遍历，取出其中的 key 和 value，直到又回到起点 bucket，完成遍历过程。

源码部分比较好看懂，尤其是理解了前面注释的几段代码后，再看这部分代码就没什么压力了。所以，接下来，我将通过图形化的方式讲解整个遍历过程，希望能够清晰易懂。

假设我们有下图所示的一个 map，起始时 B = 1，有两个 bucket，后来触发了扩容（这里不要深究扩容条件，只是一个设定），B 变成 2。并且， 1 号 bucket 中的内容搬迁到了新的 bucket，`1 号`裂变成 `1 号`和 `3 号`；`0 号` bucket 暂未搬迁。老的 bucket 挂在在 `*oldbuckets` 指针上面，新的 bucket 则挂在 `*buckets` 指针上面。

![map origin](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/5.png)

这时，我们对此 map 进行遍历。假设经过初始化后，startBucket = 3，offset = 2。于是，遍历的起点将是 3 号 bucket 的 2 号 cell，下面这张图就是开始遍历时的状态：

![map init](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/6.png)

标红的表示起始位置，bucket 遍历顺序为：3 -> 0 -> 1 -> 2。

因为 3 号 bucket 对应老的 1 号 bucket，因此先检查老 1 号 bucket 是否已经被搬迁过。判断方法就是：

```golang
func evacuated(b *bmap) bool {
	h := b.tophash[0]
	return h > empty && h < minTopHash
}
```

如果 b.tophash[0] 的值在标志值范围内，即在 (0,4) 区间里，说明已经被搬迁过了。

```golang
empty = 0
evacuatedEmpty = 1
evacuatedX = 2
evacuatedY = 3
minTopHash = 4
```

在本例中，老 1 号 bucket 已经被搬迁过了。所以它的 tophash[0] 值在 (0,4) 范围内，因此只用遍历新的 3 号 bucket。

依次遍历 3 号 bucket 的 cell，这时候会找到第一个非空的 key：元素 e。到这里，mapiternext 函数返回，这时我们的遍历结果仅有一个元素：

![iter res](https://golang.design/go-questions/map/assets/7.png)

由于返回的 key 不为空，所以会继续调用 mapiternext 函数。

继续从上次遍历到的地方往后遍历，从新 3 号 overflow bucket 中找到了元素 f 和 元素 g。

遍历结果集也因此壮大：

![iter res](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/8.png)

新 3 号 bucket 遍历完之后，回到了新 0 号 bucket。0 号 bucket 对应老的 0 号 bucket，经检查，老 0 号 bucket 并未搬迁，因此对新 0 号 bucket 的遍历就改为遍历老 0 号 bucket。那是不是把老 0 号 bucket 中的所有 key 都取出来呢？

并没有这么简单，回忆一下，老 0 号 bucket 在搬迁后将裂变成 2 个 bucket：新 0 号、新 2 号。而我们此时正在遍历的只是新 0 号 bucket（注意，遍历都是遍历的 `*bucket` 指针，也就是所谓的新 buckets）。所以，我们只会取出老 0 号 bucket 中那些在裂变之后，分配到新 0 号 bucket 中的那些 key。

因此，`lowbits == 00` 的将进入遍历结果集：

![iter res](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/9.png)

和之前的流程一样，继续遍历新 1 号 bucket，发现老 1 号 bucket 已经搬迁，只用遍历新 1 号 bucket 中现有的元素就可以了。结果集变成：

![iter res](https://golang.design/go-questions/map/assets/10.png)

继续遍历新 2 号 bucket，它来自老 0 号 bucket，因此需要在老 0 号 bucket 中那些会裂变到新 2 号 bucket 中的 key，也就是 `lowbit == 10` 的那些 key。

这样，遍历结果集变成：

![iter res](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/11.png)

最后，继续遍历到新 3 号 bucket 时，发现所有的 bucket 都已经遍历完毕，整个迭代过程执行完毕。

顺便说一下，如果碰到 key 是 `math.NaN()` 这种的，处理方式类似。核心还是要看它被分裂后具体落入哪个 bucket。只不过只用看它 top hash 的最低位。如果 top hash 的最低位是 0 ，分配到 X part；如果是 1 ，则分配到 Y part。据此决定是否取出 key，放到遍历结果集里。

map 遍历的核心在于理解 2 倍扩容时，老 bucket 会分裂到 2 个新 bucket 中去。而遍历操作，会按照新 bucket 的序号顺序进行，碰到老 bucket 未搬迁的情况时，要在老 bucket 中找到将来要搬迁到新 bucket 来的 key。

### 赋值

通过汇编语言可以看到，向 map 中插入或者修改 key，最终调用的是 `mapassign` 函数。

实际上插入或修改 key 的语法是一样的，只不过前者操作的 key 在 map 中不存在，而后者操作的 key 存在 map 中。

mapassign 有一个系列的函数，根据 key 类型的不同，编译器会将其优化为相应的“快速函数”。

| key 类型 | 插入                                                         |
| -------- | ------------------------------------------------------------ |
| uint32   | mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer |
| uint64   | mapassign_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer |
| string   | mapassign_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer |

我们只用研究最一般的赋值函数 `mapassign`。

整体来看，流程非常得简单：对 key 计算 hash 值，根据 hash 值按照之前的流程，找到要赋值的位置（可能是插入新 key，也可能是更新老 key），对相应位置进行赋值。

源码大体和之前讲的类似，核心还是一个双层循环，外层遍历 bucket 和它的 overflow bucket，内层遍历整个 bucket 的各个 cell。限于篇幅，这部分代码的注释我也不展示了，有兴趣的可以去看，保证理解了这篇文章内容后，能够看懂。

我这里会针对这个过程提几点重要的。

函数首先会检查 map 的标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行“写”操作，进而导致程序 panic。这也说明了 map 对协程是不安全的。

通过前文我们知道扩容是渐进式的，如果 map 处在扩容的过程中，那么当 key 定位到了某个 bucket 后，需要确保这个 bucket 对应的老 bucket 完成了迁移过程。即老 bucket 里的 key 都要迁移到新的 bucket 中来（分裂到 2 个新 bucket），才能在新的 bucket 中进行插入或者更新的操作。

上面说的操作是在函数靠前的位置进行的，只有进行完了这个搬迁操作后，我们才能放心地在新 bucket 里定位 key 要安置的地址，再进行之后的操作。

现在到了定位 key 应该放置的位置了，所谓找准自己的位置很重要。准备两个指针，一个（`inserti`）指向 key 的 hash 值在 tophash 数组所处的位置，另一个(`insertk`)指向 cell 的位置（也就是 key 最终放置的地址），当然，对应 value 的位置就很容易定位出来了。这三者实际上都是关联的，在 tophash 数组中的索引位置决定了 key 在整个 bucket 中的位置（共 8 个 key），而 value 的位置需要“跨过” 8 个 key 的长度。

在循环的过程中，inserti 和 insertk 分别指向第一个找到的空闲的 cell。如果之后在 map 没有找到 key 的存在，也就是说原来 map 中没有此 key，这意味着插入新 key。那最终 key 的安置地址就是第一次发现的“空位”（tophash 是 empty）。

如果这个 bucket 的 8 个 key 都已经放置满了，那在跳出循环后，发现 inserti 和 insertk 都是空，这时候需要在 bucket 后面挂上 overflow bucket。当然，也有可能是在 overflow bucket 后面再挂上一个 overflow bucket。这就说明，太多 key hash 到了此 bucket。

在正式安置 key 之前，还要检查 map 的状态，看它是否需要进行扩容。如果满足扩容的条件，就主动触发一次扩容操作。

这之后，整个之前的查找定位 key 的过程，还得再重新走一次。因为扩容之后，key 的分布都发生了变化。

最后，会更新 map 相关的值，如果是插入新 key，map 的元素数量字段 count 值会加 1；在函数之初设置的 `hashWriting` 写标志出会清零。

另外，有一个重要的点要说一下。前面说的找到 key 的位置，进行赋值操作，实际上并不准确。我们看 `mapassign` 函数的原型就知道，函数并没有传入 value 值，所以赋值操作是什么时候执行的呢？

```
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer
```

答案还得从汇编语言中寻找。我直接揭晓答案，有兴趣可以私下去研究一下。`mapassign` 函数返回的指针就是指向的 key 所对应的 value 值位置，有了地址，就很好操作赋值了。

### 删除

写操作底层的执行函数是 `mapdelete`：

`func mapdelete(t *maptype, h *hmap, key unsafe.Pointer)  `

根据 key 类型的不同，删除操作会被优化成更具体的函数：

| key 类型 | 删除                                              |
| -------- | ------------------------------------------------- |
| uint32   | mapdelete_fast32(t *maptype, h *hmap, key uint32) |
| uint64   | mapdelete_fast64(t *maptype, h *hmap, key uint64) |
| string   | mapdelete_faststr(t *maptype, h *hmap, ky string) |

当然，**我们只关心 `mapdelete` 函数。它首先会检查 h.flags 标志，如果发现写标位是 1，直接 panic，因为这表明有其他协程同时在进行写操作**。

计算 key 的哈希，找到落入的 bucket。检查此 map 如果正在扩容的过程中，直接触发一次搬迁操作。

**删除操作同样是两层循环，核心还是找到 key 的具体位置。寻找过程都是类似的，在 bucket 中挨个 cell 寻找。**

**找到对应位置后，对 key 或者 value 进行“清零”操作：**

```golang
// 对 key 清零
if t.indirectkey {
	*(*unsafe.Pointer)(k) = nil
} else {
	typedmemclr(t.key, k)
}

// 对 value 清零
if t.indirectvalue {
	*(*unsafe.Pointer)(v) = nil
} else {
	typedmemclr(t.elem, v)
}
```

**最后，将 count 值减 1，将对应位置的 tophash 值置成 `Empty`**。

这块源码同样比较简单，感兴起直接去看代码。

### 扩容

使用哈希表的目的就是要快速查找到目标 key，然而，随着向 map 中添加的 key 越来越多，key 发生碰撞的概率也越来越大。bucket 中的 8 个 cell 会被逐渐塞满，查找、插入、删除 key 的效率也会越来越低。最理想的情况是一个 bucket 只装一个 key，这样，就能达到 `O(1)` 的效率，但这样空间消耗太大，用空间换时间的代价太高。

Go 语言采用一个 bucket 里装载 8 个 key，定位到某个 bucket 后，还需要再定位到具体

的 key，这实际上又用了时间换空间。

当然，这样做，要有一个度，不然所有的 key 都落在了同一个 bucket 里，直接退化成了链表，各种操作的效率直接降为 O(n)，是不行的。

因此，需要有一个指标来衡量前面描述的情况，这就是`装载因子`。Go 源码里这样定义 `装载因子`：

```
 loadFactor := count / (2^B) 
```

count 就是 map 的元素个数，2^B 表示 bucket 数量。

再来说触发 map 扩容的时机：在向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会**触发扩容**：

1. **装载因子超过阈值，源码里定义的阈值是 6.5**。
2. **overflow 的 bucket 数量过多**：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B >= 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。

通过汇编语言可以找到赋值操作对应源码中的函数是 `mapassign`，对应扩容条件的源码如下：

```golang
// src/runtime/hashmap.go/mapassign

// 触发扩容时机
if !h.growing() && (overLoadFactor(int64(h.count), h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
		hashGrow(t, h)
	}

// 装载因子超过 6.5
func overLoadFactor(count int64, B uint8) bool {
	return count >= bucketCnt && float32(count) >= loadFactor*float32((uint64(1)<<B))
}

// overflow buckets 太多
func tooManyOverflowBuckets(noverflow uint16, B uint8) bool {
	if B < 16 {
		return noverflow >= uint16(1)<<B
	}
	return noverflow >= 1<<15
}
```

解释一下：

第 1 点：我们知道，**每个 bucket 有 8 个空位，在没有溢出，且所有的桶都装满了的情况下，装载因子算出来的结果是 8**。因此当装载因子超过 6.5 时，表明很多 bucket 都快要装满了，查找效率和插入效率都变低了。在这个时候进行扩容是有必要的。

第 2 点：是对第 1 点的补充。就是说在装载因子比较小的情况下，这时候 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。**表面现象就是计算装载因子的分子比较小，即 map 里元素总数少，但是 bucket 数量多（真实分配的 bucket 数量多，包括大量的 overflow bucket）**。

不难想像**造成这种情况的原因：不停地插入、删除元素。先插入很多元素，导致创建了很多 bucket，但是装载因子达不到第 1 点的临界值，未触发扩容来缓解这种情况。之后，删除元素降低元素总数量，再插入很多元素，导致创建很多的 overflow bucket**，但就是不会触犯第 1 点的规定，你能拿我怎么办？overflow bucket 数量太多，导致 key 会很分散，查找插入效率低得吓人，因此出台第 2 点规定。这就像是一座空城，房子很多，但是住户很少，都分散了，找起人来很困难。

**对于命中条件 1，2 的限制，都会发生扩容。但是扩容的策略并不相同，毕竟两种条件应对的场景不同。**

**对于条件 1，元素太多，而 bucket 数量太少**，很简单：**将 B 加 1，bucket 最大数量（2^B）直接变成原来 bucket 数量的 2 倍**。于是，就有新老 bucket 了。注意，这时候元素都在老 bucket 里，还没迁移到新的 bucket 来。而且，新 bucket 只是最大数量变为原来最大数量（2^B）的 2 倍（2^B * 2）。

**对于条件 2，其实元素没那么多，但是 overflow bucket 数特别多，说明很多 bucket 都没装满。解决办法就是开辟一个新 bucket 空间，将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。**这样，原来，在 overflow bucket 中的 key 可以移动到 bucket 中来。结果是节省空间，提高 bucket 利用率，map 的查找和插入效率自然就会提升。

对于条件 2 的解决方案，曹大的博客里还提出了一个极端的情况：如果插入 map 的 key 哈希都一样，就会落到同一个 bucket 里，超过 8 个就会产生 overflow bucket，结果也会造成 overflow bucket 数过多。移动元素其实解决不了问题，因为这时整个哈希表已经退化成了一个链表，操作效率变成了 `O(n)`。

再来看一下扩容具体是怎么做的。由于 map 扩容需要将原有的 key/value 重新搬迁到新的内存地址，如果有大量的 key/value 需要搬迁，会非常影响性能。因此 **Go map 的扩容采取了一种称为“渐进式”地方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。**

上面说**的 `hashGrow()` 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 `growWork()` 函数中，而调用 `growWork()` 函数的动作是在 mapassign 和 mapdelete 函数中。也就是插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil。**

我们先看 `hashGrow()` 函数所做的工作，再来看具体的搬迁 buckets 是如何进行的。

```golang
func hashGrow(t *maptype, h *hmap) {
	// B+1 相当于是原来 2 倍的空间
	bigger := uint8(1)

	// 对应条件 2
	if !overLoadFactor(int64(h.count), h.B) {
		// 进行等量的内存扩容，所以 B 不变
		bigger = 0
		h.flags |= sameSizeGrow
	}
	// 将老 buckets 挂到 buckets 上
	oldbuckets := h.buckets
	// 申请新的 buckets 空间
	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger)

	flags := h.flags &^ (iterator | oldIterator)
	if h.flags&iterator != 0 {
		flags |= oldIterator
	}
	// 提交 grow 的动作
	h.B += bigger
	h.flags = flags
	h.oldbuckets = oldbuckets
	h.buckets = newbuckets
	// 搬迁进度为 0
	h.nevacuate = 0
	// overflow buckets 数为 0
	h.noverflow = 0

	// ……
}
```

主要是申请到了新的 buckets 空间，把相关的标志位都进行了处理：例如标志 nevacuate 被置为 0， 表示当前搬迁进度为 0。

值得一说的是对 `h.flags` 的处理：

```golang
flags := h.flags &^ (iterator | oldIterator)
if h.flags&iterator != 0 {
	flags |= oldIterator
}
```

这里得先说下运算符：&^。这叫`按位置 0`运算符。例如：

```golang
x = 01010011
y = 01010100
z = x &^ y = 00000011
```

如果 y bit 位为 1，那么结果 z 对应 bit 位就为 0，否则 z 对应 bit 位就和 x 对应 bit 位的值相同。

所以上面那段对 flags 一顿操作的代码的意思是：先把 h.flags 中 iterator 和 oldIterator 对应位清 0，然后如果发现 iterator 位为 1，那就把它转接到 oldIterator 位，使得 oldIterator 标志位变成 1。潜台词就是：buckets 现在挂到了 oldBuckets 名下了，对应的标志位也转接过去吧。

几个标志位如下：

```golang
// 可能有迭代器使用 buckets
iterator     = 1
// 可能有迭代器使用 oldbuckets
oldIterator  = 2
// 有协程正在向 map 中写入 key
hashWriting  = 4
// 等量扩容（对应条件 2）
sameSizeGrow = 8
```

再来看看真正执行搬迁工作的 growWork() 函数。

```golang
func growWork(t *maptype, h *hmap, bucket uintptr) {
	// 确认搬迁老的 bucket 对应正在使用的 bucket
	evacuate(t, h, bucket&h.oldbucketmask())

	// 再搬迁一个 bucket，以加快搬迁进程
	if h.growing() {
		evacuate(t, h, h.nevacuate)
	}
}
```

h.growing() 函数非常简单：

```golang
func (h *hmap) growing() bool {
	return h.oldbuckets != nil
}
```

如果 `oldbuckets` 不为空，说明还没有搬迁完毕，还得继续搬。

`bucket&h.oldbucketmask()` 这行代码，如源码注释里说的，是为了确认搬迁的 bucket 是我们正在使用的 bucket。`oldbucketmask()` 函数返回扩容前的 map 的 bucketmask。

所谓的 bucketmask，作用就是将 key 计算出来的哈希值与 bucketmask 相与，得到的结果就是 key 应该落入的桶。比如 B = 5，那么 bucketmask 的低 5 位是 `11111`，其余位是 `0`，hash 值与其相与的意思是，只有 hash 值的低 5 位决策 key 到底落入哪个 bucket。

接下来，我们集中所有的精力在搬迁的关键函数 evacuate。源码贴在下面，不要紧张，我会加上大面积的注释，通过注释绝对是能看懂的。之后，我会再对搬迁过程作详细说明。

源码如下：

```golang
func evacuate(t *maptype, h *hmap, oldbucket uintptr) {
	// 定位老的 bucket 地址
	b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
	// 结果是 2^B，如 B = 5，结果为32
	newbit := h.noldbuckets()
	// key 的哈希函数
	alg := t.key.alg
	// 如果 b 没有被搬迁过
	if !evacuated(b) {
		var (
			// 表示bucket 移动的目标地址
			x, y   *bmap
			// 指向 x,y 中的 key/val
			xi, yi int
			// 指向 x，y 中的 key
			xk, yk unsafe.Pointer
			// 指向 x，y 中的 value
			xv, yv unsafe.Pointer
		)
		// 默认是等 size 扩容，前后 bucket 序号不变
		// 使用 x 来进行搬迁
		x = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
		xi = 0
		xk = add(unsafe.Pointer(x), dataOffset)
		xv = add(xk, bucketCnt*uintptr(t.keysize))、

		// 如果不是等 size 扩容，前后 bucket 序号有变
		// 使用 y 来进行搬迁
		if !h.sameSizeGrow() {
			// y 代表的 bucket 序号增加了 2^B
			y = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
			yi = 0
			yk = add(unsafe.Pointer(y), dataOffset)
			yv = add(yk, bucketCnt*uintptr(t.keysize))
		}

		// 遍历所有的 bucket，包括 overflow buckets
		// b 是老的 bucket 地址
		for ; b != nil; b = b.overflow(t) {
			k := add(unsafe.Pointer(b), dataOffset)
			v := add(k, bucketCnt*uintptr(t.keysize))

			// 遍历 bucket 中的所有 cell
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
				// 当前 cell 的 top hash 值
				top := b.tophash[i]
				// 如果 cell 为空，即没有 key
				if top == empty {
					// 那就标志它被"搬迁"过
					b.tophash[i] = evacuatedEmpty
					// 继续下个 cell
					continue
				}
				// 正常不会出现这种情况
				// 未被搬迁的 cell 只可能是 empty 或是
				// 正常的 top hash（大于 minTopHash）
				if top < minTopHash {
					throw("bad map state")
				}

				k2 := k
				// 如果 key 是指针，则解引用
				if t.indirectkey {
					k2 = *((*unsafe.Pointer)(k2))
				}

				// 默认使用 X，等量扩容
				useX := true
				// 如果不是等量扩容
				if !h.sameSizeGrow() {
					// 计算 hash 值，和 key 第一次写入时一样
					hash := alg.hash(k2, uintptr(h.hash0))

					// 如果有协程正在遍历 map
					if h.flags&iterator != 0 {
						// 如果出现 相同的 key 值，算出来的 hash 值不同
						if !t.reflexivekey && !alg.equal(k2, k2) {
							// 只有在 float 变量的 NaN() 情况下会出现
							if top&1 != 0 {
								// 第 B 位置 1
								hash |= newbit
							} else {
								// 第 B 位置 0
								hash &^= newbit
							}
							// 取高 8 位作为 top hash 值
							top = uint8(hash >> (sys.PtrSize*8 - 8))
							if top < minTopHash {
								top += minTopHash
							}
						}
					}

					// 取决于新哈希值的 oldB+1 位是 0 还是 1
					// 详细看后面的文章
					useX = hash&newbit == 0
				}

				// 如果 key 搬到 X 部分
				if useX {
					// 标志老的 cell 的 top hash 值，表示搬移到 X 部分
					b.tophash[i] = evacuatedX
					// 如果 xi 等于 8，说明要溢出了
					if xi == bucketCnt {
						// 新建一个 bucket
						newx := h.newoverflow(t, x)
						x = newx
						// xi 从 0 开始计数
						xi = 0
						// xk 表示 key 要移动到的位置
						xk = add(unsafe.Pointer(x), dataOffset)
						// xv 表示 value 要移动到的位置
						xv = add(xk, bucketCnt*uintptr(t.keysize))
					}
					// 设置 top hash 值
					x.tophash[xi] = top
					// key 是指针
					if t.indirectkey {
						// 将原 key（是指针）复制到新位置
						*(*unsafe.Pointer)(xk) = k2 // copy pointer
					} else {
						// 将原 key（是值）复制到新位置
						typedmemmove(t.key, xk, k) // copy value
					}
					// value 是指针，操作同 key
					if t.indirectvalue {
						*(*unsafe.Pointer)(xv) = *(*unsafe.Pointer)(v)
					} else {
						typedmemmove(t.elem, xv, v)
					}

					// 定位到下一个 cell
					xi++
					xk = add(xk, uintptr(t.keysize))
					xv = add(xv, uintptr(t.valuesize))
				} else { // key 搬到 Y 部分，操作同 X 部分
					// ……
					// 省略了这部分，操作和 X 部分相同
				}
			}
		}
		// 如果没有协程在使用老的 buckets，就把老 buckets 清除掉，帮助gc
		if h.flags&oldIterator == 0 {
			b = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
			// 只清除bucket 的 key,value 部分，保留 top hash 部分，指示搬迁状态
			if t.bucket.kind&kindNoPointers == 0 {
				memclrHasPointers(add(unsafe.Pointer(b), dataOffset), uintptr(t.bucketsize)-dataOffset)
			} else {
				memclrNoHeapPointers(add(unsafe.Pointer(b), dataOffset), uintptr(t.bucketsize)-dataOffset)
			}
		}
	}

	// 更新搬迁进度
	// 如果此次搬迁的 bucket 等于当前进度
	if oldbucket == h.nevacuate {
		// 进度加 1
		h.nevacuate = oldbucket + 1
		// Experiments suggest that 1024 is overkill by at least an order of magnitude.
		// Put it in there as a safeguard anyway, to ensure O(1) behavior.
		// 尝试往后看 1024 个 bucket
		stop := h.nevacuate + 1024
		if stop > newbit {
			stop = newbit
		}
		// 寻找没有搬迁的 bucket
		for h.nevacuate != stop && bucketEvacuated(t, h, h.nevacuate) {
			h.nevacuate++
		}
		
		// 现在 h.nevacuate 之前的 bucket 都被搬迁完毕
		
		// 所有的 buckets 搬迁完毕
		if h.nevacuate == newbit {
			// 清除老的 buckets
			h.oldbuckets = nil
			// 清除老的 overflow bucket
			// 回忆一下：[0] 表示当前 overflow bucket
			// [1] 表示 old overflow bucket
			if h.extra != nil {
				h.extra.overflow[1] = nil
			}
			// 清除正在扩容的标志位
			h.flags &^= sameSizeGrow
		}
	}
}
```

evacuate 函数的代码注释非常清晰，对着代码和注释是很容易看懂整个的搬迁过程的，耐心点。

搬迁的目的就是将老的 buckets 搬迁到新的 buckets。而通过前面的说明我们知道，应对条件 1，新的 buckets 数量是之前的一倍，应对条件 2，新的 buckets 数量和之前相等。

对于条件 2，从老的 buckets 搬迁到新的 buckets，由于 bucktes 数量不变，因此可以按序号来搬，比如原来在 0 号 bucktes，到新的地方后，仍然放在 0 号 buckets。

对于条件 1，就没这么简单了。要重新计算 key 的哈希，才能决定它到底落在哪个 bucket。例如，原来 B = 5，计算出 key 的哈希后，只用看它的低 5 位，就能决定它落在哪个 bucket。扩容后，B 变成了 6，因此需要多看一位，它的低 6 位决定 key 落在哪个 bucket。这称为 `rehash`。

![map rehash](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/12.png)

因此，某个 key 在搬迁前后 bucket 序号可能和原来相等，也可能是相比原来加上 2^B（原来的 B 值），取决于 hash 值 第 6 bit 位是 0 还是 1。

再明确一个问题：如果扩容后，B 增加了 1，意味着 buckets 总数是原来的 2 倍，原来 1 号的桶“裂变”到两个桶。

例如，原始 B = 2，1号 bucket 中有 2 个 key 的哈希值低 3 位分别为：010，110。由于原来 B = 2，所以低 2 位 `10` 决定它们落在 2 号桶，现在 B 变成 3，所以 `010`、`110` 分别落入 2、6 号桶。

![bucket split](https://golang.design/go-questions/map/assets/13.png)

理解了这个，后面讲 map 迭代的时候会用到。

再来讲搬迁函数中的几个关键点：

evacuate 函数每次只完成一个 bucket 的搬迁工作，因此要遍历完此 bucket 的所有的 cell，将有值的 cell copy 到新的地方。bucket 还会链接 overflow bucket，它们同样需要搬迁。因此会有 2 层循环，外层遍历 bucket 和 overflow bucket，内层遍历 bucket 的所有 cell。这样的循环在 map 的源码里到处都是，要理解透了。

源码里提到 X, Y part，其实就是我们说的如果是扩容到原来的 2 倍，桶的数量是原来的 2 倍，前一半桶被称为 X part，后一半桶被称为 Y part。一个 bucket 中的 key 可能会分裂落到 2 个桶，一个位于 X part，一个位于 Y part。所以在搬迁一个 cell 之前，需要知道这个 cell 中的 key 是落到哪个 Part。很简单，重新计算 cell 中 key 的 hash，并向前“多看”一位，决定落入哪个 Part，这个前面也说得很详细了。

有一个特殊情况是：有一种 key，每次对它计算 hash，得到的结果都不一样。这个 key 就是 `math.NaN()` 的结果，它的含义是 `not a number`，类型是 float64。当它作为 map 的 key，在搬迁的时候，会遇到一个问题：再次计算它的哈希值和它当初插入 map 时的计算出来的哈希值不一样！

你可能想到了，这样带来的一个后果是，这个 key 是永远不会被 Get 操作获取的！当我使用 `m[math.NaN()]` 语句的时候，是查不出来结果的。这个 key 只有在遍历整个 map 的时候，才有机会现身。所以，可以向一个 map 插入任意数量的 `math.NaN()` 作为 key。

当搬迁碰到 `math.NaN()` 的 key 时，只通过 tophash 的最低位决定分配到 X part 还是 Y part（如果扩容后是原来 buckets 数量的 2 倍）。如果 tophash 的最低位是 0 ，分配到 X part；如果是 1 ，则分配到 Y part。

这是通过 tophash 值与新算出来的哈希值进行运算得到的：

```golang
if top&1 != 0 {
    // top hash 最低位为 1
    // 新算出来的 hash 值的 B 位置 1
	hash |= newbit
} else {
    // 新算出来的 hash 值的 B 位置 0
	hash &^= newbit
}

// hash 值的 B 位为 0，则搬迁到 x part
// 当 B = 5时，newbit = 32，二进制低 6 位为 10 0000
useX = hash&newbit == 0
```

其实这样的 key 我随便搬迁到哪个 bucket 都行，当然，还是要搬迁到上面裂变那张图中的两个 bucket 中去。但这样做是有好处的，在后面讲 map 迭代的时候会再详细解释，暂时知道是这样分配的就行。

确定了要搬迁到的目标 bucket 后，搬迁操作就比较好进行了。将源 key/value 值 copy 到目的地相应的位置。

设置 key 在原始 buckets 的 tophash 为 `evacuatedX` 或是 `evacuatedY`，表示已经搬迁到了新 map 的 x part 或是 y part。新 map 的 tophash 则正常取 key 哈希值的高 8 位。

下面通过图来宏观地看一下扩容前后的变化。

扩容前，B = 2，共有 4 个 buckets，lowbits 表示 hash 值的低位。假设我们不关注其他 buckets 情况，专注在 2 号 bucket。并且假设 overflow 太多，触发了等量扩容（对应于前面的条件 2）。

![扩容前](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/14.png)

扩容完成后，overflow bucket 消失了，key 都集中到了一个 bucket，更为紧凑了，提高了查找的效率。

![same size 扩容](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/15.png)

假设触发了 2 倍的扩容，那么扩容完成后，老 buckets 中的 key 分裂到了 2 个 新的 bucket。一个在 x part，一个在 y 的 part。依据是 hash 的 lowbits。新 map 中 `0-3` 称为 x part，`4-7` 称为 y part。

![2倍扩容](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/16.png)

注意，上面的两张图忽略了其他 buckets 的搬迁情况，表示所有的 bucket 都搬迁完毕后的情形。实际上，我们知道，搬迁是一个“渐进”的过程，并不会一下子就全部搬迁完毕。所以在搬迁过程中，oldbuckets 指针还会指向原来老的 []bmap，并且已经搬迁完毕的 key 的 tophash 值会是一个状态值，表示 key 的搬迁去向。

### 无序的key

map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。

当然，如果我就一个 hard code 的 map，我也不会向 map 进行插入删除的操作，按理说每次遍历这样的 map 都会返回一个固定顺序的 key/value 序列吧。的确是这样，但是 Go 杜绝了这种做法，因为这样会给新手程序员带来误解，以为这是一定会发生的事情，在某些情况下，可能会酿成大错。

当然，Go 做得更绝，**当我们在遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，并且是从这个 bucket 的一个随机序号的 cell 开始遍历**。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key/value 对了。

多说一句，“迭代 map 的结果是无序的”这个特性是从 go 1.0 开始加入的。

### key的类型

从语法上看，是可以的。Go 语言中只要是**可比较的类型**都可以作为 key。**除开 slice，map，functions 这几种类型**，其他类型都是 OK 的。具体包括：**布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组**。这些类型的共同特征是支持 `==` 和 `!=` 操作符，`k1 == k2` 时，可认为 k1 和 k2 是同一个 key。**如果是结构体，只有 hash 后的值相等以及字面值相等，才被认为是相同的 key**。很多字面值相等的，hash出来的值不一定相等，比如引用。

顺便说一句，任何类型都可以作为 value，包括 map 类型。

### **map 并不是一个线程安全的数据结构**

同时**读写一个 map 是未定义的行为，如果被检测到，会直接 panic**。

#### [如何检测Map并发异常](https://mp.weixin.qq.com/s/dZIcI_3b8N8a2_nzJ7fNOA)

在Go源码map.go中，可以看到以下flags：

```
// flags
iterator     = 1 // there may be an iterator using buckets
oldIterator  = 2 // there may be an iterator using oldbuckets
hashWriting  = 4 // a goroutine is writing to the map
sameSizeGrow = 8 // the current map growth is to a new map of the same size
```

在源码中mapaccess1、mapaccess2都用于查询mapassign和mapdelete用于修改。

对于查询操作，大致检查并发错误的流程如下：**在查询前检查并发flag是否存在，如果存在就抛出异常**。

```
if h.flags&hashWriting != 0 {
    throw("concurrent map read and map write")
}
```

对于修改操作则如下：

- **写入前检查一次标记位，通过后打上标记。**

- **写入完成再次检查标记位，通过后还原标记。**

```
//各类前置操作
....
if h.flags&amp;hashWriting != 0 {
//检查是否存在并发
throw("concurrent map writes")
}

//赋值标记位
h.flags ^= hashWriting
....
//后续操作
done:
//完成修改后，再次检查标记位
if h.flags&hashWriting == 0 {
throw("concurrent map writes")
}
//还原标记位取消hashWriting标记
h.flags &^= hashWriting
```

上面说的是发生在多个协程同时读写同一个 map 的情况下。 如果在同一个协程内边遍历边删除，并不会检测到同时读写，理论上是可以这样做的。但是，遍历的结果就可能不会是相同的了，有可能结果遍历结果集中包含了删除的 key，也有可能不包含，这取决于删除 key 的时间：是在遍历到 key 所在的 bucket 时刻前或者后。

一般而言，这可以通过读写锁来解决：`sync.RWMutex`。

读之前调用 `RLock()` 函数，读完之后调用 `RUnlock()` 函数解锁；写之前调用 `Lock()` 函数，写完之后，调用 `Unlock()` 解锁。

另外，`sync.Map` 是线程安全的 map，也可以使用。

### 无法对 map 的 key 或 value 进行取址。

```golang
package main

import "fmt"

func main() {
	m := make(map[string]int)

	fmt.Println(&m["qcrao"])
}
```

编译报错：

```shell
./main.go:8:14: cannot take the address of m["qcrao"]
```

如果通过其他 hack 的方式，例如 unsafe.Pointer 等获取到了 key 或 value 的地址，也不能长期持有，**因为一旦发生扩容，key 和 value 的位置就会改变，之前保存的地址也就失效了**。

在查找、赋值、遍历、删除的过程中都会检测写标志，一旦发现写标志置位（等于1），则直接 panic。赋值和删除函数在检测完写标志是复位之后，先将写标志位置位，才会进行之后的操作。

### map比较

map 深度相等的条件：

1、都为 nil 

2、非空、长度相等，指向同一个 map 实体对象 

3、相应的 key 指向的 value “深度”相等 

直接将使用 map1 == map2 是错误的。这种写法只能比较 map 是否为 nil。

```golang
package main

import "fmt"

func main() {
	var m map[string]int
	var n map[string]int

	fmt.Println(m == nil)
	fmt.Println(n == nil)

	// 不能通过编译
	//fmt.Println(m == n)
}
```

输出结果：

```golang
true
true
```

因此**只能是遍历map 的每个元素，比较元素是否都是深度相等**。

### map的线程安全

[参考](https://zhuanlan.zhihu.com/p/356739568)

#### 原子操作

```
func addMap2() {
	for atomic.LoadInt64(&flag) != 0 {
	}
	atomic.AddInt64(&flag, 1)
	test[1] = 2
	atomic.AddInt64(&flag, -1)
}

func delMap2() {
	for atomic.LoadInt64(&flag) != 0 {
	}
	atomic.AddInt64(&flag, 1)
	delete(test, 1)
	atomic.AddInt64(&flag, -1)
}

var flag int64 = 0

func Test_Map2(t *testing.T) {
	test = map[int]int{1: 20}
	go delMap2()
	go addMap2()
	time.Sleep(6 * time.Millisecond)
	fmt.Println(test)
}
```

通过多次试验也能得到不同结果

#### channel操作

```
func addMap(start chan interface{}) {
	<-start
	test[1] = 2
	start <- struct{}{}

}

var test map[int]int

func delMap(start chan interface{}) {
	<-start
	delete(test, 1)
	start <- struct{}{}

}

func Test_Map(t *testing.T) {
	start := make(chan interface{}, 1)
	start <- struct{}{}
	test = map[int]int{1: 20}
	go addMap(start)
	go delMap(start)
	time.Sleep(6 * time.Millisecond)
	fmt.Println(test)
}
```

多次测试能够出现两种结果

#### 加读写锁

#### 分片加锁

#### sync.map

[地址](https://github.com/Simin-hub/Golang-Learning-and-Interview/blob/main/Go/%E6%A0%87%E5%87%86%E5%BA%93/sync.md#type-map)



### Map原地修改value

[参考](https://www.jianshu.com/p/30e86473bdce)、[参考](https://blog.csdn.net/qq_37102984/article/details/121292529)

**map中修改key对应结构体类型value值时**，报错 error: Cannot assign to xxxx

**原因**：

 **map 元素是无法取址的**，也就是能取到 value=user1[key], 但不能修改value。（在bucket中，是以数组的形式存储数据）

**解决**：

使用指针结构map。**go map底层是"哈希表（数组+链表）**"，时间复杂度为O(1)。

**根因**：

go中的map, **当通过key获取到value时，这个value是不可寻址**的，因为map会进行动态扩容，当进行扩容后，map的value就会进行内存迁移，其地址发生变化，所以无法对这个value进行寻址。因此不能直接修改value。

map与slice比较：map的扩容与slice不同，那么map本身是引用类型，作为形参或返回参数的时候，传递的是值的拷贝，而值是地址，扩容时也不会改变这个地址。而slice的扩容，会导致地址的变化。

#### 示例

在Go语言中，Map中的值是不可以原地修改的，如：

```go
package main

type Student struct {
    Name string
    Id int
}

func main() {
    s := make(map[string]Student)
    s["chenchao"] = Student{
        Name:"chenchao",
        Id:111,
    }
    s["chenchao"].Id = 222

}
```

上面的代码会编译失败，因为在go中 map中的赋值属于值copy，就是在赋值的时候是把Student的完全复制了一份，复制给了map。而在go语言中，是不允许将其修改的。

但是如果map的value为int，是可以修改的，因为修改map中的int属于赋值的操作。

```go
package main

type Student struct {
    Name string
    Id int
}

func main() {
    s1 := make(map[string]int)
    s1["chenchao"] = 2
    s1["chenchao"] = 3
}
```

那么，如何在go语言中原地修改map中的value呢？ 答案是：传指针！

```go
package main

import "fmt"

type Student struct {
    Name string
    Id int
}

func main() {
    s := make(map[string]*Student)
    s["chenchao"] = &Student{
        Name:"chenchao",
        Id:111,
    }
    s["chenchao"].Id = 222
    fmt.Println(s)
}
```

在结构体比较大的时候，用指针效率会更好，因为不需要值copy

当然，如果map中的value为 *int指针类型，那么在赋值时不可以用&123，因为int为常亮，不占内存，没有内存地址

```go
package main

import "fmt"

type Student struct {
    Name string
    Id int
}

func main() {
    s2 := make(map[string]*int)
    n := 1
    s2["chenchao"] = &n
    fmt.Println(s2)
}
```

## channel

[**参考**](http://golang.design/go-questions/channel/csp/)

### 初始化

```
/ path: src/runtime/chan.go
func makechan(t *chantype, size int) *hchan {
   ...
   var c *hchan
    
   // 针对不同情况下对 channel 实行不同的内存分配策略
   switch {
   case mem == 0:
      // 无缓冲区,只给 hchan 分配一段内存
      c = (*hchan)(mallocgc(hchanSize, nil, true))
      c.buf = c.raceaddr()
   case elem.ptrdata == 0:
      // channel 不包含指针，给 hchan 和 缓冲区分配一段连续的内存
      c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
      c.buf = add(unsafe.Pointer(c), hchanSize)
   default:
      // 单独给 hchan 和 缓冲区分配内存
      c = new(hchan)
      c.buf = mallocgc(mem, elem, true)
   }

   // 初始化 hchan 的内部字段 
   c.elemsize = uint16(elem.size)
   c.elemtype = elem
   c.dataqsiz = uint(size)
   ...
}
```

make channel 得到的是一个指向`hchan`的指针

### 底层数据结构

```golang
type hchan struct {
	// chan 里元素数量
	qcount   uint
	// chan 底层循环数组的长度
	dataqsiz uint
	// 指向底层循环数组的指针
	// 只针对有缓冲的 channel
	buf      unsafe.Pointer
	// chan 中元素大小
	elemsize uint16
	// chan 是否被关闭的标志
	closed   uint32
	// chan 中元素类型
	elemtype *_type // element type
	// 已发送元素在循环数组中的索引
	sendx    uint   // send index
	// 已接收元素在循环数组中的索引
	recvx    uint   // receive index
	// 等待接收的 goroutine 队列
	recvq    waitq  // list of recv waiters
	// 等待发送的 goroutine 队列
	sendq    waitq  // list of send waiters

	// 保护 hchan 中所有字段
	lock mutex
}
```

`buf` 指向底层循环数组，**只有缓冲型的 channel 才有**。

`sendx`，`recvx` **均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）**。

`sendq`，`recvq` **分别表示被阻塞的 goroutine**，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。

`waitq` 是 `sudog` 的一个双向链表，而 `sudog` 实际上是对 goroutine 的一个封装：

```golang
type waitq struct {
	first *sudog
	last  *sudog
}
```

`lock` 用来保证每个读 channel 或写 channel 的操作都是原子的。

例如，创建一个容量为 6 的，元素为 int 型的 channel 数据结构如下 ：

![chan data structure](https://golang.design/go-questions/channel/assets/0.png)

### 创建

通道有两个方向，发送和接收。理论上来说，我们可以创建一个只发送或只接收的通道，但是这种通道创建出来后，怎么使用呢？一个只能发的通道，怎么接收呢？同样，一个只能收的通道，如何向其发送数据呢？

一般而言，使用 `make` 创建一个能收能发的通道：

```golang
// 无缓冲通道
ch1 := make(chan int)
// 有缓冲通道
ch2 := make(chan int, 10)
```

通过[汇编](https://mp.weixin.qq.com/s/obnnVkO2EiFnuXk_AIDHWw)分析，我们知道，最终创建 chan 的函数是 `makechan`：

```golang
func makechan(t *chantype, size int64) *hchan
```

从函数原型来看，**创建的 chan 是一个指针。所以我们能在函数间直接传递 channel，而不用传递 channel 的指针**。

具体来看下代码：

```golang
const hchanSize = unsafe.Sizeof(hchan{}) + uintptr(-int(unsafe.Sizeof(hchan{}))&(maxAlign-1))

func makechan(t *chantype, size int64) *hchan {
	elem := t.elem

	// 省略了检查 channel size，align 的代码
	// ……

	var c *hchan
	// 如果元素类型不含指针 或者 size 大小为 0（无缓冲类型）
	// 只进行一次内存分配
	if elem.kind&kindNoPointers != 0 || size == 0 {
		// 如果 hchan 结构体中不含指针，GC 就不会扫描 chan 中的元素
		// 只分配 "hchan 结构体大小 + 元素大小*个数" 的内存
		c = (*hchan)(mallocgc(hchanSize+uintptr(size)*elem.size, nil, true))
		// 如果是缓冲型 channel 且元素大小不等于 0（大小等于 0的元素类型：struct{}）
		if size > 0 && elem.size != 0 {
			c.buf = add(unsafe.Pointer(c), hchanSize)
		} else {
			// race detector uses this location for synchronization
			// Also prevents us from pointing beyond the allocation (see issue 9401).
			// 1. 非缓冲型的，buf 没用，直接指向 chan 起始地址处
			// 2. 缓冲型的，能进入到这里，说明元素无指针且元素类型为 struct{}，也无影响
			// 因为只会用到接收和发送游标，不会真正拷贝东西到 c.buf 处（这会覆盖 chan的内容）
			c.buf = unsafe.Pointer(c)
		}
	} else {
		// 进行两次内存分配操作
		c = new(hchan)
		c.buf = newarray(elem, int(size))
	}
	c.elemsize = uint16(elem.size)
	c.elemtype = elem
	// 循环数组长度
	c.dataqsiz = uint(size)

	// 返回 hchan 指针
	return c
}
```

新建一个 chan 后，内存在堆上分配，大概长这样：

![make chan](https://golang.design/go-questions/channel/assets/1.png)

### 发送数据

发送操作最终转化为 `chansend` 函数，直接上源码，同样大部分都注释了，可以看懂主流程

```golang
// 位于 src/runtime/chan.go

func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
	// 如果 channel 是 nil
	if c == nil {
		// 不能阻塞，直接返回 false，表示未发送成功
		if !block {
			return false
		}
		// 当前 goroutine 被挂起
		gopark(nil, nil, "chan send (nil chan)", traceEvGoStop, 2)
		throw("unreachable")
	}

	// 省略 debug 相关……

	// 对于不阻塞的 send，快速检测失败场景
	//
	// 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：
	// 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine
	// 2. channel 是缓冲型的，但循环数组已经装满了元素
	if !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) ||
		(c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {
		return false
	}

	var t0 int64
	if blockprofilerate > 0 {
		t0 = cputicks()
	}

	// 锁住 channel，并发安全
	lock(&c.lock)

	// 如果 channel 关闭了
	if c.closed != 0 {
		// 解锁
		unlock(&c.lock)
		// 直接 panic
		panic(plainError("send on closed channel"))
	}

	// 如果接收队列里有 goroutine，直接将要发送的数据拷贝到接收 goroutine
	if sg := c.recvq.dequeue(); sg != nil {
		send(c, sg, ep, func() { unlock(&c.lock) }, 3)
		return true
	}

	// 对于缓冲型的 channel，如果还有缓冲空间
	if c.qcount < c.dataqsiz {
		// qp 指向 buf 的 sendx 位置
		qp := chanbuf(c, c.sendx)

		// ……

		// 将数据从 ep 处拷贝到 qp
		typedmemmove(c.elemtype, qp, ep)
		// 发送游标值加 1
		c.sendx++
		// 如果发送游标值等于容量值，游标值归 0
		if c.sendx == c.dataqsiz {
			c.sendx = 0
		}
		// 缓冲区的元素数量加一
		c.qcount++

		// 解锁
		unlock(&c.lock)
		return true
	}

	// 如果不需要阻塞，则直接返回错误
	if !block {
		unlock(&c.lock)
		return false
	}

	// channel 满了，发送方会被阻塞。接下来会构造一个 sudog

	// 获取当前 goroutine 的指针
	gp := getg()
	mysg := acquireSudog()
	mysg.releasetime = 0
	if t0 != 0 {
		mysg.releasetime = -1
	}

	mysg.elem = ep
	mysg.waitlink = nil
	mysg.g = gp
	mysg.selectdone = nil
	mysg.c = c
	gp.waiting = mysg
	gp.param = nil

	// 当前 goroutine 进入发送等待队列
	c.sendq.enqueue(mysg)

	// 当前 goroutine 被挂起
	goparkunlock(&c.lock, "chan send", traceEvGoBlockSend, 3)

	// 从这里开始被唤醒了（channel 有机会可以发送了）
	if mysg != gp.waiting {
		throw("G waiting list is corrupted")
	}
	gp.waiting = nil
	if gp.param == nil {
		if c.closed == 0 {
			throw("chansend: spurious wakeup")
		}
		// 被唤醒后，channel 关闭了。坑爹啊，panic
		panic(plainError("send on closed channel"))
	}
	gp.param = nil
	if mysg.releasetime > 0 {
		blockevent(mysg.releasetime-t0, 2)
	}
	// 去掉 mysg 上绑定的 channel
	mysg.c = nil
	releaseSudog(mysg)
	return true
}
```

上面的代码注释地比较详细了，我们来详细看看。

- 如果检测到 channel 是空的，当前 goroutine 会被挂起。
- 对于不阻塞的发送操作，如果 channel 未关闭并且没有多余的缓冲空间（说明：a. channel 是非缓冲型的，且等待接收队列里没有 goroutine；b. channel 是缓冲型的，但循环数组已经装满了元素）

对于这一点，runtime 源码里注释了很多。这一条判断语句是为了在不阻塞发送的场景下快速检测到发送失败，好快速返回。

![runtime-chansend.png](https://blog.frognew.com/images/2021/11/runtime-chansend.png)

### 接收数据

接收操作有两种写法，一种带 “ok”，反应 channel 是否关闭；一种不带 “ok”，这种写法，当接收到相应类型的零值时无法知道是真实的发送者发送过来的值，还是 channel 被关闭后，返回给接收者的默认类型的零值。两种写法，都有各自的应用场景。

经过编译器的处理后，这两种写法最后对应源码里的这两个函数：

```golang
// entry points for <- c from compiled code
func chanrecv1(c *hchan, elem unsafe.Pointer) {
	chanrecv(c, elem, true)
}

func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) {
	_, received = chanrecv(c, elem, true)
	return
}
```

`chanrecv1` 函数处理不带 “ok” 的情形，`chanrecv2` 则通过返回 “received” 这个字段来反应 channel 是否被关闭。接收值则比较特殊，会“放到”参数 `elem` 所指向的地址了，这很像 C/C++ 里的写法。如果代码里忽略了接收值，这里的 elem 为 nil。

无论如何，最终转向了 `chanrecv` 函数：

```golang
// 位于 src/runtime/chan.go

// chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。
// 如果 ep 是 nil，说明忽略了接收值。
// 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false)
// 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false)
// 否则，用返回值填充 ep 指向的内存地址。返回 (true, true)
// 如果 ep 非空，则应该指向堆或者函数调用者的栈

func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
	// 省略 debug 内容 …………

	// 如果是一个 nil 的 channel
	if c == nil {
		// 如果不阻塞，直接返回 (false, false)
		if !block {
			return
		}
		// 否则，接收一个 nil 的 channel，goroutine 挂起
		gopark(nil, nil, "chan receive (nil chan)", traceEvGoStop, 2)
		// 不会执行到这里
		throw("unreachable")
	}

	// 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回
	// 当我们观察到 channel 没准备好接收：
	// 1. 非缓冲型，等待发送列队 sendq 里没有 goroutine 在等待
	// 2. 缓冲型，但 buf 里没有元素
	// 之后，又观察到 closed == 0，即 channel 未关闭。
	// 因为 channel 不可能被重复打开，所以前一个观测的时候 channel 也是未关闭的，
	// 因此在这种情况下可以直接宣布接收失败，返回 (false, false)
	if !block && (c.dataqsiz == 0 && c.sendq.first == nil ||
		c.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&
		atomic.Load(&c.closed) == 0 {
		return
	}

	var t0 int64
	if blockprofilerate > 0 {
		t0 = cputicks()
	}

	// 加锁
	lock(&c.lock)

	// channel 已关闭，并且循环数组 buf 里没有元素
	// 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况
	// 也就是说即使是关闭状态，但在缓冲型的 channel，
	// buf 里有元素的情况下还能接收到元素
	if c.closed != 0 && c.qcount == 0 {
		if raceenabled {
			raceacquire(unsafe.Pointer(c))
		}
		// 解锁
		unlock(&c.lock)
		if ep != nil {
			// 从一个已关闭的 channel 执行接收操作，且未忽略返回值
			// 那么接收的值将是一个该类型的零值
			// typedmemclr 根据类型清理相应地址的内存
			typedmemclr(c.elemtype, ep)
		}
		// 从一个已关闭的 channel 接收，selected 会返回true
		return true, false
	}

	// 等待发送队列里有 goroutine 存在，说明 buf 是满的
	// 这有可能是：
	// 1. 非缓冲型的 channel
	// 2. 缓冲型的 channel，但 buf 满了
	// 针对 1，直接进行内存拷贝（从 sender goroutine -> receiver goroutine）
	// 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部
	if sg := c.sendq.dequeue(); sg != nil {
		// Found a waiting sender. If buffer is size 0, receive value
		// directly from sender. Otherwise, receive from head of queue
		// and add sender's value to the tail of the queue (both map to
		// the same buffer slot because the queue is full).
		recv(c, sg, ep, func() { unlock(&c.lock) }, 3)
		return true, true
	}

	// 缓冲型，buf 里有元素，可以正常接收
	if c.qcount > 0 {
		// 直接从循环数组里找到要接收的元素
		qp := chanbuf(c, c.recvx)

		// …………

		// 代码里，没有忽略要接收的值，不是 "<- ch"，而是 "val <- ch"，ep 指向 val
		if ep != nil {
			typedmemmove(c.elemtype, ep, qp)
		}
		// 清理掉循环数组里相应位置的值
		typedmemclr(c.elemtype, qp)
		// 接收游标向前移动
		c.recvx++
		// 接收游标归零
		if c.recvx == c.dataqsiz {
			c.recvx = 0
		}
		// buf 数组里的元素个数减 1
		c.qcount--
		// 解锁
		unlock(&c.lock)
		return true, true
	}

	if !block {
		// 非阻塞接收，解锁。selected 返回 false，因为没有接收到值
		unlock(&c.lock)
		return false, false
	}

	// 接下来就是要被阻塞的情况了
	// 构造一个 sudog
	gp := getg()
	mysg := acquireSudog()
	mysg.releasetime = 0
	if t0 != 0 {
		mysg.releasetime = -1
	}

	// 待接收数据的地址保存下来
	mysg.elem = ep
	mysg.waitlink = nil
	gp.waiting = mysg
	mysg.g = gp
	mysg.selectdone = nil
	mysg.c = c
	gp.param = nil
	// 进入channel 的等待接收队列
	c.recvq.enqueue(mysg)
	// 将当前 goroutine 挂起
	goparkunlock(&c.lock, "chan receive", traceEvGoBlockRecv, 3)

	// 被唤醒了，接着从这里继续执行一些扫尾工作
	if mysg != gp.waiting {
		throw("G waiting list is corrupted")
	}
	gp.waiting = nil
	if mysg.releasetime > 0 {
		blockevent(mysg.releasetime-t0, 2)
	}
	closed := gp.param == nil
	gp.param = nil
	mysg.c = nil
	releaseSudog(mysg)
	return true, !closed
}
```

上面的代码注释地比较详细了，你可以对着源码一行行地去看，我们再来详细看一下。

- 如果 channel 是一个空值（nil），在非阻塞模式下，会直接返回。在阻塞模式下，会调用 gopark 函数挂起 goroutine，这个会一直阻塞下去。因为在 channel 是 nil 的情况下，要想不阻塞，只有关闭它，但关闭一个 nil 的 channel 又会发生 panic，所以没有机会被唤醒了。更详细地可以在 closechan 函数的时候再看。
- 和发送函数一样，接下来搞了一个在非阻塞模式下，不用获取锁，快速检测到失败并且返回的操作。顺带插一句，我们平时在写代码的时候，找到一些边界条件，快速返回，能让代码逻辑更清晰，因为接下来的正常情况就比较少，更聚焦了，看代码的人也更能专注地看核心代码逻辑了。

```golang
// 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回 (false, false)
	if !block && (c.dataqsiz == 0 && c.sendq.first == nil ||
		c.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&
		atomic.Load(&c.closed) == 0 {
		return
	}
```

当我们观察到 channel 没准备好接收：

1. 非缓冲型，等待发送列队里没有 goroutine 在等待
2. 缓冲型，但 buf 里没有元素

之后，又观察到 closed == 0，即 channel 未关闭。

因为 channel 不可能被重复打开，所以前一个观测的时候， channel 也是未关闭的，因此在这种情况下可以直接宣布接收失败，快速返回。因为没被选中，也没接收到数据，所以返回值为 (false, false)。

- 接下来的操作，首先会上一把锁，粒度比较大。如果 channel 已关闭，并且循环数组 buf 里没有元素。对应非缓冲型关闭和缓冲型关闭但 buf 无元素的情况，返回对应类型的零值，但 received 标识是 false，告诉调用者此 channel 已关闭，你取出来的值并不是正常由发送者发送过来的数据。但是如果处于 select 语境下，这种情况是被选中了的。很多将 channel 用作通知信号的场景就是命中了这里。
- 接下来，如果有等待发送的队列，说明 channel 已经满了，要么是非缓冲型的 channel，要么是缓冲型的 channel，但 buf 满了。这两种情况下都可以正常接收数据。

。。。。

![runtime-chanrecv.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/runtime-chanrecv.png)

### 关闭channel

关闭某个 channel，会执行函数 `closechan`：

```golang
func closechan(c *hchan) {
	// 关闭一个 nil channel，panic
	if c == nil {
		panic(plainError("close of nil channel"))
	}

	// 上锁
	lock(&c.lock)
	// 如果 channel 已经关闭
	if c.closed != 0 {
		unlock(&c.lock)
		// panic
		panic(plainError("close of closed channel"))
	}

	// …………

	// 修改关闭状态
	c.closed = 1

	var glist *g

	// 将 channel 所有等待接收队列的里 sudog 释放
	for {
		// 从接收队列里出队一个 sudog
		sg := c.recvq.dequeue()
		// 出队完毕，跳出循环
		if sg == nil {
			break
		}

		// 如果 elem 不为空，说明此 receiver 未忽略接收数据
		// 给它赋一个相应类型的零值
		if sg.elem != nil {
			typedmemclr(c.elemtype, sg.elem)
			sg.elem = nil
		}
		if sg.releasetime != 0 {
			sg.releasetime = cputicks()
		}
		// 取出 goroutine
		gp := sg.g
		gp.param = nil
		if raceenabled {
			raceacquireg(gp, unsafe.Pointer(c))
		}
		// 相连，形成链表
		gp.schedlink.set(glist)
		glist = gp
	}

	// 将 channel 等待发送队列里的 sudog 释放
	// 如果存在，这些 goroutine 将会 panic
	for {
		// 从发送队列里出队一个 sudog
		sg := c.sendq.dequeue()
		if sg == nil {
			break
		}

		// 发送者会 panic
		sg.elem = nil
		if sg.releasetime != 0 {
			sg.releasetime = cputicks()
		}
		gp := sg.g
		gp.param = nil
		if raceenabled {
			raceacquireg(gp, unsafe.Pointer(c))
		}
		// 形成链表
		gp.schedlink.set(glist)
		glist = gp
	}
	// 解锁
	unlock(&c.lock)

	// Ready all Gs now that we've dropped the channel lock.
	// 遍历链表
	for glist != nil {
		// 取最后一个
		gp := glist
		// 向前走一步，下一个唤醒的 g
		glist = glist.schedlink.ptr()
		gp.schedlink = 0
		// 唤醒相应 goroutine
		goready(gp, 3)
	}
}
```

close 逻辑比较简单，**对于一个 channel，recvq 和 sendq 中分别保存了阻塞的发送者和接收者**。关闭 channel 后，**对于等待接收者而言，会收到一个相应类型的零值**。**对于等待发送者，会直接 panic**。所以，在不了解 channel 还有没有接收者的情况下，不能贸然关闭 channel。

**close 函数先上一把大锁，接着把所有挂在这个 channel 上的 sender 和 receiver 全都连成一个 sudog 链表，再解锁。最后，再将所有的 sudog 全都唤醒**。

唤醒之后，该干嘛干嘛。sender 会继续执行 chansend 函数里 goparkunlock 函数之后的代码，很不幸，检测到 channel 已经关闭了，panic。receiver 则比较幸运，进行一些扫尾工作后，返回。这里，selected 返回 true，而返回值 received 则要根据 channel 是否关闭，返回不同的值。如果 channel 关闭，received 为 false，否则为 true。这我们分析的这种情况下，received 返回 false。

### Channel 发送和接收元素的本质是什么

> All transfer of value on the go channels happens with the copy of value.

就是说 **channel 的发送和接收操作本质上都是 “值的拷贝”**，无论是从 sender goroutine 的栈到 chan buf，还是从 chan buf 到 receiver goroutine，或者是直接从 sender goroutine 到 receiver goroutine。

```
type user struct {
	name string
	age int8
}

var u = user{name: "Ankur", age: 25}
var g = &u

func modifyUser(pu *user) {
	fmt.Println("modifyUser Received Vaule", pu)
	pu.name = "Anand"
}

func printUser(u <-chan *user) {
	time.Sleep(2 * time.Second)
	fmt.Println("printUser goRoutine called", <-u)
}

func main() {
	c := make(chan *user, 5)
	c <- g
	fmt.Println(g)
	// modify g
	g = &user{name: "Ankur Anand", age: 100}
	go printUser(c)
	go modifyUser(g)
	time.Sleep(5 * time.Second)
	fmt.Println(g)
}
```

运行结果：

```shell
&{Ankur 25}
modifyUser Received Vaule &{Ankur Anand 100}
printUser goRoutine called &{Ankur 25}
&{Anand 100}
```

这里就是一个很好的 `share memory by communicating` 的例子。

![output](https://golang.design/go-questions/channel/assets/12.png)

一开始构造一个结构体 u，地址是 0x56420，图中地址上方就是它的内容。接着把 `&u` 赋值给指针 `g`，g 的地址是 0x565bb0，它的内容就是一个地址，指向 u。

main 程序里，先把 g 发送到 c，根据 `copy value` 的本质，进入到 chan buf 里的就是 `0x56420`，它是指针 g 的值（不是它指向的内容），所以打印从 channel 接收到的元素时，它就是 `&{Ankur 25}`。因此，这里并不是将指针 g “发送” 到了 channel 里，只是拷贝它的值而已。

再强调一次：

> Remember all transfer of value on the go channels happens with the copy of value.

### select相关

[参考](https://cloud.tencent.com/developer/article/1796708)

#### 1.如果通道已经关闭会怎么样？如果select中只有一个case呢？

**问题** 

`for`循环`select`时，如果通道已经关闭会怎么样？如果`select`中的`case`只有一个，又会怎么样？

**怎么答** 

- **for循环`select`时，如果其中一个case通道已经关闭，则每次都会执行到这个case**。
- **如果select里边只有一个case，而这个case被关闭了，则会出现死循环**。

**解释** 

**1.for循环里被关闭的通道**

![img](https://ask.qcloudimg.com/http-save/yehe-8318363/0smbytmw4c.png?imageView2/2/w/1620)

![img](https://ask.qcloudimg.com/http-save/yehe-8318363/rna537fca9.png?imageView2/2/w/1620)

- `c通道`是一个缓冲为`0`的通道，在`main`开始时，启动一个协程对`c通道`写入`10`，然后就关闭掉这个通道。
- 在`main`中通过 `x, ok := <-c` 接受`通道c`里的值，从输出结果里看出，确实从通道里读出了之前塞入通道的`10`，但是在通道关闭后，这个通道一直能读出内容。

#### **2.怎么样才能不读关闭后通道**

<img src="https://raw.githubusercontent.com/Simin-hub/Picture/master/img/8vqfb6hxw9.png" alt="img" style="zoom:50%;" />

- `x, ok := <-c` 返回的值里第一个x是通道内的值，`ok`是指通道是否关闭，当通道被关闭后，`ok`则返回`false`，因此可以根据这个进行操作。读一个已经关闭的通道为什么会出现false，可以看我之前的 [**对已经关闭的的chan进行读写，会怎么样？为什么？**](https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483735&idx=1&sn=6ab8ac319dc1857acf44c9bb9d21c7c3&scene=21#wechat_redirect) 。
- 当返回的`ok`为`false`时，执行`c = nil` 将通道置为`nil`，相当于读一个未初始化的通道，则会一直阻塞。至于为什么读一个未初始化的通道会出现阻塞，可以看我的另一篇 [**对未初始化的的chan进行读写，会怎么样？为什么？**](https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483717&idx=1&sn=0c0385234cd70d72d424eb7097ebfe9a&scene=21#wechat_redirect) 。`select`中如果任意某个通道有值可读时，它就会被执行，其他被忽略。则`select`会跳过这个阻塞`case`，可以解决不断读已关闭通道的问题。

#### **3.如果select里只有一个已经关闭的case，会怎么样？**

<img src="https://raw.githubusercontent.com/Simin-hub/Picture/master/img/8ndh7j6v5n.png" alt="img" style="zoom:50%;" />

- 可以看出只有一个`case`的情况下，则会`死循环`。
- 那如果像上面一个`case`那样，把通道置为`nil`就能解决问题了吗？

#### **4.select里只有一个已经关闭的case，置为nil，会怎么样？**

<img src="https://raw.githubusercontent.com/Simin-hub/Picture/master/img/91xeii43oa.png" alt="img" style="zoom:50%;" />

- 第一次读取`case`能读到通道里的`10`
- 第二次读取`case`能读到通道已经关闭的信息。此时将通道置为`nil`
- 第三次读取`case`时main协程会被阻塞，**此时整个进程没有其他活动的协程了**，进程`deadlock`

#### **总结** 

- `select`中如果任意某个通道有值可读时，它就会被执行，其他被忽略。
- 如果没有`default`字句，`select`将有可能阻塞，直到某个通道有值可以运行，所以`select`里最好有一个`default`，否则将有一直阻塞的风险。



## struct

### Go struct 内存对齐

[参考](https://geektutu.com/post/hpg-struct-alignment.html)

#### 为什么需要内存对齐

**CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问**。比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。

这么设计的目的，是**减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量**。比如同样读取 8 个字节的数据，一次读取 4 个字节那么只需要读取 2 次。

CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数，例如：

![memory alignment](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/memory_alignment.png)

变量 a、b 各占据 3 字节的空间，内存对齐后，a、b 占据 4 字节空间，CPU 读取 b 变量的值只需要进行一次内存访问。如果不进行内存对齐，CPU 读取 b 变量的值需要进行 2 次内存访问。第一次访问得到 b 变量的第 1 个字节，第二次访问得到 b 变量的后两个字节。

从这个例子中也可以看到，内存对齐对实现变量的原子性操作也是有好处的，每次内存访问是原子的，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的，这个特性在并发场景下至关重要。

简言之：合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。

**在对内存特别敏感的结构体的设计上，我们可以通过调整字段的顺序，减少内存的占用。**

### 初始化带嵌套结构的结构体

go 的哲学是组合优于继承，使用 struct 嵌套即可完成组合，内嵌的结构体属性就像外层结构的属性即可，可以直接调用。

注意**初始化外层结构体时，必须指定内嵌结构体名称的结构体初始化**，如下看到 s1方式报错，s2 方式正确。

```
type stPeople struct {
    Gender bool
    Name string
}
type stStudent struct {
    stPeople
    Class int
}
//尝试4 嵌套结构的初始化表达式
//var s1 = stStudent{false, "JimWen", 3}
var s2 = stStudent{stPeople{false, "JimWen"}, 3}
fmt.Println(s2.Gender, s2.Name, s2.Class)
```



## 指针

### 什么是指针？

简单点说，**指针是指向另一个地址的值**。

**指针是指向另一个变量的内存位置的值。**

指针（pointer）在Go语言中可以被拆分为两个核心概念：

- 类型指针，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，类型指针不能进行偏移和运算。
- 切片，由指向起始元素的原始指针、元素数量和容量组成。

一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 32 和 64 位机器上分别占用 4 或 8 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 nil。指针变量通常缩写为 ptr。

每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用在变量名前面添加`&`操作符（前缀）来获取变量的内存地址（取地址操作）

## 函数

[参考地址](https://www.bookstack.cn/read/advanced-go-programming-book/ch1-basic-ch1-04-func-method-interface.md)

Go语言中的函数有**具名和匿名**之分：**具名函数一般对应于包级的函数**，是匿名函数的一种特例，当**匿名函数引用了外部作用域中的变量时就成了闭包函数**，闭包函数是函数式编程语言的核心。**方法是绑定到一个具体类型的特殊函数，Go语言中的方法是依托于类型的，必须在编译时静态绑定**。接口定义了方法的集合，这些方法依托于运行时的接口对象，因此接口对应的方法是在运行时动态绑定的。Go语言通过隐式接口机制实现了鸭子面向对象模型。



[先看基础部分](https://github.com/Simin-hub/Golang-Learning-and-Interview/blob/main/Go/%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.md#%E4%B8%89%E5%87%BD%E6%95%B0)

在Go语言中，函数是第一类对象，我们可以将函数保持到变量中。函数主要有具名和匿名之分，包级函数一般都是具名函数，具名函数是匿名函数的一种特例。当然，Go语言中每个类型还可以有自己的方法，方法其实也是函数的一种。

### 基本用法

```
// 具名函数
func Add(a, b int) int {    
	return a+b
}
// 匿名函数
var Add = func(a, b int) int {    
	return a+b
}
// 闭包函数
func(a, b int) int {    
	return a+b
}(a, b)
```

Go语言中的函数可以有多个参数和多个返回值，参数和返回值都是以传值的方式和被调用者交换数据。在语法上，函数还支持可变数量的参数，可变数量的参数必须是最后出现的参数，**可变数量的参数其实是一个切片类型的参数**。

```
// 多个参数和多个返回值
func Swap(a, b int) (int, int) {
    return b, a
}
// 可变数量的参数
// more 对应 []int 切片类型
func Sum(a int, more ...int) int {
    for _, v := range more {
        a += v
    }
    return a
}
```

当可变参数是一个空接口类型时，调用者是否解包可变参数会导致不同的结果：

```
func main() {
    var a = []interface{}{123, "abc"}
    Print(a...) // 123 abc
    Print(a)    // [123 abc]
}
func Print(a ...interface{}) {
    fmt.Println(a...)
}
```

第一个`Print`调用时传入的参数是`a...`，等价于直接调用`Print(123, "abc")`。第二个`Print`调用传入的是未解包的`a`，等价于直接调用`Print([]interface{}{123, "abc"})`。

### init 函数

Go语言程序的**初始化和执行总是从`main.main`函数开始的**。但是如果`main`包导入了其它的包，则会按照顺序将它们包含进`main`包里（这里的**导入顺序依赖具体实现，一般可能是以文件名或包路径名的字符串顺序导入**）。如果某个包被**多次导入的话，在执行的时候只会导入一次**。**当一个包被导入时，如果它还导入了其它的包，则先将其它的包包含进来**，然后创建和初始化这个包的常量和变量,再调用包里的`init`函数，如果一个**包有多个`init`函数的话，调用顺序未定义(实现可能是以文件名的顺序调用)**，同一个**文件内的多个`init`则是以出现的顺序依次调用**（`init`不是普通函数，可以定义有多个，所以也不能被其它函数调用）。最后，当`main`包的所有包级常量、变量被创建和初始化完成，并且`init`函数被执行后，才会进入`main.main`函数，程序开始正常执行。下图是Go程序函数启动顺序的示意图：

![1.4 函数、方法和接口 - 图1](https://static.sitestack.cn/projects/advanced-go-programming-book/images/ch1-11-init.ditaa.png)

要注意的是，**在`main.main`函数执行之前所有代码都运行在同一个goroutine**（可查看[goroutine调度](https://github.com/Simin-hub/Golang-Learning-and-Interview/blob/main/Go/%E8%BF%9B%E9%98%B6/goroutine.md#goroutine-%E8%B0%83%E5%BA%A6%E5%99%A8)），也就是程序的主系统线程中。因此，如果某个`init`函数内部用go关键字启动了新的goroutine的话，新的goroutine只有在进入`main.main`函数之后才可能被执行到。

#### 作用

初始化每个包后，会自动执行 init（）函数，并且执行优先级高于主函数的执行优先级。init 函数通常用于：

- 变量初始化
- 检查 / 修复状态
- 注册器
- 运行计算

#### 特性

- **init 函数不需要传入参数，也不需要返回任何值**。与 main 相比，init 没有声明，因此**无法引用**。

```
package main
import "fmt"
func init(){
  fmt.Println("init")
}
func main(){
  init()
}
```

编译上述函数 “undefined：init” 时发生错误。

**每个源文件可以包含一个以上的 init 函数**，请记住，**写在每个源文件中的 “行进方式” 只能包含一个 init 函数**，这有点不同，因此进行下一个验证。

```
package main
import "fmt"
func init(){
  fmt.Println("init 1")
}
func init(){
  fmt.Println("init2")
}
func main(){
  fmt.Println("main")
}
/* 实施结果:
init1
init2
main */
```

从上面的示例中，您可以看到每个源文件可以包含多个 init 函数。

初始化函数的一个常见示例是设置初始表达式的值。

```
var precomputed=[20]float64{}
func init(){
  var current float64=1
  precomputed[0]=current
  for i:=1;i<len(precomputed);i++{
    precomputed[i]=precomputed[i-1]*1.2
  }
}
```

因为不可能在上面的代码 (这是一条语句) 中将 for 循环用作预先计算的值，所以可以使用 init 函数来解决此问题。

#### Go 套件汇入规则的副作用

Go 非常严格，不允许引用未使用的软件包。但是有时您引用包只是为了调用 init 函数进行一些初始化。空标识符 (即下划线) 的目的是解决此问题

Go 非常严格，不允许引用未使用的软件包。但是有时您引用包只是为了调用 init 函数进行一些初始化。空标识符 (即下划线) 的目的是解决此问题。

```go
import _ "image/png"
```

#### 总结

- init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等

- 每个包可以拥有多个init函数

- 包的每个源文件也可以拥有多个init函数

- 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)

- 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序

- **init函数不能被其他函数调用，而是在main函数执行之前，自动被调用**

### main函数

在Go语言中，**main**包是一个特殊的软件包，与可执行程序一起使用，并且该package包含*main()*函数。在*main()*函数是一种特殊类型的函数，它是可执行程序的入口点。它**不带任何参数也不返回任何内容**。由于可以自动调用*main()*函数，因此无需显式调用*main()*函数，并且**每个可执行程序必须包含一个package main和*main()*函数**。

示例

```
//主包的声明
package main

//导入包
import (
    "fmt"
    "sort"
    "strings"
    "time"
)

func main() {

    //对切片进行排序
    s := []int{345, 78, 123, 10, 76, 2, 567, 5}
    sort.Ints(s)
    fmt.Println("排序后的切片: ", s)

    // 查找索引值
    fmt.Println("索引值为: ", strings.Index("nhooo", "ks"))

    //显示当前时间戳
    fmt.Println("时间戳: ", time.Now().Unix())

}
```

**输出：**

```
排序后的切片:  [2 5 10 76 78 123 345 567]
索引值为:  -1
时间戳:  1593335332
```

`init`函数和`main`函数的异同

```
相同点：
	两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。
不同点：
    init可以应用于任意包中，且可以重复定义多个。
    main函数只能用于main包中，且只能定义一个。
```

### 参数值传递

[参考地址](89N3PDyZzakoH7W6n8ZrjGDDktjh8iWFG6eKRvi3kvpQ)

#### slice

[底层](https://github.com/Simin-hub/Golang-Learning-and-Interview/blob/main/Go/%E8%BF%9B%E9%98%B6/array%E3%80%81slice%E3%80%81map%E3%80%81channel.md#slice)

`slice`底层结构：

```go
//runtime/slice.go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```

`slice`是一个结构体，他的**第一个元素是一个指针类型**，这个指针指向的是底层数组的第一个元素。所以当是`slice`类型的时候，`fmt.Printf`返回是`slice`这个结构体里第一个元素的地址。说到底，又转变成了指针处理，只不过这个指针是`slice`中第一个元素的内存地址。之所以对于引用类型的传递可以修改原内容的数据，这是因为在底层默认使用该引用类型的指针进行传递，但也是使用指针的副本，依旧是值传递。所以**`slice`传递的就是第一个元素的指针的副本**，因为`fmt.printf`缘故造成了打印的地址一样，给人一种混淆的感觉。

slice外在表现为指向第一个元素的指针。

因为切片中的**底层数组部分是通过隐式指针传递(指针本身依然是传值的**，但是指针指向的却是同一份的数据)，所以**被调用函数是可以通过指针修改掉调用参数切片中的数据**。除了数据之外，切片结构还包含了切片长度和切片容量信息，这2个信息也是传值的。如果被调用函数中**修改了`Len`或`Cap`信息的话，就无法反映到调用参数的切片中**，这时候我们一般会通过返回修改后的切片来更新之前的切片。这也是为何内置的`append`必须要返回一个切片的原因。

##### 当使用值传递时，若发生了扩容，原slice和函数内的slice指向不同的数组

```
func main() {
  s := []int{1, 2, 3}
  reverse(s)
  fmt.Println(s)
}
 
func reverse(s []int) {
  s = append(s, 999, 1000, 1001)
  for i, j := 0, len(s)-1; i < j; i++ {
    j = len(s) - (i + 1)
    s[i], s[j] = s[j], s[i]
  }
}
```

本来切片只有 3 个元素，分别是 1，2，3。我们把切片赋给了变量 s，然后用变量 s 作为参数传给了函数 reverse 进行处理，函数 reverse 在反转切片元素之前还给原来的切片先追加了几个值，这就导致了切片发生扩容。因为切片实际上并不是一个指针类型，它的运行时类型表示是 SliceHeader。

因为 Go 里边有**一切都是值传递的规则**，所以切片作为参数时，会在函数内重新拷贝一个 SliceHeader 结构体，只不过结构体的 Data 指针一开始跟外部切片的指向是一样的，都是同一个底层数据。

这就导致了函数内切片 SliceHeader 里的 Data 指针发生变化后，函数外原来的切片还是指向原来的底层数组。最后结果，打印函数外切片变量输出的是 `[1, 2, 3]`，但函数里边的切片已经是 `[1001, 1000, 999, 3, 2, 1]` 了。

下面这个图，展示了这个函数内外切片指向的底层数组发生变化的过程。

<img src="https://img-blog.csdnimg.cn/img_convert/7d149106f6f932b38b7d7f3df7a39758.png" alt="7d149106f6f932b38b7d7f3df7a39758.png" style="zoom:50%;" />

#### map

[底层](https://github.com/Simin-hub/Golang-Learning-and-Interview/blob/main/Go/%E8%BF%9B%E9%98%B6/array%E3%80%81slice%E3%80%81map%E3%80%81channel.md#map)

在这里，Go语言通过`make`函数，字面量的包装，为我们省去了指针的操作，让我们可以更容易的使用map。**这里的`map`可以理解为引用类型，但是记住引用类型不是传引用**。

**如果用 Map 当函数参数，Map发生扩容后**，函数内外的Map变量指向的底层内存仍是一致的。这是为什么呢？答案我是在《Go 语言设计与实现》哈希表这一章找到的，有书的可以翻开 75 页看看。\

#### channel

[底层](https://github.com/Simin-hub/Golang-Learning-and-Interview/blob/main/Go/%E8%BF%9B%E9%98%B6/array%E3%80%81slice%E3%80%81map%E3%80%81channel.md#channel)

go就是值传递，可以确认的是Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。

是否可以修改原内容数据，和传值、传引用没有必然的关系。在C++中，传引用肯定是可以修改原内容数据的，在Go语言里，虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型。

### 递归

Go语言中，**函数还可以直接或间接地调用自己，也就是支持递归调用**。Go语言函数的递归调用深度逻辑上没有限制，函数调用的栈是不会出现溢出错误的，因为Go语言运行时会根据需要动态地调整函数栈的大小。**每个goroutine刚启动时只会分配很小的栈（4或8KB，具体依赖实现），根据需要动态调整栈的大小，栈最大可以达到GB级**（依赖具体实现，在目前的实现中，32 位体系结构为250MB, 64 位体系结构为1GB）。在 Go1.4 以前，Go的动态栈采用的是分段式的动态栈，通俗地说就是采用一个链表来实现动态栈，每个链表的节点内存位置不会发生变化。但是链表实现的动态栈对某些导致跨越链表不同节点的热点调用的性能影响较大，因为相邻的链表节点它们在内存位置一般不是相邻的，这会增加CPU高速缓存命中失败的几率。为了解决热点调用的CPU缓存命中率问题，Go1.4之后改用连续的动态栈实现，也就是采用一个类似动态数组的结构来表示栈。不过连续动态栈也带来了新的问题：当连续栈动态增长时，需要将之前的数据移动到新的内存空间，这会导致之前栈中全部变量的地址发生变化。虽然Go语言运行时会自动更新引用了地址变化的栈变量的指针，但最重要的一点是要明白Go语言中指针不再是固定不变的了（因此不能随意将指针保持到数值变量中，Go语言的地址也不能随意保存到不在GC控制的环境中，因此使用CGO时不能在C语言中长期持有Go语言对象的地址）。

因为，Go语言函数的栈会自动调整大小，所以普通Go程序员已经很少需要关心栈的运行机制的。在Go语言规范中甚至故意没有讲到栈和堆的概念。我们无法知道函数参数或局部变量到底是保存在栈中还是堆中，我们只需要知道它们能够正常工作就可以了。

### 方法

Go语言的方法却是关联到类型的，这样可以**在编译阶段完成方法的静态绑定**。一个面向对象的程序会用方法来表达其属性对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。

#### 方法即函数

```
// 文件对象
type File struct {
    fd int
}
// 打开文件
func OpenFile(name string) (f *File, err error) {
    // ...
}
// 关闭文件
func CloseFile(f *File) error {
    // ...
}
// 读文件数据
func ReadFile(f *File, int64 offset, data []byte) int {
    // ...
}
```

Go语言中的做法是，将`CloseFile`和`ReadFile`函数的第一个参数移动到函数名的开头：

```
// 关闭文件
func (f *File) CloseFile() error {
    // ...
}
// 读文件数据
func (f *File) ReadFile(int64 offset, data []byte) int {
    // ...
}
```

这样的话，**`CloseFile`和`ReadFile`函数就成了`File`类型独有的方法了（而不是`File`对象方法）**。它们也不再占用包级空间中的名字资源，同时`File`类型已经明确了它们操作对象，因此方法名字一般简化为`Close`和`Read`：

```
// 关闭文件
func (f *File) Close() error {
    // ...
}
// 读文件数据
func (f *File) Read(int64 offset, data []byte) int {
    // ...
}
```

将第一个函数参数移动到函数前面，从代码角度看虽然只是一个小的改动，但是从编程哲学角度来看，Go语言已经是进入面向对象语言的行列了。我们可以给任何自定义类型添加一个或多个方法。每种类型对应的方法必须和类型的定义在同一个包中，因此是**无法给`int`这类内置类型添加方法**的（**因为方法的定义和类型的定义不在一个包中**）（但是可以**通过别名的方式添加方法**）。对于给定的类型，**每个方法的名字必须是唯一**的，同时方法和函数一样也不支持重载。

```go
package main

import "fmt"

// 将int定义为MyInt类型
type MyInt int
// 为MyInt添加IsZero()方法
func (m MyInt) IsZero() bool {
    return m == 0
}

func main() {
	var n MyInt
	n = 3
	fmt.Println(n.IsZero())
}

```

方法是由函数演变而来，只是将函数的第一个对象参数移动到了函数名前面了而已。因此我们依然可以按照原始的过程式思维来使用方法。**通过叫方法表达式的特性可以将方法还原为普通类型的函数**：

```go
// 不依赖具体的文件对象
// func CloseFile(f *File) error
var CloseFile = (*File).Close
// 不依赖具体的文件对象
// func ReadFile(f *File, int64 offset, data []byte) int
var ReadFile = (*File).Read
// 文件处理
f, _ := OpenFile("foo.dat")
ReadFile(f, 0, data)
CloseFile(f)
```

在有些场景更关心一组相似的操作：比如`Read`读取一些数组，然后调用`Close`关闭。此时的环境中，用户并不关心操作对象的类型，只要能满足通用的`Read`和`Close`行为就可以了。不过在方法表达式中，因为得到的`ReadFile`和`CloseFile`函数参数中含有`File`这个特有的类型参数，这使得`File`相关的方法无法和其它不是`File`类型但是有着相同`Read`和`Close`方法的对象无缝适配。这种小困难难不倒我们Go语言码农，我们可以通过结合闭包特性来消除方法表达式中第一个参数类型的差异：

``` go
// 先打开文件对象
f, _ := OpenFile("foo.dat")
// 绑定到了 f 对象
// func Close() error
var Close = func Close() error {
    return (*File).Close(f)
}
// 绑定到了 f 对象
// func Read(int64 offset, data []byte) int
var Read = func Read(int64 offset, data []byte) int {
    return (*File).Read(f, offset, data)
}
// 文件处理
Read(0, data)
Close()
```

这刚好是方法值也要解决的问题。我们用方法值特性可以简化实现：

``` go
// 先打开文件对象
f, _ := OpenFile("foo.dat")
// 方法值: 绑定到了 f 对象
// func Close() error
var Close = f.Close
// 方法值: 绑定到了 f 对象
// func Read(int64 offset, data []byte) int
var Read = f.Read
// 文件处理
Read(0, data)
Close()
```

#### 继承

Go语言不支持传统面向对象中的继承特性，而是**以自己特有的组合方式支持了方法的继承**。Go语言中，通过**在结构体内置匿名的成员来实现继承**：

``` go
import "image/color"
type Point struct{ X, Y float64 }
type ColoredPoint struct {
    Point
    Color color.RGBA
}
```

假如外部struct中的字段名和内部struct的字段名相同，会如何？

有以下两个名称冲突的规则：

1. **外部struct覆盖内部struct的同名字段、同名方法**
2. **同级别的struct出现同名字段、方法将报错**

第一个规则使得Go struct能够实现面向对象中的重写(override)，而且可以重写字段、重写方法。

第二个规则使得同名属性不会出现歧义。

虽然我们可以将`ColoredPoint`定义为一个有三个字段的扁平结构的结构体，但是我们这里将`Point`嵌入到`ColoredPoint`来提供`X`和`Y`这两个字段。

``` go
import "image/color"
type Point struct{ X, Y float64 }
type ColoredPoint struct {
    Point
    Color color.RGBA
}
```

通过嵌入匿名的成员，我们**不仅可以继承匿名成员的内部成员，而且可以继承匿名成员类型所对应的方法**。我们一般会将 `Point` 看作基类，把 `ColoredPoint` 看作是它的继承类或子类。不过这种方式继承的方法并不能实现C++中虚函数的多态特性。所有继承来的方法的接收者参数依然是那个匿名成员本身，而不是当前的变量。

``` go
var cp ColoredPoint
cp.X = 1
fmt.Println(cp.Point.X) // "1"
cp.Point.Y = 2
fmt.Println(cp.Y)       // "2"
```

`Cache` 结构体类型通过嵌入一个匿名的 `sync.Mutex` 来继承它的`Lock`和`Unlock`方法. 但是在调用`p.Lock()`和`p.Unlock()`时, `p`并不是`Lock`和`Unlock`方法的真正接收者, 而是会将它们展开为`p.Mutex.Lock()`和`p.Mutex.Unlock()`调用. **这种展开是编译期完成的, 并没有运行时代价.**

在**传统的面向对象语言(eg.C++或Java)的继承中，子类的方法是在运行时动态绑定到对象的**，因此基类实现的某些方法看到的`this`可能不是基类类型对应的对象，这个特性会导致基类方法运行的不确定性。而在Go语言通过嵌入匿名的成员来“继承”的基类方法，`this`就是实现该方法的类型的对象，**Go语言中方法是编译时静态绑定的**。如果需要虚函数的多态特性，我们需要借助Go语言接口来实现。

#### 值接收者和指针接收者

方法能给用户自定义的类型添加新的行为。它和函数的**区别在于方法有一个接收者**，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是`值接收者`，也可以是`指针接收者`。

在调用方法的时候，值类型既可以调用`值接收者`的方法，也可以调用`指针接收者`的方法；指针类型既可以调用`指针接收者`的方法，也可以调用`值接收者`的方法。

也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。

实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现：

|                |                           值接收者                           |                          指针接收者                          |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  值类型调用者  |           方法会使用调用者的一个副本，类似于“传值”           | 使用值的引用来调用方法，上例中，`qcrao.growUp()` 实际上是 `(&qcrao).growUp()` |
| 指针类型调用者 | 指针被解引用为值，上例中，`stefno.howOld()` 实际上是 `(*stefno).howOld()` | 实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针 |

**接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者；而对于接收者是值类型的方法，在方法中不会对接收者本身产生影响**。

#### 分别使用什么场景

**如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。**

使用指针作为方法的接收者的理由：

- **方法能够修改接收者指向的值**。
- 避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。

是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该**基于该类型的`本质`**。

**如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法**。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 `header`， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 `header`，而 `header` 本身就是为复制设计的。

**如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。**比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份`实体`。

### 闭包

[参考](https://zhuanlan.zhihu.com/p/56750616)

**闭包** 是**由函数及其相关引用环境组合而成的实体**(即：闭包=函数+引用环境)。

“官方”的解释是：所谓“**闭包**”，**指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数）**，因而这些变量也是该表达式的一部分。

比如下面“斐波那契数列”闭包：

```text
func fib() func() int {
	a, b := 0, 1
	return func() int {
		a, b = b, a+b
		return a
	}
}

调用如下
f00 := fib()
fmt.Println(f00(), f00(), f00(), f00(), f00())
输出结果是：1 1 2 3 5
```

golang里是如何做到这种闭包管理的呢？

####  1. 什么是闭包？

**一个匿名函数内引用了外部的局部变量，这种现象，就称之为闭包**。

例如下面的这段代码中，adder 函数返回了一个匿名函数，而该匿名函数中引用了 adder 函数中的局部变量 `sum` ，那这个函数就是一个闭包。

```
package main

import "fmt"


// 具名函数
func Add(a, b int) int {    
	return a+b
}
// 匿名函数
var Add = func(a, b int) int {    
	return a+b
}
// 闭包函数
func(a, b int) int {    
	return a+b
}(a, b)

// 闭包函数
func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}
```

而这个闭包中引用的外部局部变量并不会随着 adder 函数的返回而被从栈上销毁。

我们尝试着调用这个函数，发现每一次调用，sum 的值都会保留在 闭包函数中以待使用。

```
func main() {
     valueFunc:= adder()
     fmt.Println(valueFunc(2))     // output: 2
     fmt.Println(valueFunc(2))   // output: 4
}
```

#### 2. 复杂的闭包场景

写一个闭包是比较容易的事，但单单会写简单的闭包函数，还远远不够，如果不搞清楚闭包真正的原理，那很容易在一些复杂的闭包场景中对函数的执行逻辑进行误判。

别的不说，就拿下来这个例子来说吧？

你觉得它会打印什么呢？

是 6 还是 11 呢？

```
import "fmt"

func func1() (i int) {
    i = 10
    defer func() {
        i += 1
    }()
    return 5
}

func main() {
    closure := func1()
    fmt.Println(closure)
}
```

#### 3. 闭包的底层原理？

还是以最上面的例子来分析

```
package main

import "fmt"

func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}

func main() {
    valueFunc:= adder()
    fmt.Println(valueFunc(2))     // output: 2
}
```

我们先对它进行逃逸分析，很容易发现 sum 作为 adder 函数局部变量，并不是分配在栈上，而是分配在堆上的。

这就解决了第一个疑惑：**为什么 adder 函数返回后， sum 不会随之销毁？**

```
$ go build -gcflags="-m -m -l" demo.go
# command-line-arguments
./demo.go:8:3: adder.func1 capturing by ref: sum (addr=true assign=true width=8)
./demo.go:7:9: func literal escapes to heap:
./demo.go:7:9:   flow: ~r0 = &{storage for func literal}:
./demo.go:7:9:     from func literal (spill) at ./demo.go:7:9
./demo.go:7:9:     from return func literal (return) at ./demo.go:7:2
./demo.go:6:2: sum escapes to heap:
./demo.go:6:2:   flow: {storage for func literal} = &sum:
./demo.go:6:2:     from func literal (captured by a closure) at ./demo.go:7:9
./demo.go:6:2:     from sum (reference) at ./demo.go:8:3
./demo.go:6:2: moved to heap: sum
./demo.go:7:9: func literal escapes to heap
./demo.go:15:23: valueFunc(2) escapes to heap:
./demo.go:15:23:   flow: {storage for ... argument} = &{storage for valueFunc(2)}:
./demo.go:15:23:     from valueFunc(2) (spill) at ./demo.go:15:23
./demo.go:15:23:   flow: {heap} = {storage for ... argument}:
./demo.go:15:23:     from ... argument (spill) at ./demo.go:15:13
./demo.go:15:23:     from fmt.Println(valueFunc(2)) (call parameter) at ./demo.go:15:13
./demo.go:15:13: ... argument does not escape
./demo.go:15:23: valueFunc(2) escapes to heap
```

可另一个问题，又浮现出来了，就算它不会销毁，那闭包函数若是存储的若是 sum 拷贝后的值，那每次调用闭包函数，里面的 sum 应该都是一样的，调用两次都应该返回 2，而不是可以累加记录。

因此，可以大胆猜测，闭包函数的结构体里存储的是 sum 的指针。

为了验证这一猜想，只能上汇编了。

通过执行下面的命令，可以输出对应的汇编代码

```
go build -gcflags="-S" demo.go 
```

输出的内容相当之多，我提取出下面最关键的一行代码，它定义了闭包函数的结构体。

其中 F 是函数的指针，但这不是重点，重点是 sum 存储的确实是指针，验证了我们的猜。

```
type.noalg.struct { F uintptr; "".sum *int }(SB), CX
```

#### 4. 迷题揭晓

首先，由于 `i` 在函数定义的返回值上声明，因此根据 [go 的 `caller-save` 模式](https://segmentfault.com/a/1190000039753236)， `i` 变量会存储在 main 函数的栈空间。

然后，`func1` 的 return 重新把 5 赋值给了 `i` ，此时 `i = 5`

由于闭包函数存储了这个变量 `i` 的指针。

因此最后，在 defer 中对 `i` 进行自增，是直接更新到 `i` 的指针上，此时 `i = 5+1`，所以最终打印出来的结果是 `6`

```
import "fmt"

func func1() (i int) {
    i = 10
    defer func() {
        i += 1
    }()
    return 5
}

func main() {
    closure := func1()
    fmt.Println(closure)
}
```

#### 5. 再度变题

上面那题听懂了的话，再来看看下面这道题。

`func1` 的返回值我们不写变量名 `i` 了，然后原先返回具体字面量，现在改成变量 `i` ，就是这两小小小的改动，会导致运行结果大大不同，你可以思考一下结果。

```
import "fmt"

func func1() (int) {
    i := 10
    defer func() {
        i += 1
    }()
    return i
}

func main() {
    closure := func1()
    fmt.Println(closure)
}
```

如果你在返回值里写了变量名，那么该变量会存储 main 的栈空间里，而如果你不写，那 i 只能存储在 `func1` 的栈空间里，与此同时，return 的值，不会作用于原变量 `i` 上，而是会存储在该函数在另一块栈内存里。

因此你在 defer 中对原 `i` 进行自增，并不会作用到 func1 的返回值上。

所以打印的结果，只能是 `10`。

你答对了吗？

#### 6. 最后一个问题

不知道你有没有发现，在第一节示例中的 sum 是存储在堆内存中的，而后面几个示例都是存储在栈内存里。

这是为什么呢？

仔细对比，不难发现，示例一返回的是闭包函数，闭包函数在 `adder` 返回后还要在其他地方继续使用，在这种情况下，为了保证闭包函数的正常运行，无论闭包函数在哪里，`i` 都不能回收，所以 Go 编译器会智能地将其分配在堆上。

而后面的其他示例，都只是涉及了闭包的特性，并不是直接把闭包函数返回，因此完全可以将其分配在栈上，非常的合理。

闭包实现

我们先对闭包分3种场景：  

- **闭包里没有引用环境**（变量生命周期很短，调用完即释放）
- **闭包里引用全局变量**（变量生命周期就是全局变量生命周期）
- **闭包里引用局部变量**（变量生命周期长，调用完不释放，下次调用会继续引用）

分别对3种场景以以下代码进行分析：

```text
var y int

// 第一种场景
func fib01() func() int {
	return func() int {
		a, b := 0, 1
		a, b = b, a+b
		return a
	}
}

// 第二种场景
func fib00() func() int {
	return func() int {
		y++
		return y
	}
}

// 第三种场景
func fib3(x int) func() int {
	a, b := 0, 1
	return func() int {
		a, b = b, a+b
		x++
		return a+x
	}
}
```

保存上述文件为closure.go，然后在用汇编工具生成汇编代码。汇编参考[golang内核系列–深入理解plan9汇编&实践](https://zhuanlan.zhihu.com/p/56750445)
git：git@github.com:buptbill220/gotls.git
**使用如下命名生成汇编**：

```text
go tool compile -S closure.go  > closure.S
```

我们打开closure.S找到对应的函数闭包位置

#### 第一种场景fib01



![img](https://pic4.zhimg.com/v2-28c94789a18157f2f55163ff9959c453_r.jpg)



然后找到 **"".fib01.func1**



![img](https://pic1.zhimg.com/v2-0e75ab0c538d2148ac21af8172886398_r.jpg)



闭包在全局区定义到代码段

```text
"".fib01.func1·f SRODATA dupok size=8
```

我们可以看到：**这种情况就是一种普通的函数，直接返回函数地址然后调用**



![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/v2-dd251f8c45e161af972cb18192185ea0_b.png)



为了帮助理解这个实现，我们手动使用汇编根据一个函数地址调用函数

```text
TEXT ·CallTest(SB),NOSPLIT,$0-8
    MOVQ arg+0(FP), AX
    CALL AX
    RET

func call_test() {
	fmt.Printf("call test")
}

func CallTest(uintptr)

x := call_test
CallTest(**(*(*uintptr))(unsafe.Pointer(&x)))

结果输出：call test
```

#### 第二种场景fib00



![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/v2-90c6f8fbd36723eb7cd6014c1754f1a4_r.jpg)



然后找到 **“”.fib00.func1**



![img](https://pic4.zhimg.com/v2-f0895f298d65160e0b0663a517554553_r.jpg)



y的位置

```text
"".y SNOPTRBSS size=8
```

我们可以看到，**第二种场景也是返回函数闭包的地址，只是闭包内部访问全局变量，并不做额外的工作。可以和场景1归纳为一类**

#### 第三种场景fib3

由于汇编较多，拆为2部分



![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/v2-8917f4dcf7a6c76351749a93c1e35a91_r.jpg)





![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/v2-85fd460430959c80fbd7a87715352d71_r.jpg)



然后找到 **“”.fib3.func1**



![img](https://pic3.zhimg.com/v2-889eb8ed19caf1feefd5eb246f819ac2_r.jpg)



通过上述分析，我们可以得知，**所有引用局部变量，Golang在生成汇编是帮我们在堆上创建该变量的一个拷贝，并把该变量地址和函数闭包组成一个结构体，并把该结构体传出来作为返回值。**
结构体形式如下：

```text
type FF struct {
	F unitptr
	B *int
	A *int
	X *int // 如果X是string/[]int，那么这里应该为*string，*[]int
}
```

这个结构有个特点：**结构里变量顺序和函数里引用顺序刚好相反。这是因为Golang为了保持物理地址顺序一致性的结果。**

- 栈的物理空间增长顺序是从大到小，栈里看到地址顺序是x>a>b
- 而我们引用的是堆上物理空间增长顺序是从小到大，为了保持和栈上物理地址顺序一致，生成的结构顺序就是b、a、x



![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/v2-0717900fa8d47405bf7a7689da3f2cb2_b.jpg)



为了帮助理解这种实现，我们手动把函数闭包转换成结构并输出：

```text
type FF struct {
	F unitptr
	b *int
	a *int
	x *int
}
f := fib3(0)
ptr := *(**FF)(unsafe.Pointer(&f))
fmt.Printf("ptr %v, %d, %d, %d\n", ptr, *ptr.a, *ptr.b, *ptr.x)
fmt.Println(f(), f(), f(), f(), f())
fmt.Printf("ptr %v, %d, %d, %d\n", ptr, *ptr.a, *ptr.b, *ptr.x)

自己手动调试看看
```

这里还有另一个特点：**函数闭包内部本身是通过寄存器来访问引用环境的变量，在闭包调用前会把该结构地址提前放置寄存器（这里放到DX）**

我们可以看看闭包调用前的代码：



![img](https://pic3.zhimg.com/v2-8cb6e0fe7815bb741311f7c67e5930ce_b.jpg)



#### 总结

golang的函数闭包实现主要分为两种场景：

- **闭包里没有引用环境&获取引用全局变量**。这种场景下，其实现就是普通的函数，按照普通的函数调用方式执行闭包调用。
- **闭包里引用局部变量**。这种场景下，才是真正的闭包（函数+引用环境），并且以一个struct{FuncAddr, LocalAddr3, LocalAddr2, LocalAddr1}结构存储该闭包，等到调用闭包时，会把该结构地址提前放置一个寄存器，闭包内部通过该寄存器访问引用环境的变量

## 接口

**Go的接口类型是对其它类型行为的抽象和概括**；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让对象更加灵活和更具有适应能力。很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的**独特之处在于它是满足隐式实现的鸭子类型**。所谓鸭子类型说的是：只要走起路来像鸭子、叫起来也像鸭子，那么就可以把它当作鸭子。Go语言中的面向对象就是如此，如果一个对象只要看起来像是某种接口类型的实现，那么它就可以作为该接口类型使用。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不用去破坏这些类型原有的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其灵活有用。Go语言的接口类型是延迟绑定，可以实现类似虚函数的多态功能。

在静态语言如 Java, C++ 中，必须要显示地声明实现了某个接口，之后，才能用在任何需要这个接口的地方。如果你在程序中调用 `hello_world` 函数，却传入了一个根本就没有实现 `say_hello()` 的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。Go 语言作为一门现代静态语言，是有后发优势的。它引入了动态语言的便利，同时又会进行静态语言的类型检查，写起来是非常 Happy 的。Go 采用了折中的做法：不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。

动态语言的特点：

> 变量绑定的类型是不确定的，在运行期间才能确定 函数和方法可以接收任何类型的参数，且调用时不检查参数类型 不需要实现接口

### 接口的两种类型

`iface` 和 `eface` 都是 Go 中描述接口的底层结构体，区别在于 `iface` 描述的接口**包含方法**，而 `eface` 则是**不包含任何方法**的空接口：`interface{}`

#### 	iface

```golang
type iface struct {
	tab  *itab
	data unsafe.Pointer
}

type itab struct {
	inter  *interfacetype
	_type  *_type
	link   *itab
	hash   uint32 // copy of _type.hash. Used for type switches.
	bad    bool   // type does not implement interface
	inhash bool   // has this itab been added to hash?
	unused [2]byte
	fun    [1]uintptr // variable sized
}
```

**`iface` 内部维护两个指针，`tab` 指向一个 `itab` 实体， 它表示接口的类型以及赋给这个接口的实体类型。`data` 则指向接口具体的值，一般而言是一个指向堆内存的指针。**

再来仔细看一下 `itab` 结构体：`_type` 字段描述了实体的类型，包括内存对齐方式，大小等；`inter` 字段则描述了接口的类型。`fun` 字段**放置和接口方法对应的具体数据类型的方法地址**，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 `itab`。

这里只会列出实体类型和接口相关的方法，实体类型的其他方法并不会出现在这里。如果你学过 C++ 的话，这里可以类比虚函数的概念。

另外，你可能会觉得奇怪，为什么 `fun` 数组的大小为 1，要是接口定义了多个方法可怎么办？实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。顺便提一句，这些方法是按照函数名称的字典序进行排列的。

再看一下 `interfacetype` 类型，它描述的是接口的类型：

``` go
type interfacetype struct {
	typ     _type
	pkgpath name
	mhdr    []imethod
}
```

可以看到，它包装了 `_type` 类型，`_type` 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 `mhdr` 字段，表示接口所定义的函数列表， `pkgpath` 记录定义了接口的包名。

这里通过一张图来看下 `iface` 结构体的全貌：

![iface 结构体全景](https://golang.design/go-questions/interface/assets/0.png)



`iface`包含两个字段：`tab` 是接口表指针，指向类型信息；`data` 是数据指针，则指向具体的数据。它们分别被称为`动态类型`和`动态值`。而接口值包括`动态类型`和`动态值`。

**接口类型和 `nil` 作比较**

接口值的零值是指`动态类型`和`动态值`都为 `nil`。当仅且当这两部分的值都为 `nil` 的情况下，这个接口值就才会被认为 `接口值 == nil`。

#### eface

```golang
type eface struct {
    _type *_type
    data  unsafe.Pointer
}
```

相比 `iface`，`eface` 就比较简单了。只维护了一个 `_type` 字段，表示空接口所承载的具体的实体类型。`data` 描述了具体的值。

![eface 结构体全景](https://golang.design/go-questions/interface/assets/1.png)

不包含任何的方法，正因为如此，所有的类型都实现了空接口，因此空接口可以存储任意类型的数值。

fmt 包下的 Print 系列函数，其参数大多是空接口类型，也可以说支持任意类型：

``` go
func Print(a ...interface{}) (n int, err error)
func Println(format string, a ...interface{}) (n int, err error)
func Println(a ...interface{}) (n int, err error)
```

`_type` 结构体：

```golang
type _type struct {
    // 类型大小
	size       uintptr
    ptrdata    uintptr
    // 类型的 hash 值
    hash       uint32
    // 类型的 flag，和反射相关
    tflag      tflag
    // 内存对齐相关
    align      uint8
    fieldalign uint8
    // 类型的编号，有bool, slice, struct 等等等等
	kind       uint8
	alg        *typeAlg
	// gc 相关
	gcdata    *byte
	str       nameOff
	ptrToThis typeOff
}
```

Go 语言各种数据类型都是在 `_type` 字段的基础上，增加一些额外的字段来进行管理的：

```golang
type arraytype struct {
	typ   _type
	elem  *_type
	slice *_type
	len   uintptr
}

type chantype struct {
	typ  _type
	elem *_type
	dir  uintptr
}

type slicetype struct {
	typ  _type
	elem *_type
}

type structtype struct {
	typ     _type
	pkgPath name
	fields  []structfield
}
```

### 检测是否实现接口

经常看到一些开源库里会有一些类似下面这种奇怪的用法：

```
var _ io.Writer = (*myWriter)(nil) 
```

这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。编译器会由此检查 `*myWriter` 类型是否实现了 `io.Writer` 接口。

实际上，上述赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。

总结一下，可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口：

```
var _ io.Writer = (*myWriter)(nil)
var _ io.Writer = myWriter{}
```

### 接口的构造过程

[参考](https://golang.design/go-questions/interface/construct/)

### 类型转化与类型断言

[参考](https://golang.design/go-questions/interface/assert/)

`类型转换`、`类型断言`本质都是把一个类型转换成另外一个类型。不同之处在于，**类型断言是对接口变量进行的操作**。

对于**类型转换**而言，转换前后的两个类型要相互兼容才行。类型转换的语法为：

> <结果类型> := <目标类型> ( <表达式> )

```
var i int = 9
var f float64
f = float64(i)
```

**类型断言**的语法为：

> <目标类型的值>，<布尔参数> := <表达式>.( 目标类型 ) // 安全类型断言
>
> <目标类型的值> := <表达式>.( 目标类型 )　　//非安全类型断言

### 类型转化原理

[参考](https://golang.design/go-questions/interface/convert/)

`iface`由`itab`和`data`组成，将源类型的`itab`替换成目标类型的`itab`，再将源类型的data赋值给目标类型

 `iface` 的源码可以看到，实际上它包含接口的类型 `interfacetype` 和 实体类型的类型 `_type`，这两者都是 `iface` 的字段 `itab` 的成员。**也就是说生成一个 `itab` 同时需要接口的类型和实体的类型**。

`getitab `函数会根据 `interfacetype` 和 `_type` 去全局的` itab `哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 `interfacetype` 和 `_type` 新生成一个 `itab`，并插入到 `itab `哈希表，这样下一次就可以直接拿到 `itab`。

### 多态

多态是一种运行期的行为，它有以下几个特点：

> 1. 一种类型具有多种类型的能力
> 2. 允许不同的对象对同一消息做出灵活的反应
> 3. 以一种通用的方式对待个使用的对象
> 4. 非动态语言必须通过继承和接口的方式来实现

## 四种类型转换

[参考](https://learnku.com/articles/42797)

### 断言类型转换

**断言通过判断变量是否可以转换成某一个类型**

#### 类型断言

类型断言（Type Assertion）是一个使用在**接口值**上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型。

一个简单的断言表达式：

```go
var s = x.(T)
```

如果 x 不是 nil，且 x 可以转换成 T 类型，就会断言成功，返回 T 类型的变量 s。如果 T 不是接口类型，则要求 x 的类型就是 T，如果 T 是一个接口，要求 x 实现了 T 接口。

如果断言类型成立，则表达式返回值就是 T 类型的 x，如果断言失败就会触发 panic。

**上述表所示再断言失败就会 panic**，go 提供了另外一种带返回是否成立的断言语法：

在Go语言中类型断言的语法格式如下：

```
value, ok := x.(T)
```

其中，**x 表示一个接口的类型**，**T 表示一个具体的类型**（也可为接口类型）。

该断言表达式会返回 x 的值（也就是 value）和一个布尔值（也就是 ok），可根据该布尔值判断 x 是否为 T 类型：

- 如果 T 是具体某个类型，类型断言会检查 x 的动态类型是否等于具体类型 T。如果检查成功，类型断言返回的结果是 x 的动态值，其类型是 T。
- 如果 T 是接口类型，类型断言会检查 x 的动态类型是否满足 T。如果检查成功，x 的动态值不会被提取，返回值是一个类型为 T 的接口值。
- 无论 T 是什么类型，如果 x 是 nil 接口值，类型断言都会失败。

该方法和第一种差不多一样，但是 ok 会返回是否断言成功不会出现 panic，ok 就表示是否是成功了。

#### 类型 switch

go 语法种还提供了另外一种类型 switch 的断言方法。

x 断言成了 type 类型，type 类型具体值就是 switch case 的值，如果 x 成功断言成了某个 case 类型，就可以执行那个 case，此时 i := x.(type) 返回的 i 就是那个类型的变量了，可以直接当作 case 类型使用。

```
switch i := x.(type) {
case nil:
    printString("x is nil")                // type of i is type of x (interface{})
case int:
    printInt(i)                            // type of i is int
case float64:
    printFloat64(i)                        // type of i is float64
case func(int) float64:
    printFunction(i)                       // type of i is func(int) float64
case bool, string:
    printString("type is bool or string")  // type of i is type of x (interface{})
default:
    printString("don't know the type")     // type of i is type of x (interface{})
}
```

### 强制类型转换

强制类型转换通过修改变量类型

该方法不常见，**主要用于 unsafe 包和接口类型检测**，需要懂得 go 变量的知识。

#### unsafe

本文档仅大概说明一下，具体研究请求查找相关资料。unsafe 语法文档 镜像地址

```
var f float64
bits = *(*uint64)(unsafe.Pointer(&f))

type ptr unsafe.Pointer
bits = *(*uint64)(ptr(&f))

var p ptr = nil
```

float64 就强制转换成 uint64 类型，float 的地址就是一个值但是类型是 float64，然后创建了一个 uint64 类型变量，地址值也是 float64 的地址值，两个变量值相同类型不同，强制转换了类型。

unsafe 强制转换是指针的底层操作了，用 c 的朋友就很熟悉这样的指针类型转换，利用内存对齐才能保证转换可靠，例如 int 和 uint 存在符号位差别，利用 unsafe 转换后值可能不同，但是在内存存储二进制一模一样。

#### 接口类型检测

例如下列代码：

```
var _ Context = (*ContextBase)(nil)
```

nil 的类型是 nil 地址值为 0，利用强制类型转换成了 * ContextBase，返回的变量就是类型为 * ContextBase 地址值为 0，然后 Context=xx 赋值如果 xx 实现了 Context 接口就没事，如果没有实现在编译时期就会报错，实现编译期间检测接口是否实现。

### 显式类型转换

一个**显式转换的表达式 T (x)** ，其中 T 是一种类型并且 x 是可转换为类型的表达式 T，例如：uint(666)。

在以下任何一种情况下，变量 x 都可以转换成 T 类型：

- x 可以分配成 T 类型。
- 忽略 struct 标签 x 的类型和 T 具有相同的基础类型。
- 忽略 struct 标记 x 的类型和 T 是未定义类型的指针类型，并且它们的指针基类型具有相同的基础类型。
- x 的类型和 T 都是整数或浮点类型。
- x 的类型和 T 都是复数类型。
- x 的类型是整数或 [] byte 或 [] rune，并且 T 是字符串类型。
- x 的类型是字符串，T 类型是 [] byte 或 [] rune。

例如下列代码利用了规则进行转换，规则实现可以参考 reflect.Value.Convert 方法逻辑：

```
int64(222)
[]byte("ssss")

type A int
A(2)
```

### 隐式类型转换

隐式类型转换日常使用并不会感觉到，但是运行中确实出现了类型转换，以下列出了两种。

#### 组合间的重新断言类型

```
type Reader interface {
    Read(p []byte) (n int, err error)
}
type ReadCloser interface {
    Reader
    Close() error
}
var rc ReaderClose
r := rc
```

ReaderClose 接口组合了 Reader 接口，但是 r=rc 的赋值时还是类型转换了，go 使用系统内置的函数执行了类型转换。以前遇到过类似接口组合类型的变量赋值，然后使用 pprof 和 bench 测试发现了这一细节，在接口类型转移时浪费了一些性能。

#### 相同类型间赋值

```
type Handler func()

func NewHandler() Handler {
    return func() {}
}
```

虽然 type 定义了 Handler 类型，但是 Handler 和 func () 是两种实际类型，类型不会相等，使用反射和断言均会出现两种类型不同。

两者类型不同验证代码：

```
package main

import (
    "fmt"
    "reflect"
)

type Handler func()

func a() Handler {
    return func() {}
}

func main() {
    var i interface{} = main
    _, ok := i.(func())
    fmt.Println(ok)
    _, ok = i.(Handler)
    fmt.Println(ok)
    fmt.Println(reflect.TypeOf(main) == reflect.TypeOf((*Handler)(nil)).Elem())
}

// true
// false
// false
```

## nil

[参考](https://gfw.go101.org/article/nil.html)

`nil`是Go中的一个使用频率很高的预声明标识符。 很多种类的类型的零值都用`nil`表示。 很多有其它语言编程经验的程序员在初学Go语言的时候常将`nil`看成是其它语言中的`null`或者`NULL`。 这种看法只是部分上正确的，但是Go中的`nil`和其它语言中的`null`或者`NULL`也是有很大的区别的。

### 认识 `nil`

#### `nil`是一个预声明的标识符

我们可以直接使用它。

#### 预声明的`nil`标识符可以表示很多种类型的零值

在Go中，预声明的`nil`可以表示下列种类（kind）的类型的零值：

- 指针类型（包括类型安全和非类型安全指针）
- 映射类型
- 切片类型
- 函数类型
- 通道类型
- 接口类型

#### 预声明标识符`nil`没有默认类型

Go中其它的预声明标识符都有各自的默认类型，比如

- 预声明标识符`true`和`false`的默认类型均为内置类型`bool`。
- 预声明标识符`iota`的默认类型为内置类型`int`。

但是，**预声明标识符`nil`没有一个默认类型**，尽管它有很多潜在的可能类型。 事实上，**预声明标识符`nil`是Go中唯一一个没有默认类型的类型不确定值**。 我们必须在代码中提供足够的信息以便让编译器能够推断出一个类型不确定的`nil`值的期望类型。

一个例子：

```go
package main

func main() {
	// 代码中必须提供充足的信息来让编译器推断出某个nil的类型。
	_ = (*struct{})(nil)
	_ = []int(nil)
	_ = map[int]bool(nil)
	_ = chan string(nil)
	_ = (func())(nil)
	_ = interface{}(nil)

	// 下面这一组和上面这一组等价。
	var _ *struct{} = nil
	var _ []int = nil
	var _ map[int]bool = nil
	var _ chan string = nil
	var _ func() = nil
	var _ interface{} = nil

	// 下面这行编译不通过。
	var _ = nil
}
```

#### `nil`不是一个关键字

预声明标识符`nil`可以被更内层的同名标识符所遮挡。

一个例子：

```go
package main

import "fmt"

func main() {
	nil := 123
	fmt.Println(nil) // 123

	// 下面这行编译报错，因为此行中的nil是一个int值。
	var _ map[string]int = nil
}
```

*（顺便说一下，其它语言中的`null`和`NULL`也不是关键字。）*

#### 不同种类的类型的nil值的尺寸很可能不相同

一个类型的所有值的内存布局都是一样的，此类型nil值也不例外（假设此类型的零值使用`nil`表示）。 所以同一个类型的nil值和非nil值的尺寸是一样的。但是**不同类型的nil值的尺寸可能是不一样**的。

一个例子：

```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	var p *struct{} = nil
	fmt.Println( unsafe.Sizeof( p ) ) // 8

	var s []int = nil
	fmt.Println( unsafe.Sizeof( s ) ) // 24

	var m map[int]bool = nil
	fmt.Println( unsafe.Sizeof( m ) ) // 8

	var c chan string = nil
	fmt.Println( unsafe.Sizeof( c ) ) // 8

	var f func() = nil
	fmt.Println( unsafe.Sizeof( f ) ) // 8

	var i interface{} = nil
	fmt.Println( unsafe.Sizeof( i ) ) // 16
}
```

上例打印出来的尺寸值取决于系统架构和具体编译器实现。 上例中的输出是使用官方标准编译器编译并在64位的系统架构上运行的结果。 在32位的系统架构上，这些输出值将减半。

对于官方标准编译器，**如果两个类型属于同一种（kind）类型，并且它们的零值用`nil`表示，则这两个类型的尺寸肯定相等**。

#### 两个不同类型的nil值可能不能相互比较

比如，下例中的两行中的比较均编译不通过。

```go
// error: 类型不匹配
var _ = (*int)(nil) == (*bool)(nil)
// error: 类型不匹配
var _ = (chan int)(nil) == (chan bool)(nil)
```

请阅读[Go中的值比较规则](https://gfw.go101.org/article/value-conversions-assignments-and-comparisons.html#comparison-rules)来了解哪些值可以相互比较。 类型确定的nil值也要遵循这些规则。

下面这些比较是合法的：

```go
type IntPtr *int
// 类型IntPtr的底层类型为*int。
var _ = IntPtr(nil) == (*int)(nil)

// 任何类型都实现了interface{}类型。
var _ = (interface{})(nil) == (*int)(nil)

// 一个双向通道可以隐式转换为和它的
// 元素类型一样的单项通道类型。
var _ = (chan int)(nil) == (chan<- int)(nil)
var _ = (chan int)(nil) == (<-chan int)(nil)
```

#### 同一个类型的两个nil值可能不能相互比较

在Go中，**映射类型、切片类型和函数类型是不支持比较类型**。 比较同一个不支持比较的类型的两个值（包括nil值）是非法的。 比如，下面的几个比较都编译不通过。

```go
var _ = ([]int)(nil) == ([]int)(nil)
var _ = (map[string]int)(nil) == (map[string]int)(nil)
var _ = (func())(nil) == (func())(nil)
```

但是，映射类型、切片类型和函数类型的任何值都可以和类型不确定的裸`nil`标识符比较。

```go
// 这几行编译都没问题。
var _ = ([]int)(nil) == nil
var _ = (map[string]int)(nil) == nil
var _ = (func())(nil) == nil
```

#### 两个nil值可能并不相等

如果可被比较的两个nil值中的一个的类型为接口类型，而另一个不是，则比较结果总是`false`。 原因是，在进行此比较之前，此非接口nil值将被转换为另一个nil值的接口类型，从而将此比较转化为两个接口值的比较。 从[接口](https://gfw.go101.org/article/interface.html#boxing)一文中，我们得知每个接口值可以看作是一个包裹非接口值的盒子。 一个非接口值被转换为一个接口类型的过程可以看作是用一个接口值将此非接口值包裹起来的过程。 一个nil接口值中什么也没包裹，但是一个包裹了nil非接口值的接口值并非什么都没包裹。 一个什么都没包裹的接口值和一个包裹了一个非接口值（即使它是nil）的接口值是不相等的。

一个例子：

```go
fmt.Println( (interface{})(nil) == (*int)(nil) ) // false
```

#### 访问nil映射值的条目不会产生恐慌

访问一个nil映射将得到此映射的类型的元素类型的零值。

比如：

```go
fmt.Println( (map[string]int)(nil)["key"] ) // 0
fmt.Println( (map[int]bool)(nil)[123] )     // false
fmt.Println( (map[int]*int64)(nil)[123] )   // 
```

#### `range`关键字后可以跟随nil通道、nil映射、nil切片和nil数组指针

遍历nil映射和nil切片的循环步数均为零。

遍历一个nil数组指针的循环步数为对应数组类型的长度。 （但是，如果此数组类型的长度不为零并且第二个循环变量未被舍弃或者忽略，则对应`for-range`循环将导致一个恐慌。）

遍历一个nil通道将使当前协程永久阻塞。

比如，下面的代码将输出`0`、`1`、`2`、`3`和`4`后进入阻塞状态。 `Hello`、`world`和`Bye`不会被输出。

```go
for range []int(nil) {
	fmt.Println("Hello")
}

for range map[string]string(nil) {
	fmt.Println("world")
}

for i := range (*[5]int)(nil) {
	fmt.Println(i)
}

for range chan bool(nil) { // 阻塞在此
	fmt.Println("Bye")
}
```

#### 通过nil非接口属主实参调用方法不会造成恐慌

一个例子：

```go
package main

type Slice []bool

func (s Slice) Length() int {
	return len(s)
}

func (s Slice) Modify(i int, x bool) {
	s[i] = x // panic if s is nil
}

func (p *Slice) DoNothing() {
}

func (p *Slice) Append(x bool) {
	*p = append(*p, x) // 如果p为空指针，则产生一个恐慌。
}

func main() {
	// 下面这几行中的选择器不会造成恐慌。
	_ = ((Slice)(nil)).Length
	_ = ((Slice)(nil)).Modify
	_ = ((*Slice)(nil)).DoNothing
	_ = ((*Slice)(nil)).Append

	// 这两行也不会造成恐慌。
	_ = ((Slice)(nil)).Length()
	((*Slice)(nil)).DoNothing()

	// 下面这两行都会造成恐慌。但是恐慌不是因为nil
	// 属主实参造成的。恐慌都来自于这两个方法内部的
	// 对空指针的解引用操作。
	/*
	((Slice)(nil)).Modify(0, true)
	((*Slice)(nil)).Append(true)
	*/
}
```

事实上，上面的`Append`方法实现不完美。我们应该像下面这样实现之：

```go
func (p *Slice) Append(x bool) {
	if p == nil {
		*p = []bool{x}
		return
	}
	*p = append(*p, x)
}
```



#### 如果类型`T`的零值可以用预声明的`nil`标识符表示，则`*new(T)`的估值结果为一个`T`类型的nil值

一个例子：

```go
package main

import "fmt"

func main() {
	fmt.Println(*new(*int) == nil)         // true
	fmt.Println(*new([]int) == nil)        // true
	fmt.Println(*new(map[int]bool) == nil) // true
	fmt.Println(*new(chan string) == nil)  // true
	fmt.Println(*new(func()) == nil)       // true
	fmt.Println(*new(interface{}) == nil)  // true
}
```

#### 总结一下

在Go中，为了简单和方便，`nil`被设计成一个可以表示成很多种类型的零值的预声明标识符。 换句话说，它可以表示很多内存布局不同的值，而不仅仅是一个值。

### [不同类型中的nil](https://segmentfault.com/a/1190000038175302)

## 比较

[参考](https://juejin.cn/post/6881912621616857102)

[参考2](https://www.jianshu.com/p/a982807819fa)

- 可比较：*Integer*，*Floating-point*，*String*，*Boolean*，*Complex(复数型)*，*Pointer*，*Channel*，*Interface*，*Array*
- 不可比较：*Slice*，*Map*，*Function*

对于 int，float，string， Complex， array，boolean可直接==将两个变量比较

golang中基本类型的比较规则和复合类型的不一致，先介绍下golang的变量类型：

- 1，基本类型
  - 整型，包括int，uint，int8，uint8，int16，uint16，int32，uint32，int64，uint64，byte，rune，uintptr等
  - 浮点型，包括float32，float64
  - 复数类型，包括complex64，complex128
  - 字符串类型，string
  - 布尔型，bool
- 2，复合类型
  - 数组
  - struct结构体
- 3，引用类型
  - slice
  - map
  - channel
  - pointer or 引用类型
- 4，接口类型
  io.Reader, io.Writer,error等

#### 一，基本类型的变量比较

golang中的基本类型

比较的两个变量类型必须相等。而且，golang没有隐式类型转换，比较的两个变量必须类型完全一样，类型别名也不行。如果要比较，先做类型转换再比较。

- 类型完全不一样的，不能比较
- `类型再定义关系，不能比较，可以强转比较`
- `类型别名关系，可以比较`

```go
    fmt.Println("2" == 2) //invalid operation: "2" == 2 (mismatched types string and int)

    type A int
    var a int = 1
    var b A = 1
    fmt.Println(a == b) //invalid operation: a == b (mismatched types int and A)
    fmt.Println(a == int(b)) //true

    type C = int
    var c C = 1
    fmt.Println(a == c) //true
```

#### 二，复合类型的变量比较

**复合类型是逐个字段，逐个元素比较的**。需要注意的是，`array 或者struct中每个元素必须要是可比较的，如果某个array的元素 or struct的成员不能比较(比如是后面介绍的slice，map等)，则此复合类型也不能比较。`

##### 1，数组类型变量比较

- **数组的长度是类型的一部分**，如果数组长度不同，无法比较
- 逐个元素比较类型和值。每个对应元素的比较遵循基本类型变量的比较规则。跟struct一样，如果item是不可比较的类型，则array也不能做比较。

##### 2，struct类型变量比较

逐个成员比较类型和值。每个对应成员的比较遵循基本类型变量的比较规则。

```go
    type Student struct {
        Name string
        Age  int
    }

    a := Student{"minping", 30}
    b := Student{"minping", 30}
    fmt.Println(a == b)   //true
    fmt.Println(&a == &b) //false
```

但是如果struct中有不可比较的成员类型时：

```go
type Student struct {
        Name string
        Age  int
        Info []string
    }

    a := Student{
        Name: "minping",
        Age:  30,
    }
    b := Student{
        Name: "minping",
        Age:  30,
    }
    fmt.Println(a == b)   //invalid operation: a == b (struct containing []string cannot be compared)
```

可以看到，struct中有slice这种不可比较的成员时，整个struct都不能做比较，即使没有对slice那个成员赋值(slice默认值为nil)

#### 三，引用类型的变量比较

slice和map的比较规则比较奇怪，我们先说普通的变量引用类型&val和channel的比较规则。

##### 1，普通的变量引用类型&val和channel的比较规则

引用类型变量存储的是某个变量的内存地址。所以引用类型变量的比较，判断的是这两个引用类型存储的是不是同一个变量。

- 如果是**同一个变量**，则内存地址肯定也一样，则引用类型变量相等，用"=="判断为true
- 如果**不是同一个变量**，则内存地址肯定不一样，"=="结果为false

上面看起来比较废话，但是得理解引用类型的含义。不然对判断规则还是不清楚。

```go
type Student struct {
        Name string
        Age  int
    }

    a := &Student{"minping", 30}

    b := &Student{"minping", 30}
    fmt.Println(a == b) //false

    c := a
    fmt.Println(a == c) //true
        
        //作为引用类型，channel和普通的&val判断规则一致
        ch1 := make(chan int, 1)
        ch2 := make(chan int, 1)
        ch3 := ch1

        fmt.Println(ch1 == ch2) //false
        fmt.Println(ch1 == ch3) //true
```

##### 2，slice这种引用类型的比较

```
slice类型不可比较，只能与零值nil做比较。
```

```go
    a := []string{}
    b := []string{}
    fmt.Println(a == b)  //invalid operation: a == b (slice can only be compared to nil)
```

关于slice类型不可比较的原因，后面会专门写文章做讨论。

##### 3， map类型的比较

```
map类型和slice一样，不能比较，只能与nil做比较。
```

#### 四，interface{}类型变量的比较

**接口类型的变量，包含该接口变量存储的值和值的类型两部分组成，分别称为接口的动态类型和动态值**。`只有动态类型和动态值都相同时，两个接口变量才相同:`

```go
type Person interface {
    getName() string
}

type Student struct {
    Name string
}

type Teacher struct {
    Name string
}

func (s Student) getName() string {
    return s.Name
}

func (t Teacher) getName() string {
    return t.Name
}

func compare(s, t Person) bool {
    return s == t
}

func main() {

    s1 := Student{"minping"}
    s2 := Student{"minping"}
    t := Teacher{"minping"}

    fmt.Println(compare(s1, s2)) //true
    fmt.Println(compare(s1, t))  //false,类型不同
}
```

而且**接口的动态类型必须要是可比较的**，如果不能比较(比如slice，map)，则运行时会报panic。因为编译器在编译时无法获取接口的动态类型，所以编译能通过，但是运行时直接panic:

```go
type Person interface {
    getName() string
}

type Student map[string]string

type Teacher map[string]string

func (s Student) getName() string {
    return s["name"]
}

func (t Teacher) getName() string {
    return t["name"]
}

func compare(s, t Person) bool {
    return s == t
}

func main() {

    s1 := Student{}
    s1["name"] = "minping"
    s2 := Student{}
    s2["name"] = "minping"

    fmt.Println(compare(s1, s2)) //runtime error: comparing uncomparable type main.Student

}
```

#### 五，函数类型的比较

golang的func作为一等公民，也是一种类型，而且不可比较

```go
f := func(int) int { return 1 }
g := func(int) int { return 2 }
f == g
```

#### 六，slice和map的特殊比较

上面说过，map和slice是不可比较类型，但是有没有特殊的方法来对slice和map做比较呢，有

##### 1，[]byte类型的变量，使用工具包byte提供的函数就可以做比较

```go
s1 := []byte{'f', 'o', 'o'}
s2 := []byte{'f', 'o', 'o'}
fmt.Println(bytes.Equal(s1, s2)) // true
s2 = []byte{'b', 'a', 'r'}
fmt.Println(bytes.Equal(s1, s2)) // false
s2 = []byte{'f', 'O', 'O'}
fmt.Println(bytes.EqualFold(s1, s2)) // true
s1 = []byte("źdźbło")
s2 = []byte("źdŹbŁO")
fmt.Println(bytes.EqualFold(s1, s2)) // true
s1 = []byte{}
s2 = nil
fmt.Println(bytes.Equal(s1, s2)) // true
```

##### 2，使用反射

reflect.DeepEqual函数可以用来比较两个任意类型的变量

```go
func DeepEqual(x, y interface{})
```

对map类型做比较：

```go
m1 := map[string]int{"foo": 1, "bar": 2}
m2 := map[string]int{"foo": 1, "bar": 2}
// fmt.Println(m1 == m2) // map can only be compared to nil
fmt.Println(reflect.DeepEqual(m1, m2)) // true
m2 = map[string]int{"foo": 1, "bar": 3}
fmt.Println(reflect.DeepEqual(m1, m2)) // false
m3 := map[string]interface{}{"foo": [2]int{1,2}}
m4 := map[string]interface{}{"foo": [2]int{1,2}}
fmt.Println(reflect.DeepEqual(m3, m4)) // true
var m5 map[float64]string
fmt.Println(reflect.DeepEqual(m5, nil)) // false
fmt.Println(m5 == nil) // true
```

对slice类型做比较：

```go
s := []string{"foo"}
fmt.Println(reflect.DeepEqual(s, []string{"foo"})) // true
fmt.Println(reflect.DeepEqual(s, []string{"bar"})) // false
s = nil
fmt.Println(reflect.DeepEqual(s, []string{})) // false
s = []string{}
fmt.Println(reflect.DeepEqual(s, []string{})) // true
```

对struct类型做比较：

```go
type T struct {
    name string
    Age  int
}
func main() {
    t := T{"foo", 10}
    fmt.Println(reflect.DeepEqual(t, T{"bar", 20})) // false
    fmt.Println(reflect.DeepEqual(t, T{"bar", 10})) // false
    fmt.Println(reflect.DeepEqual(t, T{"foo", 10})) // true
}
```

可以发现，只要变量的类型和值相同的话，reflect.DeepEqual比较的结果就为true

##### 3，使用google的cmp包

直接看用例：

```go
import (
    "fmt"
    "github.com/google/go-cmp/cmp"
)
type T struct {
    Name string
    Age  int
    City string
}
func main() {
    x := T{"Michał", 99, "London"}
    y := T{"Adam", 88, "London"}
    if diff := cmp.Diff(x, y); diff != "" {
        fmt.Println(diff)
    }
}
```

结果为：

```bash
 main.T{
-       Name: "Michał",
+       Name: "Adam",
-       Age:  99,
+       Age:  88,
        City: "London",
  }
```

#### 总结

- 1，复合类型，只有每个元素(成员)可比较，而且类型和值都相等时，两个复合元素才相等
- 2，slice，map不可比较，但是可以用reflect或者cmp包来比较
- 3，func作为golnag的一等公民，也是一个类型，也不能比较。
- 4，引用类型的比较是看指向的是不是同一个变量
- 5，类型再定义(type A string)不可比较，是两种不同的类型
- 6，类型别名(type A = string)可比较，是同一种类型。

### reflect.DeepEqual

DeepEqual函数用来判断两个值是否深度一致。具体比较规则如下：

- 不同类型的值永远不会深度相等
- 当两个数组的元素对应深度相等时，两个数组深度相等
- 当两个相同结构体的所有字段对应深度相等的时候，两个结构体深度相等
- 当两个函数都为nil时，两个函数深度相等，其他情况不相等（相同函数也不相等）
- 当两个interface的真实值深度相等时，两个interface深度相等
- map的比较需要同时满足以下几个
  - 两个map都为nil或者都不为nil，并且长度要相等
  - 相同的map对象或者所有key要对应相同
  - map对应的value也要深度相等
- 指针，满足以下其一即是深度相等
  - 两个指针满足go的==操作符
  - 两个指针指向的值是深度相等的
- 切片，需要同时满足以下几点才是深度相等
  - 两个切片都为nil或者都不为nil，并且长度要相等
  - 两个切片底层数据指向的第一个位置要相同或者底层的元素要深度相等
  - 注意：空的切片跟nil切片是不深度相等的
- 其他类型的值（numbers, bools, strings, channels）如果满足go的==操作符，则是深度相等的。要注意不是所有的值都深度相等于自己，例如函数，以及嵌套包含这些值的结构体，数组等

## 序列化



## 关键字

```
var和const ：变量和常量的声明

var varName type  或者 varName : = value

package and import: 导入

func： 用于定义函数和方法

return ：用于从函数返回

defer someCode ：在函数退出之前执行

go : 用于并行

select 用于选择不同类型的通讯

interface 用于定义接口

struct 用于定义抽象数据类型

break、case、continue、for、fallthrough、else、if、switch、goto、default 流程控制

chan用于channel通讯

type用于声明自定义类型

map用于声明map类型数据

range用于读取slice、map、channel数据
```

### make 和 new



### select

[参考](https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#非阻塞的收发)

Go 语言中的 `select` 也能够让 Goroutine 同时等待多个 Channel 可读或者可写，在多个文件或者 Channel状态改变之前，`select` 会一直阻塞当前线程或者 Goroutine。

![Golang-Select-Channels](https://img.draveness.me/2020-01-19-15794018429532-Golang-Select-Channels.png)

当我们在 Go 语言中使用 `select` 控制结构时，会遇到两个有趣的现象：

1. `select` 能在 Channel 上进行非阻塞的收发操作；
2. `select` 在遇到多个 Channel 同时响应时，会随机执行一种情况；

这两个现象是学习 `select` 时经常会遇到的，我们来深入了解具体场景并分析这两个现象背后的设计原理。

#### 非阻塞的收发

在通常情况下，`select` 语句会阻塞当前 Goroutine 并等待多个 Channel 中的一个达到可以收发的状态。但是如果 `select` 控制结构中包含 `default` 语句，那么这个 `select` 语句在执行时会遇到以下两种情况：

1. **当存在可以收发的 Channel 时**，直接处理该 Channel 对应的 `case`；
2. **当不存在可以收发的 Channel 时**，执行 `default` 中的语句；

当我们运行下面的代码时就不会阻塞当前的 Goroutine，它会直接执行 `default` 中的代码。

```go
func main() {
	ch := make(chan int)
	select {
	case i := <-ch:
		println(i)

	default:
		println("default")
	}
}
```

```
$ go run main.go
default
```

只要我们稍微想一下，就会发现 Go 语言设计的这个现象很合理。`select` 的作用是同时监听多个 `case` 是否可以执行，如果多个 Channel 都不能执行，那么运行 `default` 也是理所当然的。

**非阻塞的 Channel 发送和接收操作还是很有必要的**，在很多场景下我们不希望 Channel 操作阻塞当前 Goroutine，只是想看看 Channel 的可读或者可写状态，如下所示：

```go
errCh := make(chan error, len(tasks))
wg := sync.WaitGroup{}
wg.Add(len(tasks))
for i := range tasks {
    go func() {
        defer wg.Done()
        if err := tasks[i].Run(); err != nil {
            errCh <- err
        }
    }()
}
wg.Wait()

select {
case err := <-errCh:
    return err
default:
    return nil
}
```

在上面这段代码中，我们不关心到底多少个任务执行失败了，只关心是否存在返回错误的任务，最后的 `select` 语句能很好地完成这个任务。然而使用 `select` 实现非阻塞收发不是最初的设计，Go 语言在最初版本使用 `x, ok := <-c` 实现非阻塞的收发，以下是与非阻塞收发相关的提交：

1. [select default](https://github.com/golang/go/commit/79fbbe37a76502e6f5f9647d2d82bab953ab1546) 提交支持了 `select` 语句中的 `default`[1](https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:1)；
2. [gc: special case code for single-op blocking and non-blocking selects](https://github.com/golang/go/commit/5038792837355abde32f2e9549ef132fc5ffbd16) 提交引入了基于 `select` 的非阻塞收发[2](https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:2)。
3. [gc: remove non-blocking send, receive syntax](https://github.com/golang/go/commit/cb584707af2d8803adba88fd9692e665ecd2f059) 提交将 `x, ok := <-c` 语法删除[3](https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:3)；
4. [gc, runtime: replace closed(c) with x, ok := <-c](https://github.com/golang/go/commit/8bf34e335686816f7fe7e28614b2c7a3e04e9e7c) 提交使用 `x, ok := <-c` 语法替代 `closed(c)` 语法判断 Channel 的关闭状态[4](https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:4)；

我们可以从上面的几个提交中看到非阻塞收发从最初版本到现在的演变。

#### 随机执行

另一个使用 `select` 遇到的情况是同时有多个 `case` 就绪时，`select` 会选择哪个 `case` 执行的问题，我们通过下面的代码可以简单了解一下：

```go
func main() {
	ch := make(chan int)
	go func() {
		for range time.Tick(1 * time.Second) {
			ch <- 0
		}
	}()

	for {
		select {
		case <-ch:
			println("case1")
		case <-ch:
			println("case2")
		}
	}
}
```

```
$ go run main.go
case1
case2
case1
...
```

从上述代码输出的结果中我们可以看到，`select` 在遇到多个 `<-ch` 同时满足可读或者可写条件时会随机选择一个 `case` 执行其中的代码。

这个设计是在十多年前被 [select](https://github.com/golang/go/commit/cb9b1038db77198c2b0961634cf161258af2374d) 提交[5](https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:5)引入并一直保留到现在的，虽然中间经历过一些修改[6](https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/#fn:6)，但是语义一直都没有改变。在上面的代码中，两个 `case` 都是同时满足执行条件的，如果我们按照顺序依次判断，那么后面的条件永远都会得不到执行，而随机的引入就是为了避免饥饿问题的发生。

#### 数据结构

`select` 在 Go 语言的源代码中不存在对应的结构体，但是我们使用 [`runtime.scase`](https://draveness.me/golang/tree/runtime.scase) 结构体表示 `select` 控制结构中的 `case`：

```go
type scase struct {
	c    *hchan         // chan
	elem unsafe.Pointer // data element
}
```

因为非默认的 `case` 中都与 Channel 的发送和接收有关，所以 [`runtime.scase`](https://draveness.me/golang/tree/runtime.scase) 结构体中也包含一个 [`runtime.hchan`](https://draveness.me/golang/tree/runtime.hchan) 类型的字段存储 `case` 中使用的 Channel。

#### 实现原理

`select` 语句在编译期间会被转换成 `OSELECT` 节点。每个 `OSELECT` 节点都会持有一组 `OCASE` 节点，如果 `OCASE` 的执行条件是空，那就意味着这是一个 `default` 节点。

![golang-oselect-and-ocases](https://img.draveness.me/2020-01-18-15793463657473-golang-oselect-and-ocases.png)

**图 5-7 OSELECT 和多个 OCASE**

上图展示的就是 `select` 语句在编译期间的结构，每一个 `OCASE` 既包含执行条件也包含满足条件后执行的代码。

编译器在中间代码生成期间会根据 `select` 中 `case` 的不同对控制语句进行优化，这一过程都发生在 [`cmd/compile/internal/gc.walkselectcases`](https://draveness.me/golang/tree/cmd/compile/internal/gc.walkselectcases) 函数中，我们在这里会分四种情况介绍处理的过程和结果：

1. `select` 不存在任何的 `case`；
2. `select` 只存在一个 `case`；
3. `select` 存在两个 `case`，其中一个 `case` 是 `default`；
4. `select` 存在多个 `case`；

上述四种情况不仅会涉及编译器的重写和优化，还会涉及 Go 语言的运行时机制，我们会从编译期间和运行时两个角度分析上述情况。

##### 直接阻塞

首先介绍的是最简单的情况，也就是当 `select` 结构中不包含任何 `case`。我们截取 [`cmd/compile/internal/gc.walkselectcases`](https://draveness.me/golang/tree/cmd/compile/internal/gc.walkselectcases) 函数的前几行代码：

```go
func walkselectcases(cases *Nodes) []*Node {
	n := cases.Len()

	if n == 0 {
		return []*Node{mkcall("block", nil, nil)}
	}
	...
}
```

这段代码很简单并且容易理解，它直接将类似 `select {}` 的语句转换成调用 [`runtime.block`](https://draveness.me/golang/tree/runtime.block) 函数：

```go
func block() {
	gopark(nil, nil, waitReasonSelectNoCases, traceEvGoStop, 1)
}
```

[`runtime.block`](https://draveness.me/golang/tree/runtime.block) 的实现非常简单，它会调用 [`runtime.gopark`](https://draveness.me/golang/tree/runtime.gopark) 让出当前 Goroutine 对处理器的使用权并传入等待原因 `waitReasonSelectNoCases`。

简单总结一下，空的 `select` 语句会直接阻塞当前 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。

##### 单一管道

如果当前的 `select` 条件只包含一个 `case`，那么编译器会将 `select` 改写成 `if` 条件语句。下面对比了改写前后的代码：

```go
// 改写前
select {
case v, ok <-ch: // case ch <- v
    ...    
}

// 改写后
if ch == nil {
    block()
}
v, ok := <-ch // case ch <- v
...
```

[`cmd/compile/internal/gc.walkselectcases`](https://draveness.me/golang/tree/cmd/compile/internal/gc.walkselectcases) 在处理单操作 `select` 语句时，会根据 Channel 的收发情况生成不同的语句。当 `case` 中的 Channel 是空指针时，会直接挂起当前 Goroutine 并陷入永久休眠。

##### 非阻塞操作

当 `select` 中仅包含两个 `case`，并且其中一个是 `default` 时，Go 语言的编译器就会认为这是一次非阻塞的收发操作。[`cmd/compile/internal/gc.walkselectcases`](https://draveness.me/golang/tree/cmd/compile/internal/gc.walkselectcases) 会对这种情况单独处理。不过在正式优化之前，该函数会将 `case` 中的所有 Channel 都转换成指向 Channel 的地址，我们会分别介绍非阻塞发送和非阻塞接收时，编译器进行的不同优化。

##### 发送

首先是 Channel 的发送过程，当 `case` 中表达式的类型是 `OSEND` 时，编译器会使用条件语句和 [`runtime.selectnbsend`](https://draveness.me/golang/tree/runtime.selectnbsend) 函数改写代码：

```go
select {
case ch <- i:
    ...
default:
    ...
}

if selectnbsend(ch, i) {
    ...
} else {
    ...
}
```

这段代码中最重要的就是 [`runtime.selectnbsend`](https://draveness.me/golang/tree/runtime.selectnbsend)，它为我们提供了向 Channel 非阻塞地发送数据的能力。我们在 Channel 一节介绍了向 Channel 发送数据的 [`runtime.chansend`](https://draveness.me/golang/tree/runtime.chansend) 函数包含一个 `block` 参数，该参数会决定这一次的发送是不是阻塞的：

```go
func selectnbsend(c *hchan, elem unsafe.Pointer) (selected bool) {
	return chansend(c, elem, false, getcallerpc())
}
```

由于我们向 [`runtime.chansend`](https://draveness.me/golang/tree/runtime.chansend) 函数传入了非阻塞，所以在不存在接收方或者缓冲区空间不足时，当前 Goroutine 都不会阻塞而是会直接返回。

接收

由于从 Channel 中接收数据可能会返回一个或者两个值，所以接收数据的情况会比发送稍显复杂，不过改写的套路是差不多的：

```go
// 改写前
select {
case v <- ch: // case v, ok <- ch:
    ......
default:
    ......
}

// 改写后
if selectnbrecv(&v, ch) { // if selectnbrecv2(&v, &ok, ch) {
    ...
} else {
    ...
}
```

返回值数量不同会导致使用函数的不同，两个用于非阻塞接收消息的函数 [`runtime.selectnbrecv`](https://draveness.me/golang/tree/runtime.selectnbrecv) 和 [`runtime.selectnbrecv2`](https://draveness.me/golang/tree/runtime.selectnbrecv2) 只是对 [`runtime.chanrecv`](https://draveness.me/golang/tree/runtime.chanrecv) 返回值的处理稍有不同：

```go
func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected bool) {
	selected, _ = chanrecv(c, elem, false)
	return
}

func selectnbrecv2(elem unsafe.Pointer, received *bool, c *hchan) (selected bool) {
	selected, *received = chanrecv(c, elem, false)
	return
}
```

因为接收方不需要，所以 [`runtime.selectnbrecv`](https://draveness.me/golang/tree/runtime.selectnbrecv) 会直接忽略返回的布尔值，而 [`runtime.selectnbrecv2`](https://draveness.me/golang/tree/runtime.selectnbrecv2) 会将布尔值回传给调用方。与 [`runtime.chansend`](https://draveness.me/golang/tree/runtime.chansend) 一样，[`runtime.chanrecv`](https://draveness.me/golang/tree/runtime.chanrecv) 也提供了一个 `block` 参数用于控制这次接收是否阻塞。

##### 常见流程

在默认的情况下，编译器会使用如下的流程处理 `select` 语句：

1. 将所有的 `case` 转换成包含 Channel 以及类型等信息的 [`runtime.scase`](https://draveness.me/golang/tree/runtime.scase) 结构体；
2. 调用运行时函数 [`runtime.selectgo`](https://draveness.me/golang/tree/runtime.selectgo) 从多个准备就绪的 Channel 中选择一个可执行的 [`runtime.scase`](https://draveness.me/golang/tree/runtime.scase) 结构体；
3. 通过 `for` 循环生成一组 `if` 语句，在语句中判断自己是不是被选中的 `case`；

一个包含三个 `case` 的正常 `select` 语句其实会被展开成如下所示的逻辑，我们可以看到其中处理的三个部分：

```go
selv := [3]scase{}
order := [6]uint16
for i, cas := range cases {
    c := scase{}
    c.kind = ...
    c.elem = ...
    c.c = ...
}
chosen, revcOK := selectgo(selv, order, 3)
if chosen == 0 {
    ...
    break
}
if chosen == 1 {
    ...
    break
}
if chosen == 2 {
    ...
    break
}
```

展开后的代码片段中最重要的就是用于选择待执行 `case` 的运行时函数 [`runtime.selectgo`](https://draveness.me/golang/tree/runtime.selectgo)，这也是我们要关注的重点。因为这个函数的实现比较复杂， 所以这里分两部分分析它的执行过程：

1. 执行一些必要的初始化操作并确定 `case` 的处理顺序；
2. 在循环中根据 `case` 的类型做出不同的处理；

###### 初始化

[`runtime.selectgo`](https://draveness.me/golang/tree/runtime.selectgo) 函数首先会进行执行必要的初始化操作并决定处理 `case` 的两个顺序 — 轮询顺序 `pollOrder` 和加锁顺序 `lockOrder`：

```go
func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) {
	cas1 := (*[1 << 16]scase)(unsafe.Pointer(cas0))
	order1 := (*[1 << 17]uint16)(unsafe.Pointer(order0))
	
	ncases := nsends + nrecvs
	scases := cas1[:ncases:ncases]
	pollorder := order1[:ncases:ncases]
	lockorder := order1[ncases:][:ncases:ncases]

	norder := 0
	for i := range scases {
		cas := &scases[i]
	}

	for i := 1; i < ncases; i++ {
		j := fastrandn(uint32(i + 1))
		pollorder[norder] = pollorder[j]
		pollorder[j] = uint16(i)
		norder++
	}
	pollorder = pollorder[:norder]
	lockorder = lockorder[:norder]

	// 根据 Channel 的地址排序确定加锁顺序
	...
	sellock(scases, lockorder)
	...
}
```

轮询顺序 `pollOrder` 和加锁顺序 `lockOrder` 分别是通过以下的方式确认的：

- 轮询顺序：通过 [`runtime.fastrandn`](https://draveness.me/golang/tree/runtime.fastrandn) 函数引入随机性；
- 加锁顺序：按照 Channel 的地址排序后确定加锁顺序；

随机的轮询顺序可以避免 Channel 的饥饿问题，保证公平性；而根据 Channel 的地址顺序确定加锁顺序能够避免死锁的发生。这段代码最后调用的 [`runtime.sellock`](https://draveness.me/golang/tree/runtime.sellock) 会按照之前生成的加锁顺序锁定 `select` 语句中包含所有的 Channel。

###### 循环

当我们为 `select` 语句锁定了所有 Channel 之后就会进入 [`runtime.selectgo`](https://draveness.me/golang/tree/runtime.selectgo) 函数的主循环，它会分三个阶段查找或者等待某个 Channel 准备就绪：

1. 查找是否已经存在准备就绪的 Channel，即可以执行收发操作；
2. 将当前 Goroutine 加入 Channel 对应的收发队列上并等待其他 Goroutine 的唤醒；
3. 当前 Goroutine 被唤醒之后找到满足条件的 Channel 并进行处理；

[`runtime.selectgo`](https://draveness.me/golang/tree/runtime.selectgo) 函数会根据不同情况通过 `goto` 语句跳转到函数内部的不同标签执行相应的逻辑，其中包括：

- `bufrecv`：可以从缓冲区读取数据；
- `bufsend`：可以向缓冲区写入数据；
- `recv`：可以从休眠的发送方获取数据；
- `send`：可以向休眠的接收方发送数据；
- `rclose`：可以从关闭的 Channel 读取 EOF；
- `sclose`：向关闭的 Channel 发送数据；
- `retc`：结束调用并返回；

我们先来分析循环执行的第一个阶段，查找已经准备就绪的 Channel。循环会遍历所有的 `case` 并找到需要被唤起的 [`runtime.sudog`](https://draveness.me/golang/tree/runtime.sudog) 结构，在这个阶段，我们会根据 `case` 的四种类型分别处理：

1. 当 case 不包含 Channel 时；

   - 这种 case 会被跳过；

2. 当 case 会从 Channel 中接收数据时；

   - 如果当前 Channel 的 sendq 上有等待的 Goroutine，就会跳到 recv 标签并从缓冲区读取数据后将等待 Goroutine 中的数据放入到缓冲区中相同的位置；

   - 如果当前 Channel 的缓冲区不为空，就会跳到 bufrecv 标签处从缓冲区获取数据；

   - 如果当前 Channel 已经被关闭，就会跳到 rclose 做一些清除的收尾工作；

3. 当 case 会向 Channel 发送数据时；

   - 如果当前 Channel 已经被关，闭就会直接跳到 sclose 标签，触发 panic 尝试中止程序；

   - 如果当前 Channel 的 recvq 上有等待的 Goroutine，就会跳到 send 标签向 Channel 发送数据；

   - 如果当前 Channel 的缓冲区存在空闲位置，就会将待发送的数据存入缓冲区；

4. 当 select 语句中包含 default 时；

   - 表示前面的所有 case 都没有被执行，这里会解锁所有 Channel 并返回，意味着当前 select 结构中的收发都是非阻塞的；

![golang-runtime-selectgo](https://img.draveness.me/2020-01-18-15793463657488-golang-runtime-selectgo.png)

**图 5-8 运行时 selectgo 函数**

第一阶段的主要职责是查找所有 `case` 中是否有可以立刻被处理的 Channel。无论是在等待的 Goroutine 上还是缓冲区中，只要存在数据满足条件就会立刻处理，如果不能立刻找到活跃的 Channel 就会进入循环的下一阶段，按照需要将当前 Goroutine 加入到 Channel 的 `sendq` 或者 `recvq` 队列中：

```go
func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) {
	...
	gp = getg()
	nextp = &gp.waiting
	for _, casei := range lockorder {
		casi = int(casei)
		cas = &scases[casi]
		c = cas.c
		sg := acquireSudog()
		sg.g = gp
		sg.c = c

		if casi < nsends {
			c.sendq.enqueue(sg)
		} else {
			c.recvq.enqueue(sg)
		}
	}

	gopark(selparkcommit, nil, waitReasonSelect, traceEvGoBlockSelect, 1)
	...
}
```

除了将当前 Goroutine 对应的 [`runtime.sudog`](https://draveness.me/golang/tree/runtime.sudog) 结构体加入队列之外，这些结构体都会被串成链表附着在 Goroutine 上。在入队之后会调用 [`runtime.gopark`](https://draveness.me/golang/tree/runtime.gopark) 挂起当前 Goroutine 等待调度器的唤醒。

![Golang-Select-Waiting](https://img.draveness.me/2020-01-19-15794018429558-Golang-Select-Waiting.png)

**图 5-9 Goroutine 上等待收发的 sudog 链表**

等到 `select` 中的一些 Channel 准备就绪之后，当前 Goroutine 就会被调度器唤醒。这时会继续执行 [`runtime.selectgo`](https://draveness.me/golang/tree/runtime.selectgo) 函数的第三部分，从 [`runtime.sudog`](https://draveness.me/golang/tree/runtime.sudog) 中读取数据：

```go
func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) {
	...
	sg = (*sudog)(gp.param)
	gp.param = nil

	casi = -1
	cas = nil
	sglist = gp.waiting
	for _, casei := range lockorder {
		k = &scases[casei]
		if sg == sglist {
			casi = int(casei)
			cas = k
		} else {
			c = k.c
			if int(casei) < nsends {
				c.sendq.dequeueSudoG(sglist)
			} else {
				c.recvq.dequeueSudoG(sglist)
			}
		}
		sgnext = sglist.waitlink
		sglist.waitlink = nil
		releaseSudog(sglist)
		sglist = sgnext
	}

	c = cas.c
	goto retc
	...
}
```

第三次遍历全部 `case` 时，我们会先获取当前 Goroutine 接收到的参数 `sudog` 结构，我们会依次对比所有 `case` 对应的 `sudog` 结构找到被唤醒的 `case`，获取该 `case` 对应的索引并返回。

由于当前的 `select` 结构找到了一个 `case` 执行，那么剩下 `case` 中没有被用到的 `sudog` 就会被忽略并且释放掉。为了不影响 Channel 的正常使用，我们还是需要将这些废弃的 `sudog` 从 Channel 中出队。

当我们在循环中发现缓冲区中有元素或者缓冲区未满时就会通过 `goto` 关键字跳转到 `bufrecv` 和 `bufsend` 两个代码段，这两段代码的执行过程都很简单，它们只是向 Channel 中发送数据或者从缓冲区中获取新数据：

```go
bufrecv:
	recvOK = true
	qp = chanbuf(c, c.recvx)
	if cas.elem != nil {
		typedmemmove(c.elemtype, cas.elem, qp)
	}
	typedmemclr(c.elemtype, qp)
	c.recvx++
	if c.recvx == c.dataqsiz {
		c.recvx = 0
	}
	c.qcount--
	selunlock(scases, lockorder)
	goto retc

bufsend:
	typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)
	c.sendx++
	if c.sendx == c.dataqsiz {
		c.sendx = 0
	}
	c.qcount++
	selunlock(scases, lockorder)
	goto retc
```

这里在缓冲区进行的操作和直接调用 [`runtime.chansend`](https://draveness.me/golang/tree/runtime.chansend) 和 [`runtime.chanrecv`](https://draveness.me/golang/tree/runtime.chanrecv) 差不多，上述两个过程在执行结束之后都会直接跳到 `retc` 字段。

两个直接收发 Channel 的情况会调用运行时函数 [`runtime.send`](https://draveness.me/golang/tree/runtime.send) 和 [`runtime.recv`](https://draveness.me/golang/tree/runtime.recv)，这两个函数会与处于休眠状态的 Goroutine 打交道：

```go
recv:
	recv(c, sg, cas.elem, func() { selunlock(scases, lockorder) }, 2)
	recvOK = true
	goto retc

send:
	send(c, sg, cas.elem, func() { selunlock(scases, lockorder) }, 2)
	goto retc
```

不过如果向关闭的 Channel 发送数据或者从关闭的 Channel 中接收数据，情况就稍微有一点复杂了：

- 从一个关闭 Channel 中接收数据会直接清除 Channel 中的相关内容；
- 向一个关闭的 Channel 发送数据就会直接 `panic` 造成程序崩溃：

```go
rclose:
	selunlock(scases, lockorder)
	recvOK = false
	if cas.elem != nil {
		typedmemclr(c.elemtype, cas.elem)
	}
	goto retc

sclose:
	selunlock(scases, lockorder)
	panic(plainError("send on closed channel"))
```

总体来看，`select` 语句中的 Channel 收发操作和直接操作 Channel 没有太多出入，只是由于 `select` 多出了 `default` 关键字所以会支持非阻塞的收发。

#### 小结

我们简单总结一下 `select` 结构的执行过程与实现原理，首先在编译期间，Go 语言会对 `select` 语句进行优化，它会根据 `select` 中 `case` 的不同选择不同的优化路径：

空的 select 语句会被转换成调用 runtime.block 直接挂起当前 Goroutine；
如果 select 语句中只包含一个 case，编译器会将其转换成 if ch == nil { block }; n; 表达式；
首先判断操作的 Channel 是不是空的；
然后执行 case 结构中的内容；
如果 select 语句中只包含两个 case 并且其中一个是 default，那么会使用 runtime.selectnbrecv 和 runtime.selectnbsend 非阻塞地执行收发操作；
在默认情况下会通过 runtime.selectgo 获取执行 case 的索引，并通过多个 if 语句执行对应 case 中的代码；

在编译器已经对 `select` 语句进行优化之后，Go 语言会在运行时执行编译期间展开的 [`runtime.selectgo`](https://draveness.me/golang/tree/runtime.selectgo) 函数，该函数会按照以下的流程执行：

1. 随机生成一个遍历的轮询顺序 `pollOrder` 并根据 Channel 地址生成锁定顺序 `lockOrder`；

2. 根据pollOrder遍历所有的case查看是否有可以立刻处理的 Channel；

   1. 如果存在，直接获取 `case` 对应的索引并返回；
   2. 如果不存在，创建 [`runtime.sudog`](https://draveness.me/golang/tree/runtime.sudog) 结构体，将当前 Goroutine 加入到所有相关 Channel 的收发队列，并调用 [`runtime.gopark`](https://draveness.me/golang/tree/runtime.gopark) 挂起当前 Goroutine 等待调度器的唤醒；
   
3. 当调度器唤醒当前 Goroutine 时，会再次按照 `lockOrder` 遍历所有的 `case`，从中查找需要被处理的 [`runtime.sudog`](https://draveness.me/golang/tree/runtime.sudog) 对应的索引；

`select` 关键字是 Go 语言特有的控制结构，它的实现原理比较复杂，需要编译器和运行时函数的通力合作。

### defer

在Go语言中，defer语句会延迟[函数](https://www.nhooo.com/golang/go-functions.html)或方法或[匿名方法](https://www.nhooo.com/golang/go-anonymous-function.html)的执行，直到附近的函数返回为止。换句话说，延迟函数或方法调用参数会立即求值，但是它们会执行到附近的函数返回为止。您可以使用defer关键字创建延迟的方法，函数或匿名函数。

**语法：**

```
// 函数
defer func func_name(parameter_list Type) return_type{
    // Code
}

// 方法
defer func (receiver Type) method_name(parameter_list){
    // Code
}

defer func (parameter_list)(return_type){
    // code
}()
```

**注意事项：**

- 在Go语言中，同一程序中允**许多个defer语句，并且它们按LIFO（后进先出）顺序执行**
- 在defer语句中，**将在执行defer语句时（而不是在调用它们时）评估参数**。
- defer语句通常用于确保在完成文件处理后关闭文件，关闭通道或捕获程序中的紧急情况。

#### 特性

[参考](https://blog.csdn.net/lanyang123456/article/details/93406791?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-93406791-blog-120675020.pc_relevant_multi_platform_whitelistv6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-93406791-blog-120675020.pc_relevant_multi_platform_whitelistv6&utm_relevant_index=4)

defer以下几个特性，使用时需要关注下。

- 即时的参数传递
- 调用`os.Exit()`时defer不会被执行
- defer与return的先后顺序

##### 定义defer时传入的参数，是作为拷贝传递的。

也就是说，**如果原来的变量值发生变化，不会影响传给defer的参数**。

例子如下：

```go
package main

import (
  "fmt"
)

func main(){
   test()
}

func test() {
    a := 0

    defer func (i int) {
        fmt.Println("in defer i:", i)
    }(a)

    a += 1
    fmt.Println("a:", a)
}
```

输出结果：

```
a: 1
in defer i: 0
12
```

可以看到，即使变量a发生变化，延迟执行时变量的值仍然是0，与定义defer时传入的值一样。

另外，注意下，defer 函数中引用外部定义的变量时，是按引用传递的，例如：

```go
package main

import (
        "fmt"
)

func main(){
    test()
}

func test(){
    a := 0
    b := 0
    
    defer fmt.Println("a:", a)
    defer func(){
        fmt.Println("b:", b)
    }()
    
    a += 1
    b += 1
}
```

output:

> b: 1

> a: 0

其中，a是直接作为函数参数传递的，所以是当时的值0。

而b是 在defer重新定义的函数中使用的，是引用传递的，所以值是1.

##### 调用`os.Exit()`时defer不会被执行

当发生panic时，defer会被执行，但是当调用os.Exit()方法退出程序时，defer并不会被执行。

```
package main

import (
        "fmt"
        "os"
)

func main(){
        fmt.Println("main start")
        test()
}

func test() () {
        defer func () {
                fmt.Println("in defer ... ")
        }()

        os.Exit(0)
}
```

```
输出结果：

main start
```

defer定义的内容没有输出。

##### defer 与 return先后顺序

先执行 return 再执行 defer

#### defer 注意点

[参考](https://segmentfault.com/a/1190000022112411)

##### 有名函数返回值遇见defer情况

该知识点不属于defer本身，但是调用的场景却与defer有联系，所以也算是defer必备了解的知识点之一。

如 ： `func DeferFunc1(i int) (t int) {}`

其中返回值`t int`，这个`t`会在函数起始处被初始化为对应类型的零值并且作用域为整个函数。

![img](https://segmentfault.com/img/remote/1460000022112417)

> 示例代码

```go
package main

import "fmt"

func DeferFunc(i int) (t int) {

    fmt.Println("t = ", t)

    return 2
}

func main() {
    DeferFunc(10)
}
```

结果

```bash
t =  0
```

证明，**只要声明函数的返回值变量名称，就会在函数初始化时候为之赋值为0，而且在函数体作用域可见**。

在没有defer的情况下，其实函数的返回就是与return一致的，但是有了defer就不一样了。

先return，再defer，所以在执行完return之后，还要再执行defer里的语句，依然可以修改本应该返回的结果。

```go
package main

import "fmt"

func returnButDefer() (t int) {  //t初始化0， 并且作用域为该函数全域

    defer func() {
        t = t * 10
    }()

    return 1
}

func main() {
    fmt.Println(returnButDefer())
}
```

 该`returnButDefer()`本应的返回值是`1`，但是在return之后，又被defer的匿名func函数执行，所以`t=t*10`被执行，最后`returnButDefer()`返回给上层`main()`的结果为`10`

```bash
$ go run test.go
10
```

若是在之前传入

```
package main

import "fmt"

func returnButDefer() (t int) {  //t初始化0， 并且作用域为该函数全域

    defer func(t int) {
        t = t * 10
    }(t)

    return 1
}

func main() {
    fmt.Println(returnButDefer())
}
```

这种情路下并未修改返回值

##### 发生panic未被捕获

##### defer遇见panic，但是并不捕获异常的情况

> test10.go

```go
package main

import (
    "fmt"
)

func main() {
    defer_call()

    fmt.Println("main 正常结束")
}

func defer_call() {
    defer func() { fmt.Println("defer: panic 之前1") }()
    defer func() { fmt.Println("defer: panic 之前2") }()

    panic("异常内容")  //触发defer出栈

    defer func() { fmt.Println("defer: panic 之后，永远执行不到") }()
}
```

**结果**

```bash
defer: panic 之前2
defer: panic 之前1
panic: 异常内容
//... 异常堆栈信息
```

即发生的panic在定义defer之前。若不捕获处理异常，上层函数也是通过panic退出。

如何正确捕获

```
package main

import (
    "fmt"
)

func main() {
    defer_call()

    fmt.Println("main 正常结束")
}

func defer_call() {

    defer func() {
        fmt.Println("defer: panic 之前1, 捕获异常")
        if err := recover(); err != nil {
            fmt.Println(err)
        }
    }()

    defer func() { fmt.Println("defer: panic 之前2, 不捕获") }()

    panic("异常内容")  //触发defer出栈

    defer func() { fmt.Println("defer: panic 之后, 永远执行不到") }()
}
```

**结果**

```go
defer: panic 之前2, 不捕获
defer: panic 之前1, 捕获异常
异常内容
main 正常结束
```

通过`recover` 函数捕获，上层函数正常退出。

##### defer中包含panic

> 编译执行下面代码会出现什么?
>
> test16.go

```go
package main

import (
    "fmt"
)

func main()  {

    defer func() {
       if err := recover(); err != nil{
           fmt.Println(err)
       }else {
           fmt.Println("fatal")
       }
    }()

    defer func() {
        panic("defer panic")
    }()

    panic("panic")
}
```

**结果**

```bash
defer panic
```

**分析**

**panic仅有最后一个可以被revover捕获**。

触发`panic("panic")`后defer顺序出栈执行，第一个被执行的defer中 会有`panic("defer panic")`异常语句，这个异常将会覆盖掉main中的异常`panic("panic")`，最后这个异常被第二个执行的defer捕获到。

##### defer下的函数参数包含子函数

```go
package main

import "fmt"

func function(index int, value int) int {

    fmt.Println(index)

    return index
}

func main() {
    defer function(1, function(3, 0))
    defer function(2, function(4, 0))
}
```

 这里，有4个函数，他们的index序号分别为1，2，3，4。

那么这4个函数的先后执行顺序是什么呢？这里面有两个defer， 所以defer一共会压栈两次，先进栈1，后进栈2。 那么在压栈function1的时候，需要连同函数地址、函数形参一同进栈，那么为了得到function1的第二个参数的结果，所以就需要先执行function3将第二个参数算出，那么function3就被第一个执行。同理压栈function2，就需要执行function4算出function2第二个参数的值。然后函数结束，先出栈fuction2、再出栈function1.

 所以顺序如下：

- defer压栈function1，压栈函数地址、形参1、形参2(调用function3) --> 打印3
- defer压栈function2，压栈函数地址、形参1、形参2(调用function4) --> 打印4
- defer出栈function2, 调用function2 --> 打印2
- defer出栈function1, 调用function1--> 打印1

```bash
3
4
2
1
```

### import和package

[参考](https://learnku.com/go/t/32464)

#### package

`golang` 使用包 `package` 来**管理定义模块**，包是结构化代码的一种方式：**每个程序都由包（通常简称为 pkg）的概念组成**，可以使用 `import` 关键字来导入使用。

- 如果导入的是 `go` 自带的包，则会去安装目录 `$GOROOT/src` 按包路径加载，如 `fmt` 包
- 如果是我们 `go get` 安装或自定义的包，则会去 `$GOPATH/src` 下加载

如同其它一些编程语言中的类库或命名空间的概念，**每个 Go 文件都属于且仅属于一个包**。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。

你必须在源文件中**非注释的第一行**指明这个文件属于哪个包，如：package main 。

**package main 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。package main 包下可以有多个文件，但所有文件中只能有一个 main () 方法，main () 方法代表程序入口**。

一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。如果你打算编译包名不是为 main 的源文件，如 pack1，编译后产生的对象文件将会是 pack1.a 而不是可执行程序。另外要注意的是，所有的包名都应该使用小写字母。当然，main 包是不能在其他文档 import 的，编译器会报错：

```
import "xx/xx" is a program, not an importable package。
```

简单地说，在含有 mian 包的目录下，你可以写多个文件，每个文件非注释的第一行都使用 package main 来指明这些文件都属于这个应用的 main 包，只有一个文件能有 mian () 方法，也就是应用程序的入口。main 包不是必须的，只有在可执行的应用程序中需要。

#### 包的导入

一个 Go 程序是通过 import 关键字将一组包链接在一起。

import “fmt” 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入 / 输出）的函数。包名被封闭在半角双引号 “” 中。如果你打算从已编译的包中导入并加载公开声明的方法，不需要插入已编译包的源代码。

**import 其实是导入目录**，而不是定义的 package 名字，虽然我们一般都会保持一致，但其实是可以随便定义目录名，只是使用时会很容易混乱，不建议这么做。

例如：package big ，我们 import “math/big” ，其实是在 src 中的 src/math 目录。在代码中使用 big.Int 时，big 指的才是 Go 文件中定义的 package 名字。

当你导入多个包时，最好按照字母顺序排列包名，这样做更加清晰易读。

如果包名不是以 ./ ，如 “fmt” 或者 “container/list”，则 Go 会在全局文件进行查找；如果包名以 ./ 开头，则 Go 会在相对目录中查找。

导入包即等同于包含了这个包的所有的代码对象。

除了符号 _，包中所有代码对象的标识符必须是唯一的，以避免名称冲突。但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们。

导入包的路径的几种情况：

第一种方式相对路径

`import   "./module"   //当前文件同一目录的module目录， 此方式没什么用容易出错，不建议用`

第二种方式绝对路径

import  "LearnGo/init"  //加载Gopath/src/LearnGo/init模块，一般建议这样使用""

导入多个包的常见的方式是：

```
import  (
    "fmt"
    "net/http"
 )
```



module
