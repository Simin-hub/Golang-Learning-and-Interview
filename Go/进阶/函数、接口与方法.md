# 函数、接口与方法

[参考地址](https://www.bookstack.cn/read/advanced-go-programming-book/ch1-basic-ch1-04-func-method-interface.md)

Go语言中的函数有**具名和匿名**之分：**具名函数一般对应于包级的函数**，是匿名函数的一种特例，当**匿名函数引用了外部作用域中的变量时就成了闭包函数**，闭包函数是函数式编程语言的核心。**方法是绑定到一个具体类型的特殊函数，Go语言中的方法是依托于类型的，必须在编译时静态绑定**。**接口定义了方法的集合，这些方法依托于运行时的接口对象，因此接口对应的方法是在运行时动态绑定的。**Go语言通过隐式接口机制实现了鸭子面向对象模型。

Go语言程序的**初始化和执行总是从`main.main`函数开始的**。但是如果`main`包导入了其它的包，则会按照顺序将它们包含进`main`包里（这里的**导入顺序依赖具体实现，一般可能是以文件名或包路径名的字符串顺序导入**）。如果某个包被**多次导入的话，在执行的时候只会导入一次**。**当一个包被导入时，如果它还导入了其它的包，则先将其它的包包含进来**，然后创建和初始化这个包的常量和变量,再调用包里的`init`函数，如果一个**包有多个`init`函数的话，调用顺序未定义(实现可能是以文件名的顺序调用)**，同一个**文件内的多个`init`则是以出现的顺序依次调用**（`init`不是普通函数，可以定义有多个，所以也不能被其它函数调用）。最后，当`main`包的所有包级常量、变量被创建和初始化完成，并且`init`函数被执行后，才会进入`main.main`函数，程序开始正常执行。下图是Go程序函数启动顺序的示意图：

![1.4 函数、方法和接口 - 图1](https://static.sitestack.cn/projects/advanced-go-programming-book/images/ch1-11-init.ditaa.png)

要注意的是，**在`main.main`函数执行之前所有代码都运行在同一个goroutine**（可查看[goroutine调度](https://github.com/Simin-hub/Golang-Learning-and-Interview/blob/main/Go/%E8%BF%9B%E9%98%B6/goroutine.md#goroutine-%E8%B0%83%E5%BA%A6%E5%99%A8)），也就是程序的主系统线程中。因此，如果某个`init`函数内部用go关键字启动了新的goroutine的话，新的goroutine只有在进入`main.main`函数之后才可能被执行到。

## 函数

[先看基础部分](https://github.com/Simin-hub/Golang-Learning-and-Interview/blob/main/Go/%E5%9F%BA%E7%A1%80/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.md#%E4%B8%89%E5%87%BD%E6%95%B0)

在Go语言中，函数是第一类对象，我们可以将函数保持到变量中。函数主要有具名和匿名之分，包级函数一般都是具名函数，具名函数是匿名函数的一种特例。当然，Go语言中每个类型还可以有自己的方法，方法其实也是函数的一种。

### 基本用法

```
// 具名函数
func Add(a, b int) int {    
	return a+b
}
// 匿名函数
var Add = func(a, b int) int {    
	return a+b
}
// 闭包函数
func(a, b int) int {    
	return a+b
}(a, b)
```

Go语言中的函数可以有多个参数和多个返回值，参数和返回值都是以传值的方式和被调用者交换数据。在语法上，函数还支持可变数量的参数，可变数量的参数必须是最后出现的参数，**可变数量的参数其实是一个切片类型的参数**。

```
// 多个参数和多个返回值
func Swap(a, b int) (int, int) {
    return b, a
}
// 可变数量的参数
// more 对应 []int 切片类型
func Sum(a int, more ...int) int {
    for _, v := range more {
        a += v
    }
    return a
}
```

当可变参数是一个空接口类型时，调用者是否解包可变参数会导致不同的结果：

```
func main() {
    var a = []interface{}{123, "abc"}
    Print(a...) // 123 abc
    Print(a)    // [123 abc]
}
func Print(a ...interface{}) {
    fmt.Println(a...)
}
```

第一个`Print`调用时传入的参数是`a...`，等价于直接调用`Print(123, "abc")`。第二个`Print`调用传入的是未解包的`a`，等价于直接调用`Print([]interface{}{123, "abc"})`。

### 参数值传递

[参考地址](89N3PDyZzakoH7W6n8ZrjGDDktjh8iWFG6eKRvi3kvpQ)

#### **slice**

[底层](https://github.com/Simin-hub/Golang-Learning-and-Interview/blob/main/Go/%E8%BF%9B%E9%98%B6/array%E3%80%81slice%E3%80%81map%E3%80%81channel.md#slice)

`slice`底层结构：

```go
//runtime/slice.go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```

`slice`是一个结构体，他的第一个元素是一个指针类型，这个指针指向的是底层数组的第一个元素。所以当是`slice`类型的时候，`fmt.Printf`返回是`slice`这个结构体里第一个元素的地址。说到底，又转变成了指针处理，只不过这个指针是`slice`中第一个元素的内存地址。之所以对于引用类型的传递可以修改原内容的数据，这是因为在底层默认使用该引用类型的指针进行传递，但也是使用指针的副本，依旧是值传递。所以**`slice`传递的就是第一个元素的指针的副本**，因为`fmt.printf`缘故造成了打印的地址一样，给人一种混淆的感觉。

#### **map**

在这里，Go语言通过`make`函数，字面量的包装，为我们省去了指针的操作，让我们可以更容易的使用map。这里的`map`可以理解为引用类型，但是记住引用类型不是传引用。

#### **chan**



**go就是值传递，可以确认的是Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。**

**是否可以修改原内容数据，和传值、传引用没有必然的关系。在C++中，传引用肯定是可以修改原内容数据的，在Go语言里，虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型。**





结构体内包含匿名字段

假如外部struct中的字段名和内部struct的字段名相同，会如何？

有以下两个名称冲突的规则：

1. 外部struct覆盖内部struct的同名字段、同名方法
2. 同级别的struct出现同名字段、方法将报错

第一个规则使得Go struct能够实现面向对象中的重写(override)，而且可以重写字段、重写方法。

第二个规则使得同名属性不会出现歧义。