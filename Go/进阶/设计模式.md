# Go 语言设计模式

[Go 语言设计模式](https://www.topgoer.cn/docs/golang-design-pattern)

[参考](https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html)

[参考2](https://refactoringguru.cn/design-patterns/factory-method)

## go 实现接口与继承

### 实现接口

在 Golang 中，接口是一组方法签名。当类型为接口中的所有方法提供定义时，它被称为实现接口。它与 OOP(面向对象编程) 非常相似。接口指定了类型应该具有的方法，类型决定了如何实现这些方法。

如果**某个对象实现了某个接口的所有方法，则此对象就实现了该接口**。

**接口嵌套**

顾名思义，接口嵌套就是一个接口中包含了其他接口，如果**要实现外部接口，那么就要把内部嵌套的接口对应的所有方法全实现了**。

### 组合与继承

学习golang的过程中，有一个比较关注的价值观，**golang提倡组合，不提倡继承**。看过一些书和资料，感觉对这个概念的解释都不是很满意，特总结这篇文章，大家指正。

先说说组合与继承的概念。对设计模式有过了解的同学对这两个名词应该都有初步的理解，我们来总结一下：官方解释就不说了，组合一般理解为 has-a 的关系，继承是is-a的关系。以java为例，组合可以理解为类里边添加的属性（一般是接口类型），继承是extends。
这里我引用一篇文章的段落[浅谈组合与继承](https://www.jianshu.com/p/23aeced9cf81)

```
继承的优缺点
优点：
1，类继承简单粗爆，直观，关系在编译时静态定义。
2，被复用的实现易于修改，sub可以覆盖super的实现。
缺点：
1，无法在运行时变更从super继承来的实现（也不一定是缺点）
2，sub的部分实现通常定义在super中。
3，sub直接面对super的实现细节，因此破坏了封装。
4，super实现的任何变更都会强制子类也进行变更，因为它们的实现联系在了一起。
5，如果在新的问题场景下继承来的实现已过时或不适用，所以必须重写super或继承来的实现。
由于在类继承中，实现的依存关系，对子类进行复用可能会有问题。有一个解决办法是，只从协议或抽象基类继承(子类型化)，国为它们只对很少的实现，而协议则没有实现。

组合的优缺点
对象组合让我们同时使用多个对象，而每个对象都假定其他对象的接口正常运行。因此，为了在系统中正常运行，它们的接口都需要经过精心的设计。下面我就来说说他的优缺点
优点：
1，不会破坏封装，因为只通过接口来访问对象；
2，减少实现的依存关系，因为实面是通过接口来定义的；
3，可以在运行时将任意对象替换为其他同类型的对象；
4，可以保持类的封装以专注于单一任务；
5，类和他的层次结构能保持简洁，不至于过度膨胀而无法管理；
缺点：
1，涉及对象多；
2，系统的行为将依赖于不同对象间的关系，而不是定义于单个类中；
3，现成的组件总是不太够用，从而导致我们要不停的定义新对象。
```

总结来看，我认为，组合相对于继承的优点在于

1. 可以利用面向接口编程原则的一系列优点，封装性好，耦合性低
2. 相对于继承的编译期确定实现，组合的运行态指定实现，更加灵活



匿名和组合的区别

- 如果一个struct**嵌套了另一个匿名结构体**，那么这个结构**可以直接访问匿名结构体的方法，从而实现继承**
- 如果一个struct**嵌套了另一个【有名】的结构体**，那么这个模式叫做**组合**
- 如果一个struct嵌套了**多个匿名结构体**，那么这个结构可以直接访问多个匿名结构体的方法，从而实现**多重继承**

### 代码演示

网上很少有例子解释清楚golang所提倡的组合的优势，一般就是将一个struct嵌入到另外一个struct里。

```
package main

import (
    "fmt"
)

type A struct {
}

func (*A) Hello(name string) {
    fmt.Println("hello " + name + ", i am a")
}

type B struct {
    *A
}

func main() {
    name := "Lee"
    a := A{}
    a.Hello(name) //hello Lee, i am a

    b := B{&A{}}
    b.Hello(name) //hello Lee, i am a

}
```

如上文所述，我认为组合需要与接口结合使用才能体现其精髓。

让我们来看一段改造后的代码：

```
package main

import (
    "fmt"
)

type IHello interface {
    Hello(name string)
}

type A struct {
}

func (*A) Hello(name string) {
    fmt.Println("hello " + name + ", i am a")
}

type D struct {
}

func (*D) Hello(name string) {
    fmt.Println("hello " + name + ", i am d")
}

type B struct {
    *A
}

type C struct {
    IHello
}

func main() {
    name := "Lee"
    a := A{}
    a.Hello(name) //hello Lee, i am a

    b := B{&A{}}
    b.Hello(name) //hello Lee, i am a

    c := C{&A{}}
    c.Hello(name) //hello Lee, i am a

    c = C{&D{}}
    c.Hello(name) //hello Lee, i am d
}
```

发现不同了吗？

A的指针继承了接口IHello, B中嵌入了具体实现类A，C中嵌入了接口IHello,

B C两者在赋值时，均可嵌入A的指针实例，但是C可以根据运行时上下文指定具体实现，更加灵活。

所以让我们面向接口编程，提倡共用组合与接口的优雅代码

## 一、创建型模式

### 简单工厂模式

go 语言没有构造函数一说，所以一般会定义NewXXX函数来初始化相关类。
NewXXX 函数返回接口时就是简单工厂模式，也就是说Golang的一般推荐做法就是简单工厂。

在这个simplefactory包中只有API 接口和NewAPI函数为包外可见，封装了实现细节。

#### simple.go代码

```go
package simplefactory

import "fmt"

//API is interface
type API interface {
    Say(name string) string
}

//NewAPI return Api instance by type
func NewAPI(t int) API {
    if t == 1 {
        return &hiAPI{}
    } else if t == 2 {
        return &helloAPI{}
    }
    return nil
}

//hiAPI is one of API implement
type hiAPI struct{}

//Say hi to name
func (*hiAPI) Say(name string) string {
    return fmt.Sprintf("Hi, %s", name)
}

//HelloAPI is another API implement
type helloAPI struct{}

//Say hello to name
func (*helloAPI) Say(name string) string {
    return fmt.Sprintf("Hello, %s", name)
}
```

#### simple_test.go代码

```go
package simplefactory

import "testing"

//TestType1 test get hiapi with factory
func TestType1(t *testing.T) {
    api := NewAPI(1)
    s := api.Say("Tom")
    if s != "Hi, Tom" {
        t.Fatal("Type1 test fail")
    }
}

func TestType2(t *testing.T) {
    api := NewAPI(2)
    s := api.Say("Tom")
    if s != "Hello, Tom" {
        t.Fatal("Type2 test fail")
    }
}
```

### 工厂方法模式

**工厂方法模式使用子类的方式延迟生成对象到子类中实现。**

Go中不存在继承 所以**使用匿名组合来实现**

#### factorymethod.go

```go
package factorymethod

//Operator 是被封装的实际类接口
type Operator interface {
    SetA(int)
    SetB(int)
    Result() int
}

//OperatorFactory 是工厂接口
type OperatorFactory interface {
    Create() Operator
}

//OperatorBase 是Operator 接口实现的基类，封装公用方法
type OperatorBase struct {
    a, b int
}

//SetA 设置 A
func (o *OperatorBase) SetA(a int) {
    o.a = a
}

//SetB 设置 B
func (o *OperatorBase) SetB(b int) {
    o.b = b
}

//PlusOperatorFactory 是 PlusOperator 的工厂类
type PlusOperatorFactory struct{}

func (PlusOperatorFactory) Create() Operator {
    return &PlusOperator{
        OperatorBase: &OperatorBase{},
    }
}

//PlusOperator Operator 的实际加法实现
type PlusOperator struct {
    *OperatorBase
}

//Result 获取结果
func (o PlusOperator) Result() int {
    return o.a + o.b
}

//MinusOperatorFactory 是 MinusOperator 的工厂类
type MinusOperatorFactory struct{}

func (MinusOperatorFactory) Create() Operator {
    return &MinusOperator{
        OperatorBase: &OperatorBase{},
    }
}

//MinusOperator Operator 的实际减法实现
type MinusOperator struct {
    *OperatorBase
}

//Result 获取结果
func (o MinusOperator) Result() int {
    return o.a - o.b
}
```

#### factorymethod_test.go

```go
package factorymethod

import "testing"

func compute(factory OperatorFactory, a, b int) int {
    op := factory.Create()
    op.SetA(a)
    op.SetB(b)
    return op.Result()
}

func TestOperator(t *testing.T) {
    var (
        factory OperatorFactory
    )

    factory = PlusOperatorFactory{}
    if compute(factory, 1, 2) != 3 {
        t.Fatal("error with factory method pattern")
    }

    factory = MinusOperatorFactory{}
    if compute(factory, 4, 2) != 2 {
        t.Fatal("error with factory method pattern")
    }
}
```

### 抽象工厂模式

抽象工厂模式用于生成产品族的工厂，所生成的对象是有关联的。

如果抽象工厂退化成生成的对象无关联则成为工厂函数模式。

比如本例子中使用RDB和XML存储订单信息，抽象工厂分别能生成相关的主订单信息和订单详情信息。

如果业务逻辑中需要替换使用的时候只需要改动工厂函数相关的类就能替换使用不同的存储方式了。

#### abstractfactory.go

```go
package abstractfactory

import "fmt"

//OrderMainDAO 为订单主记录
type OrderMainDAO interface {
    SaveOrderMain()
}

//OrderDetailDAO 为订单详情纪录
type OrderDetailDAO interface {
    SaveOrderDetail()
}

//DAOFactory DAO 抽象模式工厂接口
type DAOFactory interface {
    CreateOrderMainDAO() OrderMainDAO
    CreateOrderDetailDAO() OrderDetailDAO
}

//RDBMainDAP 为关系型数据库的OrderMainDAO实现
type RDBMainDAO struct{}

//SaveOrderMain ...
func (*RDBMainDAO) SaveOrderMain() {
    fmt.Print("rdb main save\n")
}

//RDBDetailDAO 为关系型数据库的OrderDetailDAO实现
type RDBDetailDAO struct{}

// SaveOrderDetail ...
func (*RDBDetailDAO) SaveOrderDetail() {
    fmt.Print("rdb detail save\n")
}

//RDBDAOFactory 是RDB 抽象工厂实现
type RDBDAOFactory struct{}

func (*RDBDAOFactory) CreateOrderMainDAO() OrderMainDAO {
    return &RDBMainDAO{}
}

func (*RDBDAOFactory) CreateOrderDetailDAO() OrderDetailDAO {
    return &RDBDetailDAO{}
}

//XMLMainDAO XML存储
type XMLMainDAO struct{}

//SaveOrderMain ...
func (*XMLMainDAO) SaveOrderMain() {
    fmt.Print("xml main save\n")
}

//XMLDetailDAO XML存储
type XMLDetailDAO struct{}

// SaveOrderDetail ...
func (*XMLDetailDAO) SaveOrderDetail() {
    fmt.Print("xml detail save")
}

//XMLDAOFactory 是RDB 抽象工厂实现
type XMLDAOFactory struct{}

func (*XMLDAOFactory) CreateOrderMainDAO() OrderMainDAO {
    return &XMLMainDAO{}
}

func (*XMLDAOFactory) CreateOrderDetailDAO() OrderDetailDAO {
    return &XMLDetailDAO{}
}
```

#### abstractfactory_test.go

```go
package abstractfactory

func getMainAndDetail(factory DAOFactory) {
    factory.CreateOrderMainDAO().SaveOrderMain()
    factory.CreateOrderDetailDAO().SaveOrderDetail()
}

func ExampleRdbFactory() {
    var factory DAOFactory
    factory = &RDBDAOFactory{}
    getMainAndDetail(factory)
    // Output:
    // rdb main save
    // rdb detail save
}

func ExampleXmlFactory() {
    var factory DAOFactory
    factory = &XMLDAOFactory{}
    getMainAndDetail(factory)
    // Output:
    // xml main save
    // xml detail save
}
```

![../_images/AbatractFactory.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg)

### 创建者（建造者）模式

