# 微服务

[参考](https://docshome.gitbook.io/microservices/5-event-driven-data-management-for-microservices)

## 微服务介绍与对比

[参考](https://cloud.tencent.com/developer/news/841137)

### 一、微服务架构介绍

微服务架构（Microservice Architecture）是一种架构概念，旨在**通过将功能分解到各个离散的服务中以实现对解决方案的解耦**。你可以将其看作是在架构层次而非获取服务的

类上应用很多SOLID原则。微服务架构是个很有趣的概念，它的主要作用是将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。

**概念：** **把一个大型的单个应用程序和服务拆分为数个甚至数十个的支持微服务**，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。

**定义：** 围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。

**本质：** 用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题。

### 二、出现和发展

微服务（Microservice）这个概念是2012年出现的，作为加快Web和移动应用程序开发进程的一种方法，2014年开始受到各方的关注，而2015年，可以说是微服务的元年；

越来越多的论坛、社区、blog以及互联网行业巨头开始对微服务进行讨论、实践，可以说这样更近一步推动了微服务的发展和创新。而微服务的流行，Martin Fowler功不可没。

这老头是个奇人，特别擅长抽象归纳和制造概念。特别是微服务这种新生的名词，都有一个特点： **一解释就懂，一问就不知，一讨论就打架。**

Martin Fowler是国际著名的OO专家，敏捷开发方法的创始人之一，现为ThoughtWorks公司的首席科学家。在面向对象分析设计、UML、模式、软件开发方法学、XP、重构等方面，都是世界顶级的专家，现为Thought Works公司的首席科学家。Thought Works是一家从事企业应用开发和——集成的公司。早在20世纪80年代，Fowler就是使用对象技术构建多层企业应用的倡导者，他著有几本经典书籍：《企业应用架构模式》、《UML精粹》和《重构》等。             ———— 百度百科

### 三、传统开发模式和微服务的区别

先来看看传统的web开发方式，通过对比比较容易理解什么是Microservice Architecture。和Microservice相对应的，这种方式一般被称为Monolithic（单体式开发）。

所有的功能打包在一个 WAR包里，基本没有外部依赖（除了容器），部署在一个JEE容器（Tomcat，JBoss，WebLogic）里，包含了 DO/DAO，Service，UI等所有逻辑。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/45724306feb60738be0651ea0cbe687b.jpeg)

#### 优点：

①开发简单，集中式管理

②基本不会重复开发

③功能都在本地，没有分布式的管理和调用消耗

#### 缺点：

1、效率低：开发都在同一个项目改代码，相互等待，冲突不断

2、维护难：代码功功能耦合在一起，新人不知道何从下手

3、不灵活：构建时间长，任何小修改都要重构整个项目，耗时

4、稳定性差：一个微小的问题，都可能导致整个应用挂掉

5、扩展性不够：无法满足高并发下的业务需求

#### 常见的系统架构遵循的三个标准和业务驱动力：

1、提高敏捷性：及时响应业务需求，促进企业发展

2、提升用户体验：提升用户体验，减少用户流失

3、降低成本：降低增加产品、客户或业务方案的成本

#### 基于微服务架构的设计：

目的：有效的拆分应用，实现敏捷开发和部署

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/a90236331c91595d147338f11fa99efb.jpeg)

关于微服务的一个形象表达：

![img](https://ask.qcloudimg.com/http-save/yehe-14352312/552fe371f1b60e4d313157e99cd43961.jpeg)

X轴：运行多个负载均衡器之后的运行实例

Y轴：将应用进一步分解为微服务（分库）

Z轴：大数据量时，将服务分区（分表）

### 四、微服务的具体特征

#### 官方的定义：

1、一些列的独立的服务共同组成系统

2、单独部署，跑在自己的进程中

3、每个服务为独立的业务开发

4、分布式管理

5、非常强调隔离性

#### 大概的标准：

1、分布式服务组成的系统

2、按照业务，而不是技术来划分组织

3、做有生命的产品而不是项目

4、强服务个体和弱通信（ Smart endpoints and dumb pipes ）

5、自动化运维（ DevOps ）

6、高度容错性

7、快速演化和迭代

### 五、SOA和微服务的区别

#### 1、SOA喜欢重用，微服务喜欢重写

**SOA** 的主要目的是为了企业各个系统更加容易地融合在一起。说到SOA不得不说ESB(EnterpriseService Bus)。ESB是什么? 可以把ESB想象成一个连接所有企业级服务的脚手架。通过service broker，它可以把不同数据格式或模型转成canonical格式，把XML的输入转成CSV传给legacy服务，把SOAP 1.1服务转成 SOAP 1.2等等。它还可以把一个服务路由到另一个服务上，也可以集中化管理业务逻辑，规则和验证等等。它还有一个重要功能是消息队列和事件驱动的消息传递，比如把JMS服务转化成SOAP协议。各服务间可能有复杂的依赖关系。

**微服务** 通常由重写一个模块开始。要把整个巨石型的应用重写是有很大的风险的，也不一定必要。我们向微服务迁移的时候通常从耦合度最低的模块或对扩展性要求最高的模块开始，把它们一个一个剥离出来用敏捷地重写，可以尝试最新的技术和语言和框架，然 后单独布署。它通常不依赖其他服务。微服务中常用的API Gateway的模式主要目的也不是重用代码，而是减少客户端和服务间的往来。API gateway模式不等同与Facade模式，我们可以使用如future之类的调用，甚至返回不完整数据。

#### 2、SOA喜欢水平服务，微服务喜欢垂直服务

SOA设计喜欢给服务分层(如Service Layers模式)。我们常常见到一个Entity服务层的设计，美其名曰Data Access Layer。这种设计要求所有的服务都通过这个Entity服务层来获取数据。这种设计非常不灵活，比如每次数据层的改动都可能影响到所有业务层的服务。而每个微服务通常有它自己独立的data store。我们在拆分数据库时可以适当的做些去范式化(denormalization)，让它不需要依赖其他服务的数据。

微服务通常是直接面对用户的，每个微服务通常直接为用户提供某个功能。类似的功能可能针对手机有一个服务，针对机顶盒是另外一个服务。在SOA设计模式中这种情况通常会用到Multi-ChannelEndpoint的模式返回一个大而全的结果兼顾到所有的客户端的需求。

#### 3、SOA喜欢自上而下，微服务喜欢自下而上

SOA架构在设计开始时会先定义好服务合同(service contract)。它喜欢集中管理所有的服务，包括集中管理业务逻辑，数据，流程，schema，等等。它使用Enterprise Inventory和Service Composition等方法来集中管理服务。SOA架构通常会预先把每个模块服务接口都定义好。模块系统间的通讯必须遵守这些接口，各服务是针对他们的调用者。

SOA架构适用于TOGAF之类的架构方法论。

微服务则敏捷得多。只要用户用得到，就先把这个服务挖出来。然后针对性的，快速确认业务需求，快速开发迭代。

### 六、怎么具体实践微服务

**要实际的应用微服务，需要解决一下四点问题：**

**1、客户端如何访问这些服务**

**2、每个服务之间如何通信**

**3、如此多的服务，如何实现？**

**4、服务挂了，如何解决？（备份方案，应急处理机制）**

#### 1、客户端如何访问这些服务

原来的Monolithic方式开发，所有的服务都是本地的，UI可以直接调用，现在按功能拆分成独立的服务，跑在独立的一般都在独立的虚拟机上的 Java进程了。客户端UI如何访问他的？

后台有N个服务，前台就需要记住管理N个服务，一个服务下线/更新/升级，前台就要重新部署，这明显不服务我们 拆分的理念，特别当前台是移动应用的时候，通常业务变化的节奏更快。

另外，N个小服务的调用也是一个不小的网络开销。还有一般微服务在系统内部，通常是无 状态的，用户登录信息和权限管理最好有一个统一的地方维护管理（OAuth）。

所以，**一般在后台N个服务和UI之间一般会一个代理或者叫API Gateway**，他的作用包括：

**① 提供统一服务入口，让微服务对前台透明**

**② 聚合后台的服务，节省流量，提升性能**

**③ 提供安全，过滤，流控等API管理功能**

其实这个API Gateway可以有很多广义的实现办法，可以是一个软硬一体的盒子，也可以是一个简单的MVC框架，甚至是一个Node.js的服务端。他们最重要的作用是为前台（通常是移动应用）提供后台服务的聚合，提供一个统一的服务出口，解除他们之间的耦合，不过API Gateway也有可能成为单点故障点或者性能的瓶颈。

用过Taobao Open Platform（淘宝开放平台）的就能很容易的体会，TAO就是这个API Gateway。

![img](https://ask.qcloudimg.com/http-save/yehe-14352312/2ed098d734523a18f622bd40ef0eb276.jpeg)

#### 2、每个服务之间如何通信

所有的微服务都是独立的Java进程跑在独立的虚拟机上，所以服务间的通信就是IPC（inter process communication），已经有很多成熟的方案。现在基本最通用的有两种方式：

同步调用：

①REST

②RPC



异步消息调用(Kafka, Notify, MetaQ)

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/8684a62378cb9fbe400e7b24db189a40.jpeg)

#### 同步和异步的区别：

一般同步调用比较简单，一致性强，但是容易出调用问题，性能体验上也会差些，特别是调用层次多的时候。RESTful和RPC的比较也是一个很有意思的话题。

一般REST基于HTTP，更容易实现，更容易被接受，服务端实现技术也更灵活些，各个语言都能支持，同时能跨客户端，对客户端没有特殊的要求，只要封装了HTTP的SDK就能调用，所以相对使用的广一些。**RPC也有自己的优点，传输协议更高效，安全更可控**，特别在一个公司内部，如果有统一个 的开发规范和统一的服务框架时，他的开发效率优势更明显些。就看各自的技术积累实际条件，自己的选择了。



而**异步消息的方式在分布式系统中有特别广泛的应用，他既能减低调用服务之间的耦合，又能成为调用之间的缓冲，确保消息积压不会冲垮被调用方，同时能保证调用方的服务体验，继续干自己该干的活，不至于被后台性能拖慢**。不过需要付出的代价是一致性的减弱，需要接受数据最终一致性；还有就是后台服务一般要实现幂等性，因为消息发送出于性能的考虑一般会有重复（保证消息的被收到且仅收到一次对性能是很大的考验）；最后就是必须引入一个独立的broker，如果公司内部没有技术积累，对broker分布式管理也是一个很大的挑战。

#### 3、如此多的服务，如何实现？

在微服务架构中，一般每一个服务都是有多个拷贝，来做负载均衡。一个服务随时可能下线，也可能应对临时访问压力增加新的服务节点。服务之间如何相互感知？服务如何管理？

这就是**服务发现**的问题了。一般有两类做法，也各有优缺点。基本都是通过zookeeper等类似技术做服务注册信息的分布式管理。当服务上线时，服务提供者将自己的服务信息注册到ZK（或类似框架），并通过心跳维持长链接，实时更新链接信息。服务调用者通过ZK寻址，根据可定制算法， 找到一个服务，还可以将服务信息缓存在本地以提高性能。当服务下线时，ZK会发通知给服务客户端。

客户端做： 优点是架构简单，扩展灵活，只对服务注册器依赖。缺点是客户端要维护所有调用服务的地址，有技术难度，一般大公司都有成熟的内部框架支持，比如Dubbo。

服务端做：优点是简单，所有服务对于前台调用方透明，一般在小公司在云服务上部署的应用采用的比较多。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/71866a9c9d523e4d4b448897770be673.jpeg)

#### 4、服务挂了，如何解决

前面提到，Monolithic方式开发一个很大的风险是，把所有鸡蛋放在一个篮子里，一荣俱荣，一损俱损。而分布式最大的特性就是网络是不可靠的。通过微服务拆分能降低这个风险，不过如果没有特别的保障，结局肯定是噩梦。所以当我们的系统是由一系列的服务调用链组成的时候，我们必须确保任一环节出问题都不至于影响整体链路。

#### 相应的手段有很多：

①重试机制

②限流

③熔断机制

④负载均衡

⑤降级（本地缓存）

这些方法基本都很明确通用，比如Netflix的Hystrix：https://github.com/Netflix/Hystrix

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/c53cf18cb025841f47a9da33ecebc54d.jpeg)

### 七、常见的设计模式和应用

有一个图非常好的总结微服务架构需要考虑的问题，包括：

1、API Gateway

2、服务间调用

3、服务发现

4、服务容错

5、服务部署

6、数据调用

![img](https://ask.qcloudimg.com/http-save/yehe-14352312/df62449ec173d4de825c9a3569e80caa.jpeg)

六种常见的微服务架构设计模式：

#### 1、聚合器微服务设计模式

这是一种最常见也最简单的设计模式：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/8d9f011b5d6ba778e6d1ec03df936e0e.jpeg)

**聚合器调用多个服务实现应用程序所需的功能。它可以是一个简单的Web页面，将检索到的数据进行处理展示。**它也可以是一个更高层次的组合微服务，对检索到的数据增加业务逻辑后进一步发布成一个新的微服务，这符合DRY原则。另外，每个服务都有自己的缓存和数据库。如果聚合器是一个组合服务，那么它也有自己的缓存和数据库。聚合器可以沿X轴和Z轴独立扩展。

#### 2、代理微服务设计模式

这是聚合模式的一个变种，如下图所示：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/d5db5ff79ac36d6fb2c11cfebc331c41.jpeg)

在这种情况下，**客户端并不聚合数据，但会根据业务需求的差别调用不同的微服务。代理可以仅仅委派请求，也可以进行数据转换工作。**

#### 3、链式微服务设计模式

这种模式在接收到请求后会产生一个经过合并的响应，如下图所示：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/600418971a5bf3c995a638febe4d843c.jpeg)

在这种情况下，**服务A接收到请求后会与服务B进行通信，类似地，服务B会同服务C进行通信。所有服务都使用同步消息传递。在整个链式调用完成之前，客户端会一直阻塞。**

因此，服务调用链不宜过长，以免客户端长时间等待。

#### 4、分支微服务设计模式

这种模式是聚合器模式的扩展，允许同时调用两个微服务链，如下图所示：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/e5b6f86190cc5b9768496ae48f99e820.jpeg)

#### 5、数据共享微服务设计模式

自治是微服务的设计原则之一，就是说微服务是全栈式服务。但在重构现有的“单体应用（monolithic application）”时，SQL数据库反规范化可能会导致数据重复和不一致。

因此，在单体应用到微服务架构的过渡阶段，可以使用这种设计模式，如下图所示：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/3c9ab8b849e6af4202b16947ae7c59d8.jpeg)

在这种情况下，**部分微服务可能会共享缓存和数据库存储**。不过，这只有在两个服务之间存在强耦合关系时才可以。对于基于微服务的新建应用程序而言，这是一种反模式。

#### 6、异步消息传递微服务设计模式

虽然REST设计模式非常流行，但它是同步的，会造成阻塞。因此部分基于微服务的架构可能会选择使用消息队列代替REST请求/响应，如下图所示：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/9d81badd7d50785156e51722981c8140.jpeg)

### 八、优点和缺点

#### 1、微服务的优点：

关键点：复杂度可控，独立按需扩展，技术选型灵活，容错，可用性高

①它解决了复杂性的问题。它会将一种怪异的整体应用程序分解成一组服务。虽然功能总量 不变，但应用程序已分解为可管理的块或服务。每个服务都以RPC或消息驱动的API的形式定义了一个明确的边界；Microservice架构模式实现了一个模块化水平。

②这种架构使每个服务都能够由专注于该服务的团队独立开发。开发人员可以自由选择任何有用的技术，只要该服务符合API合同。当然，大多数组织都希望避免完全无政府状态并限制技术选择。然而，这种自由意味着开发人员不再有义务使用在新项目开始时存在的可能过时的技术。在编写新服务时，他们可以选择使用当前的技术。此外，由于服务相对较小，因此使用当前技术重写旧服务变得可行。

③Microservice架构模式使每个微服务都能独立部署。开发人员不需要协调部署本地服务的变更。这些变化可以在测试后尽快部署。例如，UI团队可以执行A | B测试，并快速迭代UI更改。Microservice架构模式使连续部署成为可能。

④Microservice架构模式使每个服务都可以独立调整。您可以仅部署满足其容量和可用性限制的每个服务的实例数。此外，您可以使用最符合服务资源要求的硬件。

#### 2、微服务的缺点

关键点（挑战）：系统部署依赖，服务间通信成本，数据一致性，系统集成测试，重复工作，性能监控等

①一个缺点是名称本身。术语microservice过度强调服务规模。但重要的是要记住，这是一种手段，而不是主要目标。微服务的目标是充分分解应用程序，以便于敏捷应用程序开发和部署。

②微服务器的另一个主要缺点是分布式系统而产生的复杂性。开发人员需要选择和实现基于消息传递或RPC的进程间通信机制。此外，他们还必须编写代码来处理部分故障，因为请求的目的地可能很慢或不可用。

③微服务器的另一个挑战是分区数据库架构。更新多个业务实体的业务交易是相当普遍的。但是，在基于微服务器的应用程序中，您需要更新不同服务所拥有的多个数据库。使用分布式事务通常不是一个选择，而不仅仅是因为CAP定理。许多今天高度可扩展的NoSQL数据库都不支持它们。你最终不得不使用最终的一致性方法，这对开发人员来说更具挑战性。

④测试微服务应用程序也更复杂。服务类似的测试类将需要启动该服务及其所依赖的任何服务（或至少为这些服务配置存根）。再次，重要的是不要低估这样做的复杂性。

⑤Microservice架构模式的另一个主要挑战是实现跨越多个服务的更改。例如，我们假设您正在实施一个需要更改服务A，B和C的故事，其中A取决于B和B取决于C.在单片应用程序中，您可以简单地更改相应的模块，整合更改，并一次性部署。相比之下，在Microservice架构模式中，您需要仔细规划和协调对每个服务的更改。例如，您需要更新服务C，然后更新服务B，然后再维修A.幸运的是，大多数更改通常仅影响一个服务，而需要协调的多服务变更相对较少。

⑥部署基于微服务的应用程序也更复杂。单一应用程序简单地部署在传统负载平衡器后面的一组相同的服务器上。每个应用程序实例都配置有基础架构服务（如数据库和消息代理）的位置（主机和端口）。相比之下，微服务应用通常由大量服务组成。例如，每个服务将有多个运行时实例。更多的移动部件需要进行配置，部署，扩展和监控。此外，您还需要实现服务发现机制，使服务能够发现需要与之通信的任何其他服务的位置（主机和端口）。传统的基于故障单和手动操作的方法无法扩展到这种复杂程度。因此，成功部署微服务应用程序需要开发人员更好地控制部署方法，并实现高水平的自动化。

### 九、思考：意识的转变

微服务对我们的思考，更多的是思维上的转变。对于微服务架构： **技术上不是问题，意识比工具重要。**

关于微服务的几点设计出发点：

1、应用程序的核心是业务逻辑，按照业务或客户需求组织资源（这是最难的）

2、做有生命的产品，而不是项目

3、头狼战队，全栈化

4、后台服务贯彻Single Responsibility Principle（单一职责原则）

5、VM->Docker （to PE）

6、DevOps (to PE)

同时，对于开发同学，有这么多的中间件和强大的PE支持固然是好事，我们也需要深入去了解这些中间件背后的原理，知其然知其所以然，在有限的技术资源如何通过开源技术实施微服务？

最后，一般提到微服务都离不开DevOps和Docker，理解 **微服务架构是核心，devops和docker是工具，是手段。**

## 如何把应用拆解成多个服务？

[参考](https://www.infoq.cn/article/2018/07/decomposing-system-microservices)

### 限界上下文（Bounded context）

Khononov 指出[通用语言（ubiquitous language）](https://www.agilealliance.org/glossary/ubiquitous-language/)在[领域驱动设计（Domain-Driven Design，DDD）](http://dddcommunity.org/learning-ddd/what_is_ddd/)中是基础实践，该实践的一种实现方式就是以领域专家的语言与他们进行对话。有时候，你会发现对于相同的业务概念，他们会有不同的心智模型，或者使用相同的术语描述不同的理念，如果这样的话，就预示着这些理念属于不同的[限界上下文](https://martinfowler.com/bliki/BoundedContext.html)。从一开始，Khononov 和他的团队就使用这些方法来发现定义服务的边界，每个边界内都会成为一个服务。他指出，这些服务代表了很广泛的业务领域，有时候会导致一个限界上下文涵盖多个业务子域。

### 业务子域

下一步，他们使用这些业务子域作为边界，然后为每个业务子域创建一个服务。在 Khononov 的经验中，子域和服务之间建立一对一的关系是 DDD 社区非常常见的方式，但是他们并没有满足于此，而是继续努力实现更小的服务。

### 业务实体

深入研究子域，他们发现了业务实体和流程，然后他们将其抽取到单独的服务中。开始的时候，这种终极方式失败得很惨，但是 Khononov 指出在随后的项目中，它取得了更大的成功。

就这三种策略来说，Khononov 指出，使用限界上下文能够帮助他们找到最大的有效单体边界，然而，尽管它是一个可行的工作模型，但是他认为这种方式[并没有很好地匹配微服务的理念](https://vladikk.com/2018/01/21/bounded-contexts-vs-microservices/)。在业务子域和实体间选择的时候，他认为最好的分解等级依赖于正在构建的系统及其用例。他强调，微服务的理念实际上并不是关于单个服务内部如何实现的，而是关于服务之间如何交合和耦合的。

> 系统分解为微服务的阈值是由微服务所属的用例来定义的。

Khononov 还没有找到一种简单的方式来评估一个系统的设计，但是他相信现在已经有了足够多的启发式设计准则，帮助我们将系统分解为微服务。他认为最有用的几项包括：

- 始终分解至限界上下文等级。除非你有充分的理由，否则不要进一步分解。[分布式系统有它们自己所面临的挑战](http://www.simpleorientedarchitecture.com/8-fallacies-of-distributed-systems/)。
- 核心子域是公司挣钱的区域。在进行分解时，确保获取领域的知识并具有恰当的子域。
- 购买或采用通用子域。它们已经解决了一些问题了，如果自己实现的话，是没有竞争优势的。
- 为了支持核心域，我们需要支持子域，但是这不会增加任何的竞争性优势。它们通常非常稳定和简单，在早期阶段就可以进行进一步的分解，直至使其成为实体服务。
- 采用一致性的需求，帮助我们寻找必须放到同一个服务中的函数或方法。
- 确保事件是显式和自描述的。考虑在一个服务中，使用私有事件作为实现细节，而将更为严格的公共事件作为服务的公开接口。
- 寻找按照相同频率进行变化的服务，它们可能能够进行合并以减低复杂性。
- 评估每个服务的接口。如果觉得服务范围太广的话，那么它可能能够拆分为更小的服务，主要站在集成方面，重新考虑评估边界以简化整个系统的设计。

Khononov 在总结中指出，随着系统中服务的平均规模变得越来越小，你将会从一个[大泥球](https://en.wikipedia.org/wiki/Big_ball_of_mud)般的单体系统，通过限界上下文实现相对较大的服务，进而转化为微服务。但是，他强调，如果你继续让服务变得更小的话，那么最终将会形成一个分布式的大泥球。

## 服务之间调用

微服务介绍与对比——>怎么具体实践微服务——>每个服务之前如何通信

[参考](https://blog.csdn.net/weixin_38748858/article/details/101062272)

在[微服务](https://so.csdn.net/so/search?q=微服务&spm=1001.2101.3001.7020)架构中，需要调用很多服务才能完成一项功能。服务之间如何互相调用就变成微服务架构中的一个关键问题。服务调用有两种方式，一种是**RPC方式**，另一种是**事件驱动**（Event-driven）方式，也就是**发消息方式**。消息方式是松耦合方式，比紧耦合的RPC方式要优越，但RPC方式如果用在适合的场景也有它的一席之地.

**耦合的种类：**
我们总在谈耦合，那么耦合到底意味着什么呢？

1. 时间耦合：客户端和服务端必须同时上线才能工作。发消息时，接受消息队列必须运行，但后台处理程序暂时不工作也不影响。
2. 容量耦合：客户端和服务端的处理容量必须匹配。发消息时，如果后台处理能力不足也不要紧，消息队列会起到缓冲的作用。
3. 接口耦合：RPC调用有函数标签，而消息队列只是一个消息。例如买了商品之后要调用发货服务，如果是发消息，那么就只需发送一个商品被买消息。
4. 发送方式耦合：RPC是点对点方式，需要知道对方是谁，它的好处是能够传回返回值。消息既可以点对点，也可以用广播的方式，这样减少了耦合，但也使返回值比较困难。

下面我们来逐一分析这些耦合的影响。 第一，时间耦合，对于多数应用来讲，你希望能马上得到回答，因此即使使用消息队列，后台也需要一直工作。第二，容量耦合，如果你对回复有时间要求，那么消息队列的缓冲功能作用不大，因为你希望及时响应。真正需要的是自动伸缩（Auto-scaling），它能自动调整服务端处理能力去匹配请求数量。第三和第四，接口耦合和发送方式耦合，这两个确实是[RPC](https://so.csdn.net/so/search?q=RPC&spm=1001.2101.3001.7020)方式的软肋。

### 事件驱动（Event-Driven）方式：

Martin Fowler把事件驱动分成四种方式([What do you mean by “Event-Driven”](https://martinfowler.com/articles/201701-event-driven.html))，简化之后本质上只有两种方式。 一种就是我们熟悉的的**事件通知（Event Notification）**，另一种是**事件溯源（Event Sourcing）**。**事件通知就是微服务之间不直接调用，而是通过发消息来进行合作**。**事件溯源有点像记账，它把所有的事件都记录下来，作为永久存储层，再在它的基础之上构建应用程序**。实际上从应用的角度来讲，它们并不应该分属一类，它们的用途完全不同。**事件通知是微服务的调用（或集成）方式，应该和RPC分在一起**。**事件溯源是一种存储数据的方式，应该和数据库分在一起。**

#### 事件通知（Event Notification）方式：

让我们用具体的例子来看一下。在下面的例子中，有三个微服务，“Order Service”， “Customer Service” 和“Product Service”.

![file](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/20190920153708185.jpeg)

[图片来源](https://www.infoq.com/presentations/aggregates-modular-microservices/)

先说**读数据**，假设要创建一个“Order”，在这个过程中需要读取“Customer”的数据和“Product”数据。如果用事件通知的方式就只能在“Order Service”本地也创建只读“Customer”和“Product”表，并**把数据用消息的方式同步过来**。

再说**写数据**，如果在创建一个“Order”时需要创建一个新的“Customer”或要修改“Customer”的信息，那么可以**在界面上跳转到用户创建页面**，然后在“Customer Service”创建用户之后再发”用户已创建“的消息，“Order Service”接到消息，**更新本地“Customer”表**。

这并不是一个很好的使用事件驱动的例子，因为**事件驱动的优点就是不同的程序之间可以独立运行，没有绑定关系**。但现在“Order Service”需要等待“Customer Service”创建完了之后才能继续运行，来完成整个创建“Order”的工作。主要是因为“Order”和“Customer”本身从逻辑上来讲就是紧耦合关系，没有“Customer”你是不能创建“Order”的。

在这种紧耦合的情况下，也**可以使用RPC**。你**可以建立一个更高层级的管理程序来管理这些微服务之间的调用**，这样“Order Service”就不必直接调用“Customer Service”了。当然它从本质上来讲并没有解除耦合，只是把耦合转移到了上一层，但至少现在“order Service”和“Customer Service”可以互不影响了。之所以不能根除这种紧耦合关系是因为它们在业务上是紧耦合的。



再举一个购物的例子。用户选好商品之后进行“Checkout”，生成“Order”，然后需要“payment”，再从“Inventory”取货，最后由“Shipment”发货，它们每一个都是微服务。这个例子用RPC方式和事件通知方式都可以完成。**当用RPC方式时，由“Order”服务调用其他几个服务来完成整个功能**。**用事件通知方式时，“Checkout”服务完成之后发送“Order Placed”消息，“Payment”服务收到消息，接收用户付款，发送“Payment received”消息。“Inventory”服务收到消息，从仓库里取货，并发送“Goods fetched”消息。“Shipment”服务得到消息，发送货物，并发送“Goods shipped”消息**。

![file](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/20190920153708514.jpeg)

[图片来源](https://blog.bernd-ruecker.com/the-microservice-workflow-automation-cheat-sheet-fc0a80dc25aa)

对这个例子来讲，使用事件驱动是一个不错的选择，因为每个服务发消息之后它不需要任何反馈，这个消息由下一个模块接收来完成下一步动作，时间上的要求也比上一个要宽松。用事件驱动的好处是降低了耦合度，坏处是你现在不能在程序里找到整个购物过程的步骤。如果一个业务逻辑有它自己相对固定的流程和步骤，那么使用RPC或业务流程管理（BPM）能够更方便地管理这些流程。在这种情况下选哪种方案呢？在我看来好处和坏处是大致相当的。从技术上来讲要选事件驱动，从业务上来讲要选RPC。不过现在越来越多的人采用事件通知作为微服务的集成方式，它似乎已经成了微服务之间的标椎调用方式。

#### 事件溯源(Event Sourcing)：

这是一种具有颠覆性质的的设计，**它把系统中所有的数据都以事件（Event）的方式记录下来，它的持久存储叫Event Store， 一般是建立在数据库或消息队列（例如Kafka）基础之上，并提供了对事件进行操作的接口，例如事件的读写和查询。**事件溯源是由领域驱动设计([Domain-Driven Design](https://dddcommunity.org/book/evans_2003/))提出来的。DDD中有一个很重要的概念，有界上下文（[Bounded Context](https://martinfowler.com/bliki/BoundedContext.html)），可以用有界上下文来划分微服务，每个有界上下文都可以是一个微服务。 下面是有界上下文的示例。下图中有两个服务“Sales”和“Support”。**有界上下文的一个关键是如何处理共享成员**， 在图中是“Customer”和“Product”。在不同的有界上下文中，共享成员的含义、用法以及他们的对象属性都会有些不同，**DDD建议这些共享成员在各自的有界上下文中都分别建自己的类（包括数据库表），而不是共享。可以通过数据同步的手段来保持数据的一致性。**下面还会详细讲解。

![file](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/201909201537097.jpeg)
[图片来源](https://martinfowler.com/bliki/BoundedContext.html)

事件溯源是微服务的一种存储方式，它是微服务的内部实现细节。因此你可以决定哪些微服务采用事件溯源方式，哪些不采用，而不必所有的服务都变成事件溯源的。 **通常整个应用程序只有一个Event Store， 不同的微服务都通过向Event Store发送和接受消息而互相通信**。**Event Store内部可以分成不同的stream（相当于消息队列中的Topic）， 供不同的微服务中的领域实体（Domain Entity）使用**。

**事件溯源的一个短板是数据查询**，它有两种方式来解决。**第一种是直接对stream进行查询，这只适合stream比较小并且查询比较简单的情况**。查询复杂的话，就要采用**第二种方式，那就是建立一个只读数据库，把需要的数据放在库中进行查询。数据库中的数据通过监听Event Store中相关的事件来更新。**

数据库存储方式只能保存当前状态，而事件溯源则存储了所有的历史状态，因而能根据需要回放到历史上任何一点的状态，具有很大优势。但它也不是一点问题都没有。**第一，它的程序比较复杂，因为事件是一等公民，你必须把业务逻辑按照事件的方式整理出来，然后用事件来驱动程序**。**第二，如果你要想修改事件或事件的格式就比较麻烦，因为旧的事件已经存储在Event Store里了（事件就像日志，是只读的），没有办法再改**。

由于事件溯源和事件通知表面上看起来很像，不少人都搞不清楚它们的区别。**事件通知只是微服务的集成方式，程序内部是不使用事件溯源的，内部实现仍然是传统的数据库方**式。只有当要与其他微服务集成时才会发消息。而**在事件溯源中，事件是一等公民，可以不要数据库，全部数据都是按照事件的方式存储的。**

虽然事件溯源的践行者有不同的意见，但有不少人都认为事件溯源不是微服务的集成方式，而是微服务的一种内部实现方式。因此，在一个系统中，可以某些微服务用事件溯源，另外一些微服务用数据库。当你要集成这些微服务时，你可以用事件通知的方式。注意现在有两种不同的事件需要区分开，**一种是微服务的内部事件，是颗粒度比较细的，这种事件只发送到这个微服务的stream中，只被事件溯源使用。另一种是其他微服务也关心的，是颗粒度比较粗的，这种事件会放到另外一个或几个stream中，被多个微服务使用，是用来做服务之间集成的。**这样做的好处是限制了事件的作用范围，减少了不相关事件对程序的干扰。详见"[Domain Events vs. Event Sourcing](https://www.innoq.com/en/blog/domain-events-versus-event-sourcing/)".

事件溯源出现已经很长时间了，虽然热度一直在上升（尤其是这两年），但总的来说非常缓慢，谈论的人不少，但生产环境使用的不多。究其原因就是应为它对现在的体系结构颠覆太大，需要更改数据存储结构和程序的工作方式，还是有一定风险的。另外，微服务已经形成了一整套体系，从程序部署，服务发现与注册，到监控，服务韧性（Service Resilience），它们基本上都是针对RPC的，虽然也支持消息，但成熟度就差多了，因此有不少工作还是要自己来做。有意思的是Kafka一直在推动它作为事件驱动的工具，也取得了很大的成功。但它却没有得到事件溯源圈内的认可（详见[这里](https://stackoverflow.com/a/49868866)）。

多数事件溯源都使用一个叫[evenstore](https://eventstore.org/)的开源Event Store，或是基于某个数据库的Event Store，只有比较少的人用Kafka做Event Store。 但如果用Kafka实现事件通知就一点问题都没有。总的来说，对大多数公司来讲事件溯源是有一定挑战的，应用时需要找到合适的场景。如果你要尝试的话，可以先拿一个微服务试水。

虽然现在事件驱动还有些生涩，但从长远来讲，还是很看好它的。像其他全新的技术一样，事件溯源需要大规模的适用场景来推动。例如容器技术就是因为微服务的流行和推动，才走向主流。事件溯源以前的适用场景只限于记账和源代码库，局限性较大。区块链可能会成为它的下一个机遇，因为它用的也是事件溯源技术。另外AI今后会渗入到具体程序中，使程序具有学习功能。而RPC模式注定没有自适应功能。事件驱动本身就具有对事件进行反应的能力，这是自我学习的基础。因此，这项技术长远来讲定会大放异彩，但短期内（3-5年）大概不会成为主流。

### RPC方式：

**RPC的方式就是远程函数调用，像RESTFul，gRPC, DUBBO 都是这种方式。**它一般是同步的，可以马上得到结果。在实际中，大多数应用都要求立刻得到结果，这时同步方式更有优势，代码也更简单。

#### 服务网关（API Gateway）:

熟悉微服务的人可能都知道服务网关（API Gateway）。当UI需要调用很多微服务时，它需要了解每个服务的接口，这个工作量很大。于是就用服务网关创建了一个Facade，把几个微服务封装起来，这样UI就只调用服务网关就可以了，不需要去对付每一个微服务。下面是API Gateway示例图：

![file](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/20190920153709420.jpeg)

[图片来源](https://microservices.io/patterns/apigateway.html)

**服务网关（API Gateway）不是为了解决微服务之间调用的紧耦合问题，它主要是为了简化客户端的工作。其实它还可以用来降低函数之间的耦合度。** 有了API Gateway之后，一旦服务接口修改，你可能只需要修改API Gateway， 而不必修改每个调用这个函数的客户端，这样就减少了程序的耦合性。

#### 服务调用：

可以借鉴API Gateway的思路来减少RPC调用的耦合度，例如把多个微服务组织起来形成一个完整功能的服务组合，并对外提供统一的服务接口。这种想法跟上面的API Gateway有些相似，都是把服务集中起来提供粗颗粒（Coarse Granular）服务，而不是细颗粒的服务（Fine Granular）。但这样建立的服务组合可能只适合一个程序使用，没有多少共享价值。因此如果有合适的场景就采用，否侧也不必强求。虽然我们不能降低RPC服务之间的耦合度，却可以减少这种紧耦合带来的影响。

### 降低紧耦合的影响：

什么是紧耦合的主要问题呢？就是客户端和服务端的升级不同步。服务端总是先升级，客户端可能有很多，如果要求它们同时升级是不现实的。它们有各自的部署时间表，一般都会选择在下一次部署时顺带升级。

一般有两个办法可以解决这个问题：

1. **同时支持多个版本**：这个工作量比较大，因此大多数公司都不会采用这种方式。
2. **服务端向后兼容**：这是更通用的方式。例如你要加一个新功能或有些客户要求给原来的函数增加一个新的参数，但别的客户不需要这个参数。这时你只好新建一个函数，跟原来的功能差不多，只是多了一个参数。这样新旧客户的需求都能满足。它的好处是向后兼容（当然这取决于你使用的协议）。它的坏处是当以后新的客户来了，看到两个差不多的函数就糊涂了，不知道该用那个。而且时间越长越严重，你的服务端可能功能增加的不多，但相似的函数却越来越多，无法选择。

**它的解决办法就是使用一个支持向后兼容的RPC协议，现在最好的就是Protobuf gRPC，尤其是在向后兼容上。它给每个服务定义了一个接口，这个接口是与编程语言无关的中性接口，然后你可以用工具生成各个语言的实现代码，供不同语言使用。**函数定义的变量都有编号，变量可以是可选类型的，这样就比较好地解决了函数兼容的问题。就用上面的例子，当你要增加一个可选参数时，你就定义一个新的可选变量。由于它是可选的，原来的客户端不需要提供这个参数，因此不需要修改程序。而新的客户端可以提供这个参数。你只要在服务端能同时处理这两种情况就行了。这样服务端并没有增加新的函数，但用户的新需求满足了，而且还是向后兼容的。

### 微服务的数量有没有上限？

总的来说微服务的数量不要太多，不然会有比较重的运维负担。有一点需要明确的是微服务的流行不是因为技术上的创新，而是为了满足管理上的需要。单体程序大了之后，各个模块的部署时间要求不同，对服务器的优化要求也不同，而且团队人数众多，很难协调管理。把程序拆分成微服务之后，每个团队负责几个服务，就容易管理了，而且每个团队也可以按照自己的节奏进行创新，但它给运维带来了巨大的麻烦。所以在微服务刚出来时，我一直觉得它是一个退步，弊大于利。但由于管理上的问题没有其他解决方案，只有硬着头皮上了。值得庆幸的是微服务带来的麻烦都是可解的。直到后来，微服务建立了全套的自动化体系，从程序集成到部署，从全链路跟踪到日志，以及服务检测，服务发现和注册，这样才把微服务的工作量降了下来。虽然微服务在技术上一无是处，但它的流行还是大大推动了容器技术，服务网格（Service Mesh）和全链路跟踪等新技术的发展。不过它本身在技术上还是没有发现任何优势。。直到有一天，我意识到单体程序其实性能调试是很困难的（很难分离出瓶颈点），而微服务配置了全链路跟踪之后，能很快找到症结所在。看来微服务从技术来讲也不全是缺点，总算也有好的地方。但微服务的颗粒度不宜过细，否则工作量还是太大。

一般规模的公司十几个或几十个微服务都是可以承受的，但如果有几百个甚至上千个，那么绝不是一般公司可以管理的。尽管现有的工具已经很齐全了，而且与微服务有关的整个流程也已经基本上全部自动化了，但它还是会增加很多工作。Martin Fowler几年以前建议先从单体程序开始（详见 [MonolithFirst](https://martinfowler.com/bliki/MonolithFirst.html)），然后再逐步把功能拆分出去，变成一个个的微服务。但是后来有人反对这个建议，他也有些松口了。如果单体程序不是太大，这是个好主意。可以用数据额库表的数量来衡量程序的大小，我见过大的单体程序有几百张表，这就太多了，很难管理。正常情况下，一个微服务可以有两、三张表到五、六张表，一般不超过十张表。但如果要减少微服务数量的话，可以把这个标准放宽到不要超过二十张表。用这个做为大致的指标来创建微程序，如果使用一段时间之后还是觉得太大了，那么再逐渐拆分。当然，按照这个标准建立的服务更像是服务组合，而不是单个的微服务。不过它会为你减少工作量。只要不影响业务部门的创新进度，这是一个不错的方案。

到底应不应该选择微服务呢？如果单体程序已经没法管理了，那么你别无选择。如果没有管理上的问题，那么微服务带给你的只有问题和麻烦。其实，一般公司都没有太多选择，只能采用微服务，不过你可以选择建立比较少的微服务。如果还是没法决定，有一个折中的方案，“内部微服务设计”。

#### 内部微服务设计：

这种设计表面上看起来是一个单体程序，它只有一个源代码存储仓库，一个数据库，一个部署，但在程序内部可以按照微服务的思想来进行设计。它可以分成多个模块，每个模块是一个微服务，可以由不同的团队管理。

![file](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/20190920153709762.jpeg)

[图片来源](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/identify-microservice-domain-model-boundaries)

用这张图做例子。这个图里的每个圆角方块大致是一个微服务，但我们可以把它作为一个单体程序来设计，内部有五个微服务。每个模块都有自己的数据库表，它们都在一个数据库中，但模块之间不能跨数据库访问（不要建立模块之间数据库表的外键）。“User”（在Conference Management模块中）是一个共享的类，但在不同的模块中的名字不同，含义和用法也不同，成员也不一样（例如，在“Customer Service”里叫“Customer”）。DDD（Domain-Driven Design）建议不要共享这个类，而是在每一个有界上下文（模块）中都建一个新类，并拥有新的名字。虽然它们的数据库中的数据应该大致相同，但DDD建议每一个有界上下文中都建一个新表，它们之间再进行数据同步。

这个所谓的“内部微服务设计”其实就是DDD，但当时还没有微服务，因此外表看起来是单体程序，但内部已经是微服务的设计了。它的书在2003就出版了，当时就很有名。但它更偏重于业务逻辑的设计，践行起来也比较困难，因此大家谈论得很多，真正用的较少。直到十年之后，微服务出来之后，人们发现它其实内部就是微服务，而且微服务的设计需要用它的思想来指导，于是就又重新焕发了青春，而且这次更猛，已经到了每个谈论微服务的人都不得不谈论DDD的地步。不过一本软件书籍，在十年之后还能指导新技术的设计，非常令人钦佩。

这样设计的好处是它是一个单体程序，省去了多个微服务带来的部署、运维的麻烦。但它内部是按微服务设计的，如果以后要拆分成微服务会比较容易。至于什么时候拆分不是一个技术问题。如果负责这个单体程序的各个团队之间不能在部署时间表，服务器优化等方面达成一致，那么就需要拆分了。当然你也要应对随之而来的各种运维麻烦。内部微服务设计是一个折中的方案，如果你想试水微服务，但又不愿意冒太大风险时，这是一个不错的选择。

微服务的数据库设计也有很多内容，包括如何把服务从单体程序一步步里拆分出来请参见[“微服务的数据库设计"](https://blog.csdn.net/weixin_38748858/article/details/102634941).

#### 结论：

微服务之间的调用有两种方式，RPC和事件驱动。**事件驱动是更好的方式，因为它是松耦合的。但如果业务逻辑是紧耦合的，RPC方式也是可行的（它的好处是代码更简单），而且你还可以通过选取合适的协议（Protobuf gRPC）来降低这种紧耦合带来的危害**。由于事件溯源和事件通知的相似性，很多人把两者弄混了，但它们实际上是完全不同的东西。微服务的数量不宜太多，可以先创建比较大的微服务（更像是服务组合）。如果你还是不能确定是否采用微服务[架构](https://so.csdn.net/so/search?q=架构&spm=1001.2101.3001.7020)，可以先从“内部微服务设计”开始，再逐渐拆分。



## 如何保持数据一致性

[参考](https://docshome.gitbook.io/microservices/5-event-driven-data-management-for-microservices)

为了保证松耦合，每个service有它自己的数据库。维护service之间的数据一致性是一个挑战，因为二阶段提交事务/分布式事务并不是很多应用的一个选项。相反的，一个应用必须使用[事件驱动架构](http://microservices.io/patterns/data/event-driven-architecture.html)。一个服务在它的数据变化时，会发布一个事件。别的服务消费这个事件，然后更新自己的数据。有很多种可靠的数据更新和事件发布的方法，包括[事件源](http://microservices.io/patterns/data/event-sourcing.html)和[事务日志跟踪](http://microservices.io/patterns/data/transaction-log-tailing.html)。

### 事件驱动架构

许多应用使用了[事件驱动架构](https://martinfowler.com/eaaDev/EventNarrative.html)作为解决方案。在此架构中，**微服务在发生某些重要事件时发布一个事件，比如更新业务实体时。其他微服务订阅了这些事件，当接收到一个事件时，它可以更新自己的业务实体，可能会触发更多的事件被发布**。

你可以使用事件来实现跨多服务业务的事务。一个事务由一系列的步骤组成。每个步骤包括了微服务更新业务实体和发布一个下一步需要触发的事件。下图依次展示了如何在创建订单时使用事件驱动方法来检查可用信用额度。

**微服务通过 Message Broker （消息代理）进行交换事件**：

- Order Service （订单服务）创建一个状态为 NEW 的订单，并发布一个 Order Created （订单创建）事件。

![img](https://872026152-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LAinv8dInYi41sSnmWu%2F-LAinzxGnqu1h1CS4HMv%2F-LAio67CLVV7x9AhFDx0%2F5-2.png?generation=1524425072232260&alt=media)

Order Service 发布一个事件

- Customer Service （客户服务）消费了 Order Created 事件，为订单预留信用额度，并发布 Credit Reserved 事件。

![img](https://872026152-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LAinv8dInYi41sSnmWu%2F-LAinzxGnqu1h1CS4HMv%2F-LAio69fjOzhf_mKzATO%2F5-3.png?generation=1524425070985110&alt=media)

Customer Service 响应

- Order Service 消费了 Credit Reserved （信用预留）事件并将订单的状态更改为 OPEN。

![img](https://872026152-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LAinv8dInYi41sSnmWu%2F-LAinzxGnqu1h1CS4HMv%2F-LAio6CckKvIhRRf9zkF%2F5-4.png?generation=1524425071787820&alt=media)

Order Service 作用于响应

更复杂的场景可能会涉及额外的步骤，例如在检查客户信用的同时保留库存。

假设（a）每个服务原子地更新数据库并发布一个事件 （稍后再详细说明），（b）Message Broker 保证事件至少被送达一次，然后你就实现了跨多服务的业务事务。需要注意的是，这些并不是 ACID 事务。它们只提供了更弱的保证，如[最终一致性](https://en.wikipedia.org/wiki/Eventual_consistency)。该事务模型称为 [BASE 模型](http://queue.acm.org/detail.cfm?id=1394128)。

你也可以用事件来维护由多个微服务数据构成的物化视图。维护视图的服务订阅了相关事件并更新视图。下图展示了 Customer Order View Updater Service （客户订单视图更新服务）根据 Customer Service 和 Order Service 发布的事件更新 Customer Order View （客户订单视图）。

![img](https://872026152-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LAinv8dInYi41sSnmWu%2F-LAinzxGnqu1h1CS4HMv%2F-LAio6Fv7NFEaPlPOPnq%2F5-5.png?generation=1524425071012655&alt=media)

Customer Order View 被两个服务访问

当 Customer Order View Updater Service 接收到 Customer 或 Order 事件时，它会更新 Customer Order View 的数据存储。你可以使用如 MongoDB 之类的文档数据库实现 Customer Order View，并为每个 Customer 存储一个文档。Customer Order View Query Service（客户订单视图查询服务）通过查询 Customer Order View 数据存储来处理获取一位客户和最近的订单的请求。

事件驱动的架构有几个优点与缺点。它能够实现跨越多服务并提供最终一致性的事务。另一个好处是它还使得应用能够维护[物化视图](https://en.wikipedia.org/wiki/Materialized_view)。

一个缺点是其编程模型比使用 ACID 事务更加复杂。通常，你必须实现事务补偿以从应用级别的故障中恢复。例如，如果信用检查失败，你必须取消订单。此外，应用必须处理不一致的数据。因为未提交的事务所做的更改是可见的。如果从未更新的物化视图中读取，应用依然可以看到不一致性。另一个缺点是订阅者必须要检测和忽略重复的事件。