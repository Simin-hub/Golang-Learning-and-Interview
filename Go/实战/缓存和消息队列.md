# 缓存和消息队列

# 本地缓存和分布式缓存

## 一、缓存的概念

在服务端编程当中，**缓存主要是指将数据库的数据加载到内存中，之后对该数据的访问都在内存中完成，从而减少了对数据库的访问，解决了高并发场景中数据库容易成为性能瓶颈的问题；以及基于内存的访问速度高于磁盘的访问速度的原理（数据库读取数据一般需要从磁盘读取），提高了数据的访问速度和程序性能**。

根据**缓存是否与应用进程属于同一进程**，可以将内存分为本地缓存和分布式缓存。**本地缓存是在同一个进程内的内存空间中缓存数据，数据读写都是在同一个进程内完成；而分布式缓存是一个独立部署的进程并且一般都是与应用进程部署在不同的机器，故需要通过网络来完成分布式缓存数据读写操作的数据传输**。

## 二、本地缓存

### 本地缓存的优缺点

**1. 访问速度快，但无法进行大数据存储**

本地缓存相对于分布式缓存的好处是，由于数据不需要跨网络传输，故性能更好，但是由于占用了应用进程的内存空间，如 Java 进程的 JVM 内存空间，故不能进行大数据量的数据存储。

**2. 集群的数据更新问题**

与此同时，**本地缓存只支持被该应用进程访问，一般无法被其他应用进程访问**，故在应用进程的集群部署当中，如果对应的数据库数据，存在数据更新，则需要同步更新不同部署节点的本地缓存的数据来包保证数据一致性，复杂度较高并且容易出错，如**基于 Redis 的发布订阅机制**来同步更新各个部署节点。

**3. 数据随应用进程的重启而丢失**

由于本地缓存的数据是**存储在应用进程的内存空间的，所以当应用进程重启时，本地缓存的数据会丢失**。所以对于需要持久化的数据，需要注意及时保存，否则可能会造成数据丢失。

### 适用场景

所以本地缓存一般适合于**缓存只读数据**，如统计类数据。或者每个部署节点独立的数据，如长连接服务中，每个部署节点由于都是维护了不同的连接，每个连接的数据都是独立的，并且随着连接的断开而删除。如果数据在集群的不同部署节点需要共享和保持一致，则需要使用分布式缓存来统一存储，实现应用集群的所有应用进程都在该统一的分布式缓存中进行数据存取即可。

### 本地缓存的实现

缓存一般是一种key-value的键值对数据结构，所以需要使用字典数据结构来实现，在 Java 编程中，常用的字典实现包括 HashMap 和 ConcurretHashMap。

与此同时，本地缓存由于需要被不同的服务端线程并发读写，故需要保证线程安全。由于 HashMap 不是线程安全的，而 ConcurrentHashMap 是线程安全的，故一般会使用 ConcurrentHashMap 来作为 Java 编程中的本地缓存实现。除此之外，也有其他更加智能的本地缓存实现，如可以定时失效，访问重新加载等特性，典型实现包括 Google 的 guava 工具包的 Cache 实现，这些也是线程安全的。

## 三、分布式缓存

### 分布式缓存的优缺点

**1. 支持大数据量存储，不受应用进程重启影响**

**分布式缓存由于是独立部署的进程，拥有自身独立的内存空间，不会受到应用进程重启的影响**，在应用进程重启时，分布式缓存的数据依然存在。同时对于数据量而言，由于不需要占用应用进程的内存空间，并且一般支持以集群的方式拓展，故可以进行大数据量的数据缓存。

**2. 数据集中存储，保证数据一致性**

当应用进程采用集群方式部署时，集群的每个部署节点都**通过一个统一的分布式缓存进行数据存取操作，故不存在本地缓存中的数据更新问题，保证了不同节点的应用进程的数据一致性问题**。

**3. 数据读写分离，高性能，高可用**

**分布式缓存一般支持数据副本机制，可以实现读写分离，故可以解决高并发场景中的数据读写性能问题**。并且由于在多个缓存节点冗余存储数据，提高了缓存数据的可用性，避免某个缓存节点宕机导致数据不可用问题。

**4. 数据跨网络传输，性能低于本地缓存**

由于分布式缓存是独立部署的进程，并且一般都是与应用进程位于不同的机器，故需要通过网络来进行数据传输，这样相对于本地缓存的进程内部的数据读取操作，性能会较低。

### 分布式缓存的实现

分布式缓存的典型实现包括 MemCached 和 Redis。

#### MemCached

MemCached 相对于本地缓存的主要差别是以独立进程方式存在，数据集中存储，数据不随应用程序的重启而丢失。而 key-value 键值对的 value 也是一个简单的对象类型，即 value 可以是任意格式的数据，如简单的数字、字符串、对象等，也可以是文件、图像、视频等复杂格式的数据，但是不支持数据结构的特性。

所以 MemCached 进程相当于是在内存维护了一个非常大的哈希表来存储数据，对应的数据操作复杂度都是 O(1)，即常量级别，这也是 MemCached 高性能的一个实现方式，键值对存取速度都非常快。

#### Redis

Redis 是在此基础上，更一步丰富了key-value 键值对的 value 的数据结构类型，即可以在 Redis 中完成 value 的相关数据操作，如 Set 集合去重、有序集合 ZSet 实现数据排序等，这样就不需要在应用程序额外进行这些操作，实现了开箱即用。并且 Redis 是单线程的，不存在并发数据读写的线程安全问题，以及更重要的是保证的数据读写操作的顺序性。

除此之外，Redis 支持主从同步（读写分离）、集群分片拓展、数据持久化等特性，这也是 MemCached 不支持的。所以在高并发场景并且数据能够容忍极端情况下的少量丢失，或者说丢失后可以恢复，如通过日志或者重新计算等， Redis 也可以作为数据库来使用，提高高并发场景中的访问性能。

# 1. 分布式缓存架构

- 什么是缓存？**存储在计算机上的一个原始数据的复制集**
- 无处不在的缓存
- 缓存数据存储

​			**本质是个 Hash 表**

- 缓存的关键指标

  - 缓存命中率

- 影响缓存命中率的指标

  - 缓存键集合大小
    - 键数越少，缓存效率越高

  - 缓存可使用内存空间
    - 缓存对象越多，缓存命中越高

  - 缓存对象生存时间
    - 缓存时间越长，利用率越高

### 缓存类型

##### 通读缓存

通读缓存给客户端返回缓存资源，并在未命中时获取实际数据

种类

- 代理缓存
- 反向代理缓存
- 多层反向代理缓存
- 内容分发网络 CDN
- CDN 同时配置静态文件和动态内容

##### 旁路缓存

旁路缓存通常是一个独立的键值对存储

- 对象缓存就是一种旁路缓存
- 程序获取对象缓存，存在则返回，不存在或过期，获取真实数据并缓存起来

种类

- 浏览器对象缓存
- 本地对象缓存
  - 对象直接缓存在应用程序内存中
  - 对象存储在共享内存中，同机器不同进程都可以访问
- 缓存和应用在同一台服务器
- 远程分布式对象缓存
- 分布式对象缓存一致性 hash 算法



### 缓存性能提升

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/170f69804777527c2dfb84d53f5d2f53.png)



##### 缓存为什么能显著提示性能

缓存数据通常来自内存，比磁盘访问数据更快

缓存数据一般是最终数据，不需要计算

缓存降低数据库、磁盘、网络的负载压力



### 合理使用缓存

频繁修改的数据，增加系统负担

没有热点的访问，导致内存资源浪费

数据不一致与脏读，缓存加载导致的数据一定时间内的不一致

缓存雪崩，缓存服务崩溃导致整个系统宕机

缓存预热，提前将一些元数据或基本数据直接全部缓存

缓存穿透，缓存一些不存在的数据，确保大部分的请求都能利用到缓存的高性能



### [Redis](https://github.com/Simin-hub/Golang-Learning-and-Interview/blob/main/Go/%E5%AE%9E%E6%88%98/Redis.md) vs Memcached

redis 支持复杂的数据结构

redis 支持多路复用，异步 I/O 高性能

redis 支持主从复制高可用

redis 原生集群，share nothing 集群模式



# 2. 消息队列与异步调用架构

### 同步调用 vs 异步调用

同步调用

​	多个耗时操作同步调用

异步调用

​	多次异步调用不阻塞应用线程

### 消息队列构建异步调用架构

组成

- 消息生产者
- 消息队列
- 消息消费者

点对点模型

发布订阅模型

### 消息队列的好处

实现异步处理，提升处理性能

更好的伸缩性

削峰填谷

失败隔离和自我修复

解耦

### 主要 MQ 产品

RabbitMQ

ActiveMQ

RocketMQ

[Kafka](https://github.com/Simin-hub/Golang-Learning-and-Interview/blob/main/Go/%E5%AE%9E%E6%88%98/Kafka.md)