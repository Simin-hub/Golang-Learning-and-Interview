# 服务流量控制

由于业务应用系统的负载能力有限，为了防止非预期的请求对系统压力过大而拖垮业务应用系统，每个API接口都是有访问上限的。**API接口的流量控制策略：分流、降级、限流等**。本文讨论限流策略，虽然降低了服务接口的访问频率和并发量，却换取服务接口和业务应用系统的高可用。

> **限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理。**

## 限流算法

常用的限流算法有两种：漏桶算法和令牌桶算法。

### 漏桶算法

漏桶算法(Leaky Bucket)是网络世界中流量整形（Traffic Shaping）或速率限制（Rate Limiting）时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。

漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水（接口有响应速率），当水流入速度过大会直接溢出（访问频率超过接口响应速率），然后就拒绝请求，可以看出漏桶算法能强行限制数据的传输速率。示意图如下：



![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/16910727fa61ef72%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A1304%3A0%3A0%3A0.awebp)



因为漏桶的**漏出速率是固定的参数**,所以即使网络中不存在资源冲突（没有发生拥塞），漏桶算法也不能使流突发（burst）到端口速率。因此，**漏桶算法对于存在突发特性的流量来说缺乏效率**。

### 令牌桶算法

令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。

令牌桶算法的原理是系统会以一个**恒定的速度往桶里放入令牌**，而如果请求需要被处理，则需要先从桶里获取一个令牌，**当桶里没有令牌可取时，则拒绝服务**。从原理上看，令牌桶算法和漏桶算法是相反的，一个“进水”，一个是“漏水”。



![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/1691072ad441f3a9%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A1304%3A0%3A0%3A0.awebp)



令牌桶的另外一个好处是可以方便的改变速度。 一旦需要提高速率，则**按需提高放入桶中的令牌的速率**。 一般会定时（比如100毫秒）往桶中增加一定数量的令牌，有些变种算法则实时的计算应该增加的令牌的数量。

### golang.org/x/time/rate

其实 Golang 标准库中就自带了限流算法的实现，即 `golang.org/x/time/rate`。该限流器是基于 Token Bucket(令牌桶) 实现的。


