# 分布式锁

[参考](https://www.51cto.com/article/713305.html)、[参考](https://cloud.tencent.com/developer/article/1621337)、[参考](https://pdai.tech/md/arch/arch-z-lock.html)

### 什么是分布式锁

> 要介绍分布式锁，首先要提到与分布式锁相对应的是线程锁、进程锁。

- **线程锁**：主要用来给方法、代码块加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，比如synchronized是共享对象头，显示锁Lock是共享某个变量（state）。
- **进程锁**：为了控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁。
- **分布式锁**：**当多个进程不在同一个系统中(比如分布式系统中控制共享资源访问)，用分布式锁控制多个进程对资源的访问**。

### 前言

分布式锁是一个在分布式环境中的重要原语，它表明不同进程间采用互斥的方式操作共享资源。常见的场景是作为一个sdk被引入到大型项目中，主要解决两类问题：

- **提升效率：加锁是为了避免不必要的重复处理**。例如防止幂等任务被多个执行者抢占。此时对锁的正确性要求不高；
- **保证正确性：加锁是为了避免Race Condition导致逻辑错误**。例如直接使用分布式锁实现防重，幂等机制。此时如果锁出现错误会引起严重后果，因此对锁的正确性要求高。

分布式应用中，有时我们需要**一个方法在同一时间只能被一个线程执行**。此时我们有可能会使用到分布式锁。

#### 分布式锁的设计原则

> 分布式锁的最小设计原则：**安全性**和**有效性**

[Redis的官网  (opens new window)](https://redis.io/docs/reference/patterns/distributed-locks/)上对使用分布式锁提出至少需要满足如下三个要求：

1. **互斥**（属于安全性）：在任何给定时刻，只有一个客户端可以持有锁。
2. **无死锁**（属于有效性）：即使锁定资源的客户端崩溃或被分区，也总是可以获得锁；通常通过超时机制实现。
3. **容错性**（属于有效性）：只要大多数 Redis 节点都启动，客户端就可以获取和释放锁。

除此之外，分布式锁的设计中还可以/需要考虑：

1. 加锁解锁的**同源性**：A加的锁，不能被B解锁
2. 获取锁是**非阻塞**的：如果获取不到锁，不能无限期等待；
3. **高性能**：加锁解锁是高性能的

分布式锁需要具备以下特征：

- 互斥性同一时刻锁只能被一个线程持有。
- 超时释放超时释放主要是用来避免死锁，防止不必要的线程等待和资源浪费
- 可重入性一个线程在持有锁的情况下，可以再次请求加锁
- 高性能，高可用加锁释放锁的操作尽量使用更少的资源，提高性能。同时也要保证高可用，防止分布式锁意外失效

目前比较多的分布式锁有下面的方案：

- 基于数据库实现分布式锁
- 基于缓存（redis， Hazelcast）等实现分布式锁
- 基于Zookeeper实现分布式锁



### 数据库分布式锁

#### 基于表记录的分布式锁

在**数据库中创建一个锁表**，并且在需要的字段上创建唯一索引，使用锁的时候就插入数据，插入成功则获得锁，执行结束后，就删除数据。也可以加上version控制，使之成为乐观锁。

- 获取锁：成功插入数据
- 执行业务逻辑
- 释放锁：删除数据

#### 基于数据库行锁的分布式锁

使用select * For update来获取数据库数据锁， where之后的条件加入唯一索引，则表示使用了行锁。其分布式锁使用顺序如下。

- 获取锁：SELECT * FROM database_lock WHERE id = 1 FOR UPDATE;。
- 执行业务逻辑。
- 释放锁：COMMIT。

### Zookeeper分布式锁

Zookeepe可以实现分布式锁主要是因为多个线程去Zookpeeper中创建同一个节点时，只有一个线程可以创建成功。

Zookeeper中有临时节点，持久化节点。其中临时节点在服务端session失效后，节点就会被删除。相对而言，持久化节点在服务端session失效后，也不会被删除，而是需要客户端主动删除。

在上述类型系节点之后增加一个数字后缀，即路径+数字后缀，这样可以保证其唯一性和有序性。

其分布式锁实现原理如下：

- 创建一个lock目录给分布式锁使用
- 某个线程想要获取锁就在此目录下创建临时顺序节点
- 获取此目录下的所有子节点，然后查找比自己序号小的节点，如果不存在，则当前线程创建的节点是最小节点，此时获得锁。
- 其他线程想要获取锁，同样是创建临时有序节点，如果是最小序号节点则获得锁，否则监听比自己小的次小节点。
- 持有分布式锁的线程操作完成之后，删除自己的临时节点，次大节点监听到变更事件之后，判断自己是最小序号节点的话，则获得锁。

Zookeeper实现分布式锁具有高可用，可重入，阻塞等特点，由于临时节点在客户端断开的时候就会被自动删除，所以不用担心死锁问题。但是频繁删除和创建节点，性能上会比Redis分布式锁低。

### Redis分布式锁

#### SETNX

setnx命令**只会在key不存在的情况下将key设置为value值**， 其中key和 value值均可以设置成和业务相关的的命名。但是不满足超时释放的要求。

如果使用expire设置过期时间，也有可能在setnx成功后，由于各种原因，expire没有执行成功，从而导致锁不能超时释放。

#### SETNX 扩展命令

复制

```
set key value [EX seconds] [PX milliseconds] [NX|XX]
 #EX 设置过期时间，单位为秒  set lock VALUE EX 10
 #PX 设置过期时间，单位为毫秒 set lock VALUE PX 10000
 #NX key不存在时才设置key的值  set lock VALUE EX 10 NX
 #XX key存在时才设置key SET lock VALUE EX 10 XX1.2.3.4.5.
```

set 扩展命令可以完全取代 SETNX, SETEX, PSETEX 等功能。

可以使用set扩展功能完成设置过期时间, 并且是原子操作。

上述分布式锁也有一些问题：

- 如果线程获取锁之后，执行时间过长，锁提前释放。
- 如果线程A未执行完操作，锁超时释放，此时线程B又获取了锁。线程B持有锁，但是A线程有可能执行DEL操作释放锁。

需要避免在长时间执行的任务中使用上述分布式锁，而且未按时执行完的线程不影响其最终结果。另外可以在锁的value设置一些唯一值，删除key之前验证是否持有锁。并且验证和删除需要使用Lua脚本保证其删除操作的原子性。

上述分布式锁还需要解决一个可重入性的问题。

#### Redisson 分布式锁

Redisson是基于Redis的Java内存数据网格，充分利用了Redis键值数据库提供的一系列优势。同时提供功能丰富的分布式锁。

Resisson内部会有一个监控锁的守护线程，在redisson实例被关闭前，不断延长锁的有效期。并且可以自定义超时检查时间间隔，同时还可以指定加锁时间。另外还支持公平锁（Fair Lock），联锁（MultiLock），红锁（RedLock）,读写锁（ReadWriteLock）以及RSemaphore和RCountDownLatch等类似Java提供的各种多线程工具等。

其中RedLock是基于多个Redis集群关联的锁，可以大大提高锁的可用性及安全性。

关于Redisson，我们后续的文章会继续讲到，尽请期待!



分布式应用中，有时我们需要一个方法在同一时间只能被一个线程执行。此时我们有可能会使用到分布式锁。



### ETCD 分布式锁



