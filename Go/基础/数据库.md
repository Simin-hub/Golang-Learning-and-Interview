# 数据库

# MySQL

[参考](https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md)

## 一、索引

### B+ Tree 原理

[B树](https://github.com/Simin-hub/Golang-Learning-and-Interview/blob/main/Go/%E7%AE%97%E6%B3%95/B%E6%A0%91.md)

#### 1. 数据结构

B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。

[![img](https://camo.githubusercontent.com/4d682f9aa8dd74bd32712b7ca85a85b2c213fd4282d62fcc137488dea23ddde9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33333537363834392d393237352d343762622d616461372d3864656435663565376337332e706e67)](https://camo.githubusercontent.com/4d682f9aa8dd74bd32712b7ca85a85b2c213fd4282d62fcc137488dea23ddde9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33333537363834392d393237352d343762622d616461372d3864656435663565376337332e706e67)



#### 2. 操作

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。

#### 3. 与红黑树的比较

[红黑树](https://github.com/Simin-hub/Golang-Learning-and-Interview/blob/main/Go/%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91.md)

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。

（一）B+ 树有更低的树高

平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。

（二）磁盘访问原理

操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。

如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。

（三）磁盘预读特性

为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。

### MySQL 索引

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

#### 1. B+Tree 索引

是大多数 MySQL 存储引擎的默认索引类型。

因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。

因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。

可以指定多个列作为索引列，多个索引列共同组成键。

适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

InnoDB 的 B+Tree 索引分为**主索引和辅助索引**。**主索引的叶子节点 data 域记录着完整的数据记录**，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

[![img](https://camo.githubusercontent.com/7220f50cca2d4a015b0a23df318b71a4764c6ae8009ba7092938d41045a3cf5b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34353031366539382d363837392d343730392d383536392d3236326232643664363062392e706e67)](https://camo.githubusercontent.com/7220f50cca2d4a015b0a23df318b71a4764c6ae8009ba7092938d41045a3cf5b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34353031366539382d363837392d343730392d383536392d3236326232643664363062392e706e67)



**辅助索引的叶子节点的 data 域记录着主键的值**，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

[![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37633334396239312d303530622d346437322d613766382d6563383633323033303765612e706e67)](https://camo.githubusercontent.com/4c90ec27dc7dacdb350c31ab4f072685538f1c89dfc4362750fdfa0ca85e7622/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37633334396239312d303530622d346437322d613766382d6563383633323033303765612e706e67)



#### 2. 哈希索引

哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

**InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引**，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

#### 3. 全文索引

**MyISAM 存储引擎支持全文索引**，用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

#### 4. 空间数据索引

MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。

### 索引优化

#### 1. 独立的列

**在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引**。

例如下面的查询不能使用 actor_id 列的索引：

```
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

#### 2. 多列索引

在需要**使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好**。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

```
SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
```

#### 3. 索引列的顺序

让**选择性最强的索引列放在前面**。

**索引的选择性是指：不重复的索引值和记录总数的比值**。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

```
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
```

#### 4. 前缀索引

对于 BLOB、TEXT 和 VARCHAR 类型的列，**必须使用前缀索引，只索引开始的部分字符**。

前缀长度的选取需要根据索引选择性来确定。

#### 5. 覆盖索引

索引包含所有需要查询的字段的值。

具有以下优点：

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

### 索引的优点

- 大大减少了服务器需要扫描的数据行数。
- 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
- 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

### 索引的使用条件

- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
- 对于中到大型的表，索引就非常有效；
- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

## 二、查询性能优化

### 使用 Explain 进行分析

Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。

比较重要的字段有：

- select_type : 查询类型，有简单查询、联合查询、子查询等
- key : 使用的索引
- rows : 扫描的行数

### 优化数据访问

#### 1. 减少请求的数据量

- 只返回必要的列：最好不要使用 SELECT * 语句。
- 只返回必要的行：使用 LIMIT 语句来限制返回的数据。
- 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。

#### 2. 减少服务器端扫描的行数

最有效的方式是使用索引来覆盖查询。

### 重构查询方式

#### 1. 切分大查询

一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

```
DELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);
rows_affected = 0
do {
    rows_affected = do_query(
    "DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")
} while rows_affected > 0
```

#### 2. 分解大连接查询

将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：

- 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
- 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
- 减少锁竞争；
- 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
- 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。

```
SELECT * FROM tag
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';
SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
```

## 三、存储引擎

### InnoDB

是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。

**主索引是聚簇索引**，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

#### InnoDB 存储引擎的特点

自从 MySQL5.1 之后，默认的存储引擎变成了 InnoDB 存储引擎，相对于 MylSAM，InnoDB 存储引擎有了较大的改变，它的主要特点是 

- 支持事务操作，具有事务 ACID 隔离特性，**默认的隔离级别是可重复读** (repetable-read)、通过 MVCC(并发版本控制)来实现的。能够解决 脏读 和 不可重复读 的问题。 
- InnoDB 支持外键操作。 
- InnoDB 默认的锁粒度行级锁，并发性能比较好，会发生死锁的情况。 
- 和 MyISAM 一样的是，InnoDB 存储引擎也有 frm 文件存储表结构定义，但是不同的是，**InnoDB 的表数据与索引数据是存储在一起的**，都位于 B+数的叶 子节点上，而 MylSAM 的表数据和索引数据是分开的。 
- InnoDB **有安全的日志文件，**这个日志文件用于恢复因数据库崩溃或其他情况导致的数据丢失问题，保证数据的一致性。
- InnoDB 和 MylSAM 支持的索引类型相同，但具体实现因为文件结构的不同有 很大差异。
- 增删改查性能方面，果执行大量的增删改操作，推荐使用 InnoDB 存储引 擎，它在删除操作时是对行删除，不会重建表。

### MyISAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

不支持事务。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

#### MyISAM 存储引擎的特点 

在 5.1 版本之前，MyISAM 是 MySQL 的默认存储引擎，MylSAM 并发性比较差，使用的场景比较少主要特点是: 

- **不支持事务操作**，ACID 的特性也就不存在了，这一设计是为了性能和效率 考虑的， 
- **不支持外键操作**，如果强行增加外键，MySQL 不会报错，只不过外键不起作 用。 
- MyISAM 默认的锁粒度是**表级锁**，所以并发性能比较差，加锁比较快，锁冲 突比较少，不太容易发生死锁的情况。
- MyISAM 会在磁盘上**存储三个文件**，文件名和表名相同，扩展名分别是 frm(**存储表定义**)、MYD(MYData，**存储数据**)、MYI(MyIndex，**存储索引**)。 这里需要特别注意的是 MyISAM 只缓存索引文件，并不缓存数据文件。
-  MyISAM 支持的索引类型有全局索引(Full-Text)、B-Tree 索引、R-Tree 索 引 
  - Full-Text 索引:它的出现是为了解决针对文本的模糊查询效率较低的 问题。
  - B-Tree 索引:所有的索引节点都按照平衡树的数据结构来存储，所有的 索引数据节点都在叶节点
  - R-Tree 索引:它的存储方式和 B-Tree 索引有一些区别，主要设计用于 存储空间和多维数据的字段做索引目前的 MySQL 版本仅支持 geometry 类型的字段作索引，相对于 BTREE,RTREE 的优势在于范围查找。
- 数据库所在主机如果宕机，MyISAM 的数据文件容易损坏，而且难以恢复。
- 增删改查性能方面:SELECT 性能较高，适用于查询较多的情况

### 比较

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：**MyISAM 只支持表级锁，而 InnoDB 还支持行级锁**。
- 外键：InnoDB 支持外键。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。

## 四、数据类型

### 整型

TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。

INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。

### 浮点数

FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。

FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。

### 字符串

主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。

VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。

### 时间和日期

MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。

#### 1. DATETIME

能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。

它与时区无关。

默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。

#### 2. TIMESTAMP

和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。

它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。

MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。

默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。

应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。

## 五、切分

### 水平切分

水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。

当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。

[![img](https://camo.githubusercontent.com/29dbc15634de8e798e7ed68f50fd898b923a5fd9ac6fd2a271af9bdd84e96167/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36336332393039662d306335662d343936662d396665352d6565393137366233316162612e6a7067)](https://camo.githubusercontent.com/29dbc15634de8e798e7ed68f50fd898b923a5fd9ac6fd2a271af9bdd84e96167/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36336332393039662d306335662d343936662d396665352d6565393137366233316162612e6a7067)



### 垂直切分

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。

[![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65313330653562382d623139612d346631652d623836302d3232333034303532356366362e6a7067)](https://camo.githubusercontent.com/eb35b961164a9f970ee6e1da5b6eeefb5610619553494efa9b0a5007524c99d6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65313330653562382d623139612d346631652d623836302d3232333034303532356366362e6a7067)



### Sharding 策略

- 哈希取模：hash(key) % N；
- 范围：可以是 ID 范围也可以是时间范围；
- 映射表：使用单独的一个数据库来存储映射关系。

### Sharding 存在的问题

#### 1. 事务问题

使用分布式事务来解决，比如 XA 接口。

#### 2. 连接

可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。

#### 3. ID 唯一性

- 使用全局唯一 ID（GUID）
- 为每个分片指定一个 ID 范围
- 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)

## 六、复制

### 主从复制

主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

- **binlog 线程** ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
- **I/O 线程** ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
- **SQL 线程** ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

[![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6d61737465722d736c6176652e706e67)](https://camo.githubusercontent.com/e07852d09597a9cfb719ce91e616208a17543d401a114e07ebe6e4d49e2f7dff/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6d61737465722d736c6176652e706e67)



### 读写分离

**主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。**

读写分离能提高性能的原因在于：

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

[![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6d61737465722d736c6176652d70726f78792e706e67)](https://camo.githubusercontent.com/7f9279aeb3dd23a8a0a64895594bd76ac9fce2dfb6bc24974a07cc83888c6fc9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6d61737465722d736c6176652d70726f78792e706e67)

## 面试题

[参考](https://segmentfault.com/a/1190000040112777)

[参考2](https://blog.51cto.com/wangshiyu/4874168)

### ACID

**ACID**，是指[数据库管理系统](https://zh.wikipedia.org/wiki/数据库管理系统)（[DBMS](https://zh.wikipedia.org/wiki/DBMS)）在写入或更新资料的过程中，为保证[事务](https://zh.wikipedia.org/wiki/数据库事务)（transaction）是正确可靠的，所必须具备的四个特性：[原子性](https://zh.wikipedia.org/w/index.php?title=原子性&action=edit&redlink=1)（atomicity，或称不可分割性）、[一致性](https://zh.wikipedia.org/wiki/一致性_(数据库))（consistency）、[隔离性](https://zh.wikipedia.org/wiki/隔離性)（isolation，又称独立性）、[持久性](https://zh.wikipedia.org/wiki/持久性)（durability）。

在数据库系统中，一个事务是指：由一系列数据库操作组成的一个完整的逻辑过程。例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。这个过程被称为一个事务，具有ACID特性。ACID的概念在[ISO](https://zh.wikipedia.org/wiki/ISO)/IEC 10026-1:1992文件的第四段内有所说明。

- 原子性（Atomicity）：**一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成**，不会结束在中间某个环节。事务在执行过程中发生错误，会被[回滚](https://zh.wikipedia.org/wiki/回滚_(数据管理))（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。[[1\]](https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1)
- [一致性](https://zh.wikipedia.org/wiki/一致性_(数据库))（Consistency）：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏**。这表示写入的资料必须完全符合所有的预设[约束](https://zh.wikipedia.org/wiki/数据完整性)、[触发器](https://zh.wikipedia.org/wiki/触发器_(数据库))、[级联回滚](https://zh.wikipedia.org/wiki/级联回滚)等。[[1\]](https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1)
- [事务隔离](https://zh.wikipedia.org/wiki/事務隔離)（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。[[1\]](https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1)
- [持久性](https://zh.wikipedia.org/wiki/持久性)（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。[[1\]](https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1)

### 三大范式

**1．第一范式(确保每列保持原子性)**

每个列都不可以再拆分

**2．第二范式(确保表中的每列都和主键相关)**

在第一范式的基础上，非主键列完全依赖于主键，而不能是依 赖于主键的一部分。

**3．第三范式(确保每列都和主键列直接相关,而不是间接相关)**

在第二范式的基础上，非主键列只依赖于主键，不依赖于其他 非主键。

在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够 的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。

### MySQL 有关权限的表都有哪几个？

MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 MySQL 数 据库里，由 mysql_install_db 脚本初始化。这些权限表分别 **user，db， table_priv，columns_priv 和 host**。下面分别介绍一下这些表的结构和内容： 

- user 权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局 级的。 
- db 权限表：记录各个帐号在各个数据库上的操作权限。 
- table_priv 权限表：记录数据表级的操作权限。 
- columns_priv 权限表：记录数据列级的操作权限。
-  host 权限表：配合 db 权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受 GRANT 和 REVOKE 语句的影响。

### MySQL 的 Binlog 有有几种录入格式？

分别有什么区别？ 有三种格式statement，row 和 mixed。 

- statement 模式下，**每一条会修改数据的 SQL 都会记录在 Binlog 中**。不需要记录每一行的变化，减少了 Binlog 日志量，节约了 IO，提高性能。由于 sql 的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。 
- row 级别下，**不记录 SQL 语句上下文相关信息，仅保存哪条记录被修改。**记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如 alter table)，因此这种模式的文件保存的信息太 多，日志量太大。 
- mixed，一种折中的方案，普通操作使用 statement 记录，当无法使用 statement 的时候使用 row。

### MySQL 存储引擎 MyISAM 与 InnoDB 区别

- **锁粒度方面**：由于锁粒度不同，InnoDB 比 MyISAM 支持更高的并发;**InnoDB  的锁粒度为行锁**、**MyISAM 的锁粒度为表锁**、行锁需要对每一行进行加锁， 所以锁的开销更大，但是能解决脏读和不可重复读的问题，相对来说也更 容易发生死锁 
- 可恢复性上：**由于 InnoDB 是有事务日志的**，所以在产生由于数据库崩溃等条件后，可以根据日志文件进行恢复。而 MyISAM 则没有事务日志。
- 查询性能上:MylSAM 要优于 InnoDB。因为 InnoDB 在查询过程中，是需要维护数据缓存，而且查询过程是先定位到行所在的数据块，然后在从数据块中 定位到要查找的行;而 **MyISAM 可以直接定位到数据所在的内存地址**，可以 直接找到数据。 
- 表结构文件上:MyISAM 的表结构文件包括:frm(表结构定义),.MYI(索 引),.MYD(数据);而 InnoDB 的表数据文件为:ibd 和 frm(表结构定义)。

### MyISAM 索引与 InnoDB 索引的区别？

- InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。 
-  InnoDB 的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
-  **MyISAM 索引的叶子节点存储的是行数据地址**，需要再寻址一次才能得到数据。 
- InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此 查询时做到覆盖索引会非常高效。

### 什么是索引？ 

**索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)**，**它们包含着对数据表里所有记录的引用指针**。 **索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据**。索引的实现通常使用 B 树及其变 种 B+树。 更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立 索引形成目录。索引是一个文件，它是要占据物理空间的。

### 索引有哪些优缺点？

 索引的优点  

- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 
- 通过使用索引，可以在查询的过程中，**使用优化隐藏器**，提高系统的性能。 

索引的缺点  

- 时间方面：**创建索引和维护索引要耗费时间**，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执 行效率； 
- 空间方面：**索引需要占物理空间**。

### 索引的使用场景

- where
  ![img](https://segmentfault.com/img/remote/1460000040112783)

上图中，根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。

```sql
-- 增加一个没有建立索引的字段
alter table innodb1 add sex char(1);
-- 按sex检索时可选的索引为null
EXPLAIN SELECT * from innodb1 where sex='男';
```

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/1460000040112784)

可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（alter table 表名 add index(字段名)），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。

- order by

当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么**执行计划会将查询出的所有数据使用外部排序**（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。

但是如果我们对该字段建立索引alter table 表名 add index(字段名)，那么**由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可**。而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）

- join

**对join语句匹配关系（on）涉及的字段建立索引能够提高效率**

- 索引覆盖

如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则**只要有一个字段没有建立索引就会做全表扫描**），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。

这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。

### 索引有哪几种类型？ 

**主键索引**:  数据列不允许重复，不允许为 NULL，一个表只能有一个主键。 

**唯一索引**:  数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。 

- 可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索 引。 
- 可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引。 

**普通索引**:  基本的索引类型，没有唯一性的限制，允许为 NULL 值。 

⚫ 可以通过 ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引 

⚫ 可以通过 ALTER TABLE table_name ADD INDEX index_name(column1,  column2, column3);创建组合索引。 

**全文索引**：  是目前搜索引擎使用的一种关键技术。 

⚫ 可以通过 ALTER TABLE table_name ADD FULLTEXT (column);创建全文索 引。

### MySQL 中有哪几种锁？ 

从锁的粒度分：

- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

从锁的类别分：

- 共享锁: 又叫做**读锁**。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。
- 排他锁: 又叫做**写锁**。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。

### MySQL中InnoDB引擎的行锁是怎么实现的？

答：InnoDB是基于索引来完成行锁

```n1ql
例: select * from tab_with_index where id = 1 for update;
```

for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起

###### InnoDB存储引擎的锁的算法有三种

- Record lock：单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record+gap 锁定一个范围，包含记录本身

###### 相关知识点：

- innodb对于行的查询使用next-key lock
- Next-locking keying为了解决Phantom Problem幻读问题
- 当查询的索引含有唯一属性时，将next-key lock降级为record key
- Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
- 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1

### 什么是死锁？怎么解决？

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

常见的解决死锁的方法

- 1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
- 2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
- 3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

如果业务处理不好可以用分布式事务锁或者使用乐观锁

### 数据库的乐观锁和悲观锁是什么？怎么实现的？

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。

###### 两种锁的使用场景

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。

但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

### 什么是脏读？幻读？不可重复读？

脏读(Drity Read)：**某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的**。

不可重复读(Non-repeatable read):在**一个事务的两次查询之中数据不一致**，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

幻读(Phantom Read):**在一个事务的两次查询中数据笔数不一致**，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

### MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？ 

为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/1460000040112791)

SQL 标准定义了四个隔离级别：

- READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别

事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。

InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别

### 隔离级别与锁的关系

在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突

在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；

在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。

SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。

### char 和 varchar 的区别？ 

char 和 varchar 类型在**存储和检索方面**有所不同 

- **char的长度是不可变的，而varchar的长度是可变的**
- char **列长度固定为创建表时声明的长度**，长度值范围是 1 到 255
- 当 char 值被存储时，**它们被用空格填充到特定长度**，检索 char 值时需删除尾随空格。
- **char的存取速度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。**

char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。**varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。**

**两者的存储数据都非unicode的字符数据。**

**nchar和nvarchar是存储的unicode字符串数据**

### 主键和候选键有什么区别？

 表格的每一行都由主键唯一标识,一个表只有一个主键。 主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外 键引用。

### 如何在 Unix 和 MySQL 时间戳之间进行转换？ 

UNIX_TIMESTAMP 是从 MySQL 时间戳转换为 Unix 时间戳的命令

 FROM_UNIXTIME 是从 Unix 时间戳转换为 MySQL 时间戳的命令。

### MyISAM 表类型将在哪里存储，并且还提供其存储格式？

 每个 MyISAM 表格以三种格式存储在磁盘上： 

- “.frm”文件 **存储表定义** 
- 数据文件具有“.MYD”（MYData）扩展名 
- 索引文件具有“.MYI”（MYIndex）扩展名

### MySQL 里记录货币用什么字段类型好

NUMERIC 和 DECIMAL 类型被 MySQL 实现为同样的类型，这在 SQL92 标准允许。 他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数 据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定。 

例如： salary DECIMAL(9,2)

在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。 因此，在这种情况下，能被存储在 salary 列中的值的范围是从-9999999.99 到 9999999.99。

### 创建索引时需要注意什么？ 

- **非空字段**：应该指定列为 NOT NULL，除非你想存储 NULL。在 MySQL 中，**含有空值的列很难进行查询优化**，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用 0、一个特殊的值或者一个空串代替空值； 
- **取值离散大的字段**：（变量各个取值之间的差异程度）的列放到联合索引 的前面，可以通过 count()函数查看字段的差异值，返回值越大说明字段的**唯一值越多字段的离散程度高**； 
- **索引字段越小越好**：数据库的数据存储以页为单位一页存储的数据越多一 次 I/O 操作获取的数据越大效率越高。
- 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
- 较频繁作为查询条件的字段才去创建索引
- **更新频繁字段不适合创建索引**
- 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
- 定义有外键的数据列一定要建立索引。
- 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。

### 使用索引查询一定能提高查询的性能吗？为什么 

通常，**通过索引查询数据比全表扫描要快**。但是我们也必须注意到它的代价。 **索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改**。 这意味着每条记录的 INSERT，DELETE，UPDATE 将为此多付出 4，5 次的磁盘 I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。

**使用索引查询不一定能提高查询性能**，索引范围查询(INDEX RANGE SCAN)适用于两种情况: 

- 基于一个范围的检索，一般查询返回结果集小于表中记录数的 30% 
- 基于非唯一性索引的检索

### 百万级别或以上的数据如何删除 

关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所 以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的 IO,会降低增/改/删的执行效率。所以，在我们删除数据库 百万级别数据的时候，查询 MySQL 官方手册得知**删除数据的速度和创建的索引数量是成正比的**。 

- 所以我们想要删除百万数据的时候可以**先删除索引**（此时大概耗时三分多 钟） 
- 然后**删除其中无用数据**（此过程需要不到两分钟） 
- **删除完成后重新创建索引**(此时数据较少了)创建索引也非常快，约十分钟 左右。 
- 与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。

### 什么是最左前缀原则？什么是最左匹配原则

顾名思义，就是**最左优先，在创建多列索引时，要根据业务需求，where 子句中使用最频繁的一列放在最左边**。

 最左前缀匹配原则，非常重要的原则，**MySQL 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配**，比如 a = 1 and b = 2 and c > 3 and  d = 4 如果建立(a,b,c,d)顺序的索引，d 是用不到索引的，如果建立 (a,b,d,c)的索引则都可以用到，a,b,d 的顺序可以任意调整。 =和 in 可以乱序，比如 a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任 意顺序，MySQL 的查询优化器会帮你优化成索引可以识别的形式。

### 什么是聚簇索引？

何时使用聚簇索引与非聚簇索引 

- 聚簇索引：**将数据存储与索引放到了一块，找到索引也就找到了数据** 
- 非聚簇索引：将数据存储于索引分开结构，索引结构的**叶子节点指向了数据的对应行**，myisam 通过 key_buffer 把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找 到磁盘相应数据，这也就是为什么索引不在 key buffer 命中时，速度慢的原因。

### MySQL 连接器

首先需要在 MySQL 客户端登陆才能使用，所以**需要个连接器来连接用户和 MySQL 数据库**，我们 一般是使用 

```
mysql-u 用户名-p 密码
```

来进行 MySQL 登陆，和服务端建立连接。在完成 TCP 握手后，连接器会根据你输入的用户名和密码验证你的登录身份。如果用户名或者密码错误，MySQL 就 会提示 Access denied for user，来结束执行。如果登录成功后，MySQL 会根据权限表中的记录来判定你的权限。

### MySQL 查询缓存

连接完成后，你就可以执行 SQL 语句了，这行逻辑就会来到第二步:**查询缓存**。 MySQL 在得到一个执行请求后，会**首先去查询缓存 中查找，是否执行过这条 SQL 语句，之前执行过的语句以及结果会以 key-value 对的形式，被直接放在内存中**。key 是查询语句，value 是查询的结果。 

如果通过 key 能够查找到这条 SQL 语句，就直接妾返回 SQL 的执行结果。

如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果就会被放入查询缓存中。 可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，效率会很高。

### MySQL 分析器

如果没有命中查询，就开始执行真正的 SQL 语句。

- 首先，**MySQL 会根据你写的 SQL 语句进行解析**，分析器会先做**词法分析**，你写的 SQL 就是由多个字符串和空格组成的一条 SQL 语句，MySQL **需要识别出里面的字符串是什么，代表什么**。 
- 然后**进行语法分析**，根据词法分析的结果，**语法分析器会根据语法规则， 判断你输入的这个 SQL 语句是否满足 MySQL 语法**。如果 SQL 语句不正确， 就会提示 You have an error in your SQL syntax。

### MySQL 优化器

经过分析器的词法分析和语法分析后，你这条 SQL 就合法了，MySQL 就知道你要做什么了。但是在执行前，还需要进行优化器的处理，**优化器会判断你使用了哪种索引，使用了何种连接，优化器的作用就是确定效率最高的执行方案**。

### MySQL 执行器

MySQL 通过分析器知道了你的 SQL 语句是否合法，你想要做什么操作，通过优化器知道了该怎么做效率最高，然后就进入了执行阶段，开始执行这条 SQL 语 句在执行阶段，**MySQL 首先会判断你有没有执行这条语句的权限**，没有权限的话，就会返回没有权限的错误。如果有权限，就打开表继续执行。打开表的时候，**执行器就会根据表的引擎定义，去使用这个引擎提供的接口**。对于有索引 的表，执行的逻辑也差不多。

### 什么是临时表，何时删除临时表？

 什么是临时表?

MySQL 在执行 SQL 语句的过程中 通常会**临时创建一些存储中间结果集的表**，**临时表只对当前连接可见**，**在连接关闭时，临时表会被删除并释放所有表空间**。

 临时表分为两种:**一种是内存临时表，一种是磁盘临时表**，什么区别呢?内存临时表使用的是 MEMORY 存储引擎，而临时表采用的是 MylSAM 存储引擎。 

MySQL 会在下面这几种情况产生临时表。 

- **使用 UNION 查询**:UNION 有两种，一种是 UNION，一种是 UNION ALL，它们都用于**联合查询**;区别是使用 UNION 会去掉两个表中的重复数据，相当于对结果集做了一下去重(distinct)。使用 UNIONALL，则不会排重，返回所有的行。使用 UNION 查询会产生临时表。 
- **使用 TEMPTABLE 算法或者是 UNION 查询中的视图**。TEMPTABLE 算法是一种创建临时表的算法，它是将结果放置到临时表中，意味这要 MySQL 要先创建 好一个临时表，然后将结果放到临时表中去，然后再使用这个临时表进行 相应的查询。
- **ORDER BY 和 GROUPBY 的子句不一样时也会产生临时表。** 
- DISTINCT 查询并且加上 ORDER BY 时; 
- SQL 中用到 SQL_SMALL_RESULT 选项时;如果查询结果比较小的时候，可以加 上 SQL SMALL RESULT 来优化，产生临时表 
- FROM 中的子查询; 
- EXPLAIN 查看执行计划结果的 Extra 列中，如果使用 Using Temporary 就 表示会用到临时表。

### 谈谈 SQL 优化的经验

- 查询语句无论是使用哪种判断条件等于、小于、大于，**WHERE 左侧的条件查询字段不要使用函数或者表达式** 
- **使用 EXPLAIN 命令优化你的 SELECT 查询**，对于复杂、效率低的 SQL 语 句，我们通常是使用 explainsql 来分析这条 SQL 语句，这样方便我们分 析，进行优化。
- **+当你的 SELECT 查询语句只需要使用一条记录时，要使用 LIMIT 1**。**不要直接使用 SELECT***，而应该使用具体需要查询的表字段，因为使用 EXPLAIN 进行分析时，SELECT * 使用的是全表扫描，也就是 type =all 。
- **为每一张表设置一个 ID 属性**。 
- 避免在 WHERE 字句中对字段进行 NULL  
- **判断避免在 WHERE 中使用!或>操作符** 
- **使用 BETWEEN AND 替代 IN** 
- 为搜索字段创建索引 
- 选择正确的存储引擎，InnoDB、MyISAM、MEMORY 等
- **使用 LIKE%abc%不会走索引**，而使用 LIKE abc%会走索引。
- **对于枚举类型的字段(即有固定罗列值的字段)，建议使用 ENUM 而不是 VARCHAR**，如性别、星期、类型、类别等。
- **拆分大的 DELETE 或 INSERT 语句** 
- 选择合适的字段类型，**选择标准是尽可能小、尽可能定长、尽可能使用整数**。
- 字段设计尽可能使用 NOT NULL 
- **进行水平切割或者垂直分割**

### 什么叫外链接？ 

外连接分为三种，分别是是**左外连接(**LEFT OUTER J0IN 或 LEFT JOIN 

**右外连接**(RIGHT OUTER JOIN 或 RIGHT JOIN、

全外连接(FULL OUTER JOIN  或 FULLJOIN)。 

左外连接:又称为左连接，这种连接方式会显示左表不符合条件的数据行，右边不符合条件的数据行直接显示 NULL。 

右外连接:也被称为右连接，他与左连接相对，这种连接方式会显示右表不符合条件的数据行，左表不符合条件的数据行直接显示 NULL。

### 什么叫内链接？

结合两个表中相同的字段，返回关联字段相符的记录就是内链接。

![image-20220421165719026](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220421165719026.png)

### 使用 union 和 union all 时需要注意些什么？ 

通过 union 连接的 SQL 分别**单独取出的列数必须相同**。 使用 union 时，**多个相等的行将会被合并**，由于合升比较耗时，一般不直接使用 union 进行合并，而是通常采用 union all 进行合并。



# MongoDB

[参考](https://docs.mongoing.com/)



## 面试题

[参考](https://juejin.cn/post/6844904186300071943)

### 1、mongodb是什么？

MongoDB 是由 C++语言编写的，是一个基于分布式文件存储的开源数据库系统。 再高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB 旨在给 WEB 应用提供可扩展的高性能数据存储解决方案。

MongoDB 将数据存储为一个文档，数据结构由键值(key=>value)对组成。 MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/172a279a2bbf60c4%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A1304%3A0%3A0%3A0.awebp)

### 2、mongodb有哪些特点？

（1）MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。

（2）你可以在 MongoDB 记录中设置任何属性的索引 (如： FirstName="Sameer",Address="8 Gandhi Road")来实现更快的排序。

（3）你可以通过本地或者网络创建数据镜像，这使得 MongoDB 有更强的扩展性。

（4）如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。

（5）Mongo 支持丰富的查询表达式。查询指令使用 JSON 形式的标记，可轻易查询文档中内嵌的对象及数组。

（6）MongoDb 使用 update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。

（7）Mongodb 中的 Map/reduce 主要是用来对数据进行批量处理和聚合操作。

（8）Map 和 Reduce。 Map 函数调用 emit(key,value)遍历集合中所有的记录，将 key 与 value 传给 Reduce 函数进行处理。

（9）Map 函数和 Reduce 函数是使用 Javascript 编写的，并可以通过 db.runCommand 或 mapreduce 命令来执行 MapReduce 操作。

（10）GridFS 是 MongoDB 中的一个内置功能，可以用于存放大量小文件。

（11） MongoDB 允许在服务端执行脚本， 可以用 Javascript 编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。

### 3、你说的NoSQL数据库是什么意思?NoSQL与RDBMS直接有什么区别?为什么要使用和不使用NoSQL数据库?说一说NoSQL数据库的几个优点?

NoSQL是非关系型数据库，NoSQL = Not Only SQL。

关系型数据库采用的结构化的数据，NoSQL采用的是键值对的方式存储数据。

在处理非结构化/半结构化的大数据时；在水平方向上进行扩展时；随时应对动态增加的数据项时可以优先考虑使用NoSQL数据库。

再考虑数据库的成熟度；支持；分析和商业智能；管理及专业性等问题时，应优先考虑关系型数据库。

### 4、NoSQL数据库有哪些类型?

NoSQL数据库的类型

例如：MongoDB, Cassandra, CouchDB, Hypertable, Redis, Riak,  HBASE, Memcache

### 5、MySQL与MongoDB之间最基本的差别是什么?

MySQL和MongoDB两者都是免费开源的数据库。MySQL和MongoDB有许多基本差别包括数据的表示(data representation)，查询，关系，事务，schema的设计和定义，标准化(normalization)，速度和性能。

通过比较MySQL和MongoDB，实际上我们是在比较关系型和非关系型数据库，即数据存储结构不同。

### 6、你怎么比较MongoDB、CouchDB及CouchBase?

MongoDB和CouchDB都是面向文档的数据库。MongoDB和CouchDB都是开源NoSQL数据库的最典型代表。 除了都以文档形式存储外它

们没有其他的共同点。MongoDB和CouchDB在数据模型实现、接口、对象存储以及复制方法等方面有很多不同。

### 7、MongoDB成为最好NoSQL数据库的原因是什么?

以下特点使得MongoDB成为最好的NoSQL数据库：

- 面向文件的
- 高性能
- 高可用性
- 易扩展性
- 丰富的查询语言

### 8、journal回放在条目(entry)不完整时(比如恰巧有一个中途故障了)会遇到问题吗?

每个journal (group)的写操作都是一致的，除非它是完整的否则在恢复过程中它不会回放。

### 9、分析器在MongoDB中的作用是什么?

MongoDB中包括了一个可以显示数据库中每个操作性能特点的数据库分析器。通过这个分析器你可以找到比预期慢的查询(或写操作);利用这一信息，比如，可以确定是否需要添加索引。

### 10、名字空间(namespace)是什么?

MongoDB存储BSON对象在丛集(collection)中。数据库名字和丛集名字以句点连结起来叫做名字空间(namespace)。

### 11、 如果用户移除对象的属性，该属性是否从存储层中删除?

是的，用户移除属性然后对象会重新保存(re-save())。

### 12、能否使用日志特征进行安全备份?

是的。

### 13、允许空值null吗?

对于对象成员而言，是的。然而用户不能够添加空值(null)到数据库丛集(collection)因为空值不是对象。然而用户能够添加空对象{}。

### 14、更新操作立刻fsync到磁盘?

不会，磁盘写操作默认是延迟执行的。写操作可能在两三秒(默认在60秒内)后到达磁盘。例如，如果一秒内数据库收到一千个对一个对象递增的操作，仅刷新磁盘一次。(注意，尽管fsync选项在命令行和经过getLastError_old是有效的)

### 15、如何执行事务/加锁?

MongoDB没有使用传统的锁或者复杂的带回滚的事务，因为它设计的宗旨是轻量，快速以及可预计的高性能。可以把它类比成MySQLMylSAM的自动提交模式。通过精简对事务的支持，性能得到了提升，特别是在一个可能会穿过多个服务器的系统里。

### 16、为什么我的数据文件如此庞大?

MongoDB会积极的预分配预留空间来防止文件系统碎片。

### 17、启用备份故障恢复需要多久?

从备份数据库声明主数据库宕机到选出一个备份数据库作为新的主数据库将花费10到30秒时间。这期间在主数据库上的操作将会失败--包括

写入和强一致性读取(strong consistent read)操作。然而，你还能在第二数据库上执行最终一致性查询(eventually consistent query)(在slaveOk模式下)，即使在这段时间里。

### 18、什么是master或primary?

它是当前备份集群(replica set)中负责处理所有写入操作的主要节点/成员。在一个备份集群中，当失效备援(failover)事件发生时，一个另外的成员会变成primary。

### 19、什么是secondary或slave?

Seconday从当前的primary上复制相应的操作。它是通过跟踪复制oplog(local.oplog.rs)做到的。

### 20、我必须调用getLastError来确保写操作生效了么?

不用。不管你有没有调用getLastError(又叫"Safe Mode")服务器做的操作都一样。调用getLastError只是为了确认写操作成功提交了。当然，你经常想得到确认，但是写操作的安全性和是否生效不是由这个决定的。

### 21、我应该启动一个集群分片(sharded)还是一个非集群分片的 MongoDB 环境?

为开发便捷起见，我们建议以非集群分片(unsharded)方式开始一个 MongoDB 环境，除非一台服务器不足以存放你的初始数据集。从非集群分片升级到集群分片(sharding)是无缝的，所以在你的数据集还不是很大的时候没必要考虑集群分片(sharding)。

### 22、分片(sharding)和复制(replication)是怎样工作的?

每一个分片(shard)是一个分区数据的逻辑集合。分片可能由单一服务器或者集群组成，我们推荐为每一个分片(shard)使用集群。

### 23、数据在什么时候才会扩展到多个分片(shard)里?

MongoDB 分片是基于区域(range)的。所以一个集合(collection)中的所有的对象都被存放到一个块(chunk)中。只有当存在多余一个块的时后，才会有多个分片获取数据的选项。现在，每个默认块的大小是 64Mb，所以你需要至少 64 Mb 空间才可以实施一个迁移。

### 24、当我试图更新一个正在被迁移的块(chunk)上的文档时会发生什么?

更新操作会立即发生在旧的分片(shard)上，然后更改才会在所有权转移(ownership transfers)前复制到新的分片上。

### 25、如果在一个分片(shard)停止或者很慢的时候，我发起一个查询会怎样?

如果一个分片(shard)停止了，除非查询设置了“Partial”选项，否则查询会返回一个错误。如果一个分片(shard)响应很慢，MongoDB则会等待它的响应。

### 26、我可以把moveChunk目录里的旧文件删除吗?

没问题，这些文件是在分片(shard)进行均衡操作(balancing)的时候产生的临时文件。一旦这些操作已经完成，相关的临时文件也应该被删除掉。但目前清理工作是需要手动的，所以请小心地考虑再释放这些文件的空间。

### 27、我怎么查看 Mongo 正在使用的链接?

db._adminCommand("connPoolStats");

### 28、如果块移动操作(moveChunk)失败了，我需要手动清除部分转移的文档吗?

不需要，移动操作是一致(consistent)并且是确定性的(deterministic);一次失败后，移动操作会不断重试;当完成后，数据只会出现在新的分片里(shard)。

### 29、如果我在使用复制技术(replication)，可以一部分使用日志(journaling)而其他部分则不使用吗?

可以。

### 30、当更新一个正在被迁移的块（Chunk）上的文档时会发生什么？

更新操作会立即发生在旧的块（Chunk）上，然后更改才会在所有权转移前复制到新的分片上。

### 31、MongoDB在A:{B,C}上建立索引，查询A:{B,C}和A:{C,B}都会使用索引吗？

不会，只会在A:{B,C}上使用索引。

### 32、如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？

如果一个分片停止了，除非查询设置了“Partial”选项，否则查询会返回一个错误。如果一个分片响应很慢，MongoDB会等待它的响应。

### 33、MongoDB支持存储过程吗？如果支持的话，怎么用？

MongoDB支持存储过程，它是javascript写的，保存在db.system.js表中。

### 34、如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？

GridFS是一种将大型文件存储在MongoDB中的文件规范。使用GridFS可以将大文件分隔成多个小文档存放，这样我们能够有效的保存大文档，而且解决了BSON对象有限制的问题。

### 35、什么是NoSQL数据库？NoSQL和RDBMS有什么区别？在哪些情况下使用和不使用NoSQL数据库？

NoSQL是非关系型数据库，NoSQL = Not Only SQL。

关系型数据库采用的结构化的数据，NoSQL采用的是键值对的方式存储数据。

在处理非结构化/半结构化的大数据时；在水平方向上进行扩展时；随时应对动态增加的数据项时可以优先考虑使用NoSQL数据库。

在考虑数据库的成熟度；支持；分析和商业智能；管理及专业性等问题时，应优先考虑关系型数据库。

### 36、MongoDB支持存储过程吗？如果支持的话，怎么用？

MongoDB支持存储过程，它是javascript写的，保存在db.system.js表中。

### 37、如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？

GridFS是一种将大型文件存储在MongoDB中的文件规范。使用GridFS可以将大文件分隔成多个小文档存放，这样我们能够有效的保存大文档，而且解决了BSON对象有限制的问题。

### 38、为什么MongoDB的数据文件很大？

MongoDB采用的预分配空间的方式来防止文件碎片。

### 39、当更新一个正在被迁移的块（Chunk）上的文档时会发生什么？

更新操作会立即发生在旧的块（Chunk）上，然后更改才会在所有权转移前复制到新的分片上。

### 40、MongoDB在A:{B,C}上建立索引，查询A:{B,C}和A:{C,B}都会使用索引吗？

不会，只会在A:{B,C}上使用索引。

### 41、如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？

如果一个分片停止了，除非查询设置了“Partial”选项，否则查询会返回一个错误。如果一个分片响应很慢，MongoDB会等待它的响应。

### 42、分析器在MongoDB中的作用是什么?

分析器就是explain 显示每次操作性能特点的数据库分析器。通过分析器可能查找比预期慢的操作

### 43、如果用户移除对象的属性，该属性是否从存储层中删除？

是的，用户移除属性然后对象会重新保存（re-save()）。

### 44、能否使用日志特征进行安全备份？

是的

### 45、更新操作立刻fsync到磁盘？

一般磁盘的写操作都是延迟执行的

### 46、如何执行事务/加锁？

因为mongodb设计就是轻量高性能，所以没有传统的锁和复杂的事务的回滚

### 47、什么是master或primary？

当前备份集群负责所有的写入操作的主要节点，在集群中，当主节点（master）失效，另一个成员会变为master

### 48、getLastError的作用

调用getLastError 可以确认当前的写操作是否成功的提交

### 49、分片（sharding）和复制（replication）是怎样工作的？

分片可能是单一的服务器或者集群组成，推荐使用集群

### 50、数据在什么时候才会扩展到多个分片（shard）里？

mongodb分片是基于区域的，所以一个集合的所有对象都放置在同一个块中，只有当存在多余一个块的时候，才会有多个分片获取数据的选项

### 51、 当我试图更新一个正在被迁移的块（chunk）上的文档时会发生什么？

会立即更新旧的分片，然后更改才会在所有权转移前复制到新的分片上

### 52、 我怎么查看 Mongo 正在使用的链接？

```
db._adminCommand("connPoolStats");复制代码
```

### 53、mongodb的结构介绍

数据库中存储的对象设计bson，一种类似json的二进制文件，由键值对组成

### 54、数据库的整体结构

键值对–》文档–》集合–》数据库

### 55、MongoDB是由哪种语言写的

MongoDB用c++编写的,流行的开源数据库MySQL也是用C++开发的。C++1983年发行是一种使用广泛的计算机程序设计语言。它是一种痛用程序设计语言，支持 多种编程模式。

### 56、MongoDB的优势有哪些

- 面向文档的存储：以 JSON 格式的文档保存数据。
- 任何属性都可以建立索引。
- 复制以及高可扩展性。
- 自动分片。
- 丰富的查询功能。
- 快速的即时更新。
- 来自 MongoDB 的专业支持。

### 57、什么是集合

集合就是一组 MongoDB 文档。它相当于关系型数据库（RDBMS）中的表这种概念。集合位于单独的一个数据库中。一个集合内的多个文档可以有多个不同的字段。一般来说，集合中的文档都有着相同或相关的目的。

### 58、什么是文档

文档由一组key value组成。文档是动态模式,这意味着同一集合里的文档不需要有相同的字段和结构。在关系型数据库中table中的每一条记录相当于MongoDB中的一个文档。

### 59、什么是”mongod“

mongod是处理MongoDB系统的主要进程。它处理数据请求，管理数据存储，和执行后台管理操作。当我们运行mongod命令意味着正在启动MongoDB进程,并且在后台运行。

### 60、"mongod"参数有什么

- 传递数据库存储路径，默认是"/data/db"
- 端口号 默认是 "27017"

### 61、什么是"mongo"

它是一个命令行工具用于连接一个特定的mongod实例。当我们没有带参数运行mongo命令它将使用默认的端口号和localhost连接

### 62、MongoDB哪个命令可以切换数据库

MongoDB 用 use +数据库名称的方式来创建数据库。 use 会创建一个新的数据库，如果该数据库存在，则返回这个数据库。

### 63、什么是非关系型数据库

非关系型数据库是对不同于传统关系型数据库的统称。非关系型数据库的显著特点是不使用SQL作为查询语言，数据存储不需要特定的表格模式。由于简单的设计和非常好的性能所以被用于大数据和Web Apps等

### 64、非关系型数据库有哪些类型

- -Key-Value 存储 Eg:Amazon S3
- 图表 Eg:Neo4J
- 文档存储 Eg:MongoDB
- 基于列存储 Eg:Cassandra

### 65、为什么用MOngoDB？

- 架构简单
- 没有复杂的连接
- 深度查询能力,MongoDB支持动态查询。
- 容易调试
- 容易扩展
- 不需要转化/映射应用对象到数据库对象
- 使用内部内存作为存储工作区,以便更快的存取数据。

### 66、在哪些场景使用MongoDB

- 大数据
- 内容管理系统
- 移动端Apps
- 数据管理

### 67、MongoDB中的命名空间是什么意思?

MongoDB内部有预分配空间的机制，每个预分配的文件都用0进行填充。

数据文件每新分配一次，它的大小都是上一个数据文件大小的2倍，每个数据文件最大2G。

MongoDB每个集合和每个索引都对应一个命名空间，这些命名空间的元数据集中在16M的*.ns文件中，平均每个命名占用约 628 字节，也即整个数据库的命名空间的上限约为24000。

如果每个集合有一个索引（比如默认的_id索引），那么最多可以创建12000个集合。如果索引数更多，则可创建的集合数就更少了。同时，如果集合数太多，一些操作也会变慢。

要建立更多的集合的话，MongoDB 也是支持的，只需要在启动时加上“--nssize”参数，这样对应数据库的命名空间文件就可以变得更大以便保存更多的命名。这个命名空间文件（.ns文件）最大可以为 2G。

每个命名空间对应的盘区不一定是连续的。与数据文件增长相同，每个命名空间对应的盘区大小都是随分配次数不断增长的。目的是为了平衡命名空间浪费的空间与保持一个命名空间数据的连续性。

需要注意的一个命名空间$freelist，这个命名空间用于记录不再使用的盘区（被删除的Collection或索引）。每当命名空间需要分配新盘区时，会先查看$freelist是否有大小合适的盘区可以使用，如果有就回收空闲的磁盘空间。

### 68、哪些语言支持MongoDB?

C、C++、C#、Java、Node.js、Perl、Php 等

### 69、在MongoDB中如何创建一个新的数据库

MongoDB 用  use + 数据库名称 的方式来创建数据库。 use 会创建一个新的数据库，如果该数据库存在，则返回这个数据库。

### 70、在MongoDB中如何查看数据库列表

使用命令"show dbs"

### 71、MongoDB中的分片是什么意思

分片是将数据水平切分到不同的物理节点。当应用数据越来越大的时候，数据量也会越来越大。当数据量增长时，单台机器有可能无法存储数据或可接受的读取写入吞吐量。利用分片技术可以添加更多的机器来应对数据量增加以及读写操作的要求。

### 72、如何查看使用MongoDB的连接Sharding - MongoDB Manual21.如何查看使用MongoDB的连接

使用命令"db.adminCommand(“connPoolStats”)"

```
>db.adminCommand(“connPoolStats”)复制代码
```

### 73、什么是复制

复制是将数据同步到多个服务器的过程，通过多个数据副本存储到多个服务器上增加数据可用性。复制可以保障数据的安全性，灾难恢复，无需停机维护（如备份，重建索引，压缩），分布式读取数据。

### 74、在MongoDB中如何在集合中插入一个文档

要想将数据插入 MongoDB 集合中，需要使用 insert() 或 save() 方法。

```
>db.collectionName.insert({"key":"value"})
>db.collectionName.save({"key":"value"})复制代码
```

### 75、在MongoDB中如何除去一个数据库Collection Methods24.在MongoDB中如何除去一个数据库

MongoDB 的 dropDatabase() 命令用于删除已有数据库。

```
>db.dropDatabase()复制代码
```

### 76、在MongoDB中如何创建一个集合。

在 MongoDB 中，创建集合采用db.createCollection(name, options)方法。 options 是一个用来指定集合配置的文档。

```
>db.createCollection("collectionName")db.createCollection() - MongoDB Manual>db.createCollection("复制代码
```

### 77、在MongoDB中如何查看一个已经创建的集合

可以使用show collections 查看当前数据库中的所有集合清单

```
>show collections复制代码
```

### 78、在MongoDB中如何删除一个集合

MongoDB 利用 db.collection.drop() 来删除数据库中的集合。

```
>db.CollectionName.drop()复制代码
```

### 79、为什么要在MongoDB中使用分析器

数据库分析工具(Database Profiler)会针对正在运行的mongod实例收集数据库命令执行的相关信息。包括增删改查的命令以及配置和管理命令。分析器(profiler)会写入所有收集的数据到 system.profile集合，一个capped集合在管理员数据库。分析器默认是关闭的你能通过per数据库或per实例开启。

### 80、MongoDB支持主键外键关系吗

默认MongoDB不支持主键和外键关系。 用Mongodb本身的API需要硬编码才能实现外键关联，不够直观且难度较大。

### 81、MongoDB支持哪些数据类型

String、Integer、Double、Boolean、Object、Object ID、Arrays、Min/Max Keys、Datetime、Code、Regular Expression等

### 82、为什么要在MongoDB中用"Code"数据类型

"Code"类型用于在文档中存储 JavaScript 代码。

### 83、为什么要在MongoDB中用"Regular Expression"数据类型

"Regular Expression"类型用于在文档中存储正则表达式

### 84、为什么在MongoDB中使用"Object ID"数据类型

"ObjectID"数据类型用于存储文档id

### 85、如何在集合中插入一个文档

要想将数据插入 MongoDB 集合中，需要使用insert()或save()方法。

```
>db.collectionName.insert({"key":"value"})
>db.collectionName.save({"key":"value"})复制代码
```

### 86、"ObjectID"由哪些部分组成

一共有四部分组成:时间戳、客户端ID、客户进程ID、三个字节的增量计数器

_id是一个 12 字节长的十六进制数，它保证了每一个文档的唯一性。在插入文档时，需要提供 _id 。如果你不提供，那么 MongoDB 就会为每一文档提供一个唯一的 id。 _id 的头 4 个字节代表的是当前的时间戳，接着的后 3 个字节表示的是机器 id 号，接着的 2 个字节表示MongoDB 服务器进程 id，最后的 3 个字节代表递增值。

### 87、在MongoDb中什么是索引

索引用于高效的执行查询.没有索引MongoDB将扫描查询整个集合中的所有文档这种扫描效率很低，需要处理大量数据。索引是一种特殊的数据结构，将一小块数据集保存为容易遍历的形式。索引能够存储某种特殊字段或字段集的值，并按照索引指定的方式将字段值进行排序。

### 88、如何添加索引

使用 db.collection.createIndex() 在集合中创建一个索引

```
>db.collectionName.createIndex({columnName:1})复制代码
```

### 89、用什么方法可以格式化输出结果

使用pretty() 方法可以格式化显示结果

```
>db.collectionName.find().pretty()复制代码
```

### 90、如何使用"AND"或"OR"条件循环查询集合中的文档

在 find() 方法中，如果传入多个键，并用逗号( , )分隔它们，那么 MongoDB 会把它看成是AND条件。

```
>db.mycol.find({key1:value1, key2:value2}).pretty()复制代码
```

若基于OR条件来查询文档，可以使用关键字$or。

```
>db.mycol.find(
 {
  $or: [
    {key1: value1}, {key2:value2}
  ]
 }
).pretty()复制代码
```

### 91、在MongoDB中如何更新数据

update() 与 save() 方法都能用于更新集合中的文档。 update() 方法更新已有文档中的值，而 save() 方法则是用传入该方法的文档来替换已有文档。

### 92、如何删除文档

MongoDB 利用  remove() 方法 清除集合中的文档。它有 2 个可选参数：

- deletion criteria：（可选）删除文档的标准。
- justOne：（可选）如果设为 true 或 1，则只删除一个文档。

```
>db.collectionName.remove({key:value})复制代码
```

### 93、在MongoDB中如何排序

MongoDB 中的文档排序是通过 sort() 方法来实现的。 sort() 方法可以通过一些参数来指定要进行排序的字段，并使用 1 和 -1 来指定排

序方式，其中 1 表示升序，而 -1 表示降序。

```
>db.connectionName.find({key:value}).sort({columnName:1})复制代码
```

### 94、什么是聚合

聚合操作能够处理数据记录并返回计算结果。聚合操作能将多个文档中的值组合起来，对成组数据执行各种操作，返回单一的结果。它相当于 SQL 中的 count(*) 组合 group by。对于 MongoDB 中的聚合操作，应该使用 aggregate() 方法。

```
>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)复制代码
```

### 95、在MongoDB中什么是副本集

在MongoDB中副本集由一组MongoDB实例组成，包括一个主节点多个次节点，MongoDB客户端的所有数据都写入主节点(Primary),副节点从主节点同步写入数据，以保持所有复制集内存储相同的数据，提高数据可用性。