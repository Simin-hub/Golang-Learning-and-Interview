# 计算机网络

[参考](https://segmentfault.com/a/1190000038526729)

## 概述

### ISP

**互联网服务提供商 （Internal Service Provider，ISP）** 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。

<img src="https://raw.githubusercontent.com/Simin-hub/Picture/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37326265303163642d343161652d343566372d393962392d6138643238346534346464342e706e67" alt="img" style="zoom: 50%;" />

目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。

<img src="https://raw.githubusercontent.com/Simin-hub/Picture/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33626534323630312d396433332d346432392d383335382d6139643136343533616639332e706e67" alt="img" style="zoom:50%;" />

### 主机之间的通信方式

- 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39313438393463322d306263342d343662352d626566392d3033313661363965663532312e6a7067)

- 对等（P2P）：不区分客户和服务器。

![img](https://camo.githubusercontent.com/1ce82a88a4c4c6b6125484c6ab4f5587e2e390c49392aa9309ba7e0bc1514466/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34323433306539342d333133372d343863302d626462362d3363656261663931303265332e6a7067)



端系统、分组交换机和其他因特网部件都要运行一系列协议（protocol）,这些协议控 制因特网中信息的接收和发送。

**协议（protocol）**定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。 

### 电路交换与分组交换

#### 1. 电路交换

**电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路**。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。

#### 2. 分组交换

**每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路**。

在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。

### 时延

总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延

![img](https://camo.githubusercontent.com/0a962523171ffa6b3b517823ab985c378b1acf07cd439aec5e9b535b6351efce/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34623261653738632d653235342d343464662d396533372d3537386532663262656635322e6a7067)

#### 1. 排队时延

**分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。**

#### 2. 处理时延

**主机或路由器收到分组时进行处理所需要的时间**，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。

#### 3. 传输时延

**主机或路由器传输数据帧所需要的时间。**

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64636462623936632d393037372d343132312d616562382d3734336535346163303261342e706e67)



其中 l 表示数据帧的长度，v 表示传输速率。

#### 4. 传播时延

电磁波在**信道中传播所需要花费的时间**，电磁波传播的速度接近光速。

![img](https://camo.githubusercontent.com/c9de58438de83509f26f14b6dbab912917d677287c10ec56e26572bbd5527de9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61313631366461632d306531322d343062322d383237642d3965336637663062393430642e706e67)

其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。

## 网络协议

### 什么是网络协议，为什么要对网络协议分层	*

网络协议是计算机在通信过程中要遵循的一些约定好的规则。

网络分层的原因：

- 易于实现和维护，因为各层之间是独立的，层与层之间不会收到影响。
- 有利于标准化的制定

### 计算机网络的各层协议及作用	***

> 计算机网络体系可以大致分为一下三种，**OSI七层模型**、**五层模型和TCP/IP四层模型**，一般面试能流畅回答出五层模型就可以了，表示层和会话层被问到的不多。

<img src="https://raw.githubusercontent.com/Simin-hub/Picture/master/img/%E4%B8%8B%E8%BD%BD.jpg" style="zoom:200%;" />

- 应用层

  应用层的任务是**通过应用进程之间的交互来完成特定的网络作用**，常见的应用层协议有**域名系统DNS，HTTP协议**等。应用层的信息分组称为**报文（message）**。

- 表示层

  表示层的**主要作用是数据的表示、安全、压缩**。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。

- 会话层

  会话层的**主要作用是建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话**，决定通信是否被中断以及通信中断时决定从何处重新发送。

- 传输层

  传输层的**主要作用是负责向两台主机进程之间的通信提供数据传输服务。**传输层的协议主要有**传输控制协议TCP和用户数据协议UDP**。运输层的分组称为**报文段 (segment)**。

- 网络层

  网络层的**主要作用是选择合适的网间路由和交换结点，确保数据及时送达**。常见的协议有**IP协议**。网络层的分组称为**数据报（datagram）**

- 数据链路层

  数据链路层的作用是**在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）**在信道上无差错的传输，并进行各电路上的动作系列。 **常见的协议有SDLC、HDLC、PPP**等。把链路层分组称为**帧（frmie）。**

- 物理层

  物理层的主要作用是实现相邻计算机结点之间比特流的透明传输，并尽量屏蔽掉具体传输介质和物理设备的差异。
  
  ![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/5293318_1593560537637_F02EC5233B79B410F00EF03032424943)

![preview](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/v2-2af488004591cbc12cd82c44518523de_r.jpg)

## 应用层

### URI和URL的区别	*

- URI(Uniform Resource Identifier)：中文全称为**统一资源标志符，主要作用是唯一标识一个资源**。
- URL(Uniform Resource Location)：中文全称为**统一资源定位符，主要作用是提供资源的路径**。

有个经典的比喻是URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。

#### 在浏览器中输⼊url地址到显示主页的过程	***

> 面试超高频的一道题，一般能说清楚流程就可以。

1. 对输入到浏览器的url进行DNS解析，将域名转换为IP地址。
2. 和目的服务器建立TCP连接
3. 向目的服务器发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析并渲染页面

### DNS

#### DNS的工作流程	***

DNS的定义：DNS的全称是domain name system，即域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的去访问互联网而不用去记住能够被机器直接读取的IP地址。比如大家访问百度，更多地肯定是访问www.baidu.com，而不是访问112.80.248.74，因为这几乎无规则的IP地址实在太难记了。DNS要做的就是将www.baidu.com解析成112.80.248.74。

**DNS 的过程？**

关于DNS的获取流程：

DNS是应用层协议，事实上他是为其他应用层协议工作的，包括不限于HTTP和SMTP以及FTP，用于将用户提供的主机名解析为ip地址。

具体过程如下：

①用户主机上运行着DNS的客户端，就是我们的PC机或者手机客户端运行着DNS客户端了

②浏览器将接收到的url中抽取出域名字段，就是访问的主机名，比如http://www.baidu.com/, 并将这个主机名传送给DNS应用的客户端

③DNS客户机端向DNS服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式DNS集群的工作）

④该DNS客户机最终会收到一份回答报文，其中包含有该主机名对应的IP地址

⑤一旦该浏览器收到来自DNS的IP地址，就可以向该IP地址定位的HTTP服务器发起TCP连接

![请添加图片描述](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/0215d27a7fce45fb93e20581b73cc99b.png)

![在这里插入图片描述](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/d3da10017481426ca8611b5bc2612e69.png)

### HTTP 和 HTTPS 

[**HTTP 请求包（浏览器信息）**](https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5)

我们先来看看 Request 包的结构，Request 包分为 3 部分，第一部分叫 Request line（请求行）, 第二部分叫 Request header（请求头）, 第三部分是 body（主体）。header 和 body 之间有个空行，请求包的例子所示:

```
GET /domains/example/ HTTP/1.1      // 请求行: 请求方法 请求 URL HTTP 协议/协议版本
Host：www.iana.org               // 服务端的主机名
User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4          // 浏览器信息
Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8  // 客户端能接收的 mine 能够接受的回应内容类型
Accept-Encoding：gzip,deflate,sdch       // 是否支持流压缩 	能够接受的编码方式列表
Accept-Charset：UTF-8,*;q=0.5        // 客户端字符编码集 	能够接受的字符集
// 空行,用于分割请求头和消息体
// 消息体,请求资源参数,例如 POST 传递的参数
```

HTTP 协议定义了很多与服务器交互的请求方法，最基本的有 4 种，分别是 GET, POST, PUT, DELETE。**一个 URL 地址用于描述一个网络上的资源，而 HTTP 中的 GET, POST, PUT, DELETE 就对应着对这个资源的查，增，改，删 4 个操作。**我们最常见的就是 GET 和 POST 了。GET 一般用于获取 / 查询资源信息，而 POST 一般用于更新资源信息。

通过 fiddler 抓包可以看到如下请求信息:

![](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/3.1.http.png)

![](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/3.1.httpPOST.png)

我们看看 **GET 和 POST 的区别**:

1. 我们可以看到 GET 请求消息体为空，POST 请求带有消息体。
2. **GET 提交的数据会放在 URL 之后，以 ? 分割 URL 和传输数据，参数之间以 & 相连**，如 EditPosts.aspx?name=test1&id=123456。**POST 方法是把提交的数据放在 HTTP 包的 body 中**。
3. GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制。
4. GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。

**HTTP 响应包（服务器信息）**

我们再来看看 HTTP 的 response 包，他的结构如下：

```
HTTP/1.1 200 OK                     // 状态行
Server: nginx/1.0.8                 // 服务器使用的 WEB 软件名及版本
Date: Tue, 30 Oct 2012 04:14:25 GMT     // 发送时间
Content-Type: text/html             // 服务器发送信息的类型
Transfer-Encoding: chunked          // 表示发送 HTTP 包是分段发的
Connection: keep-alive              // 保持连接状态
Content-Length: 90                  // 主体内容长度
// 空行 用来分割消息头和主体
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"... // 消息体
```


Response 包中的**第一行叫做状态行**，由 HTTP 协议版本号， 状态码， 状态消息三部分组成。


状态码用来告诉 HTTP 客户端，HTTP 服务器是否产生了预期的 Response。HTTP/1.1 协议中定义了 5 类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别

- 1XX 提示信息 - 表示请求已被成功接收，继续处理
- 2XX 成功 - 表示请求已被成功接收，理解，接受
- 3XX 重定向 - 要完成请求必须进行更进一步的处理
- 4XX 客户端错误 - 请求有语法错误或请求无法实现
- 5XX 服务器端错误 - 服务器未能实现合法的请求

我们看下面这个图展示了详细的返回信息，左边可以看到有很多的资源返回码，200 是常用的，表示正常信息，302 表示跳转。response header 里面展示了详细的信息。

![](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/3.1.response.png)

**HTTP 协议是无状态的和 Connection: keep-alive 的区别**

无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。

HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（面对无连接）。

从 HTTP/1.1 起，默认都开启了 Keep-Alive 保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的 TCP 连接。

Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同服务器软件（如 Apache）中设置这个时间。

请求实例

![](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/3.1.web.png)

上面这张图我们可以了解到整个的通讯过程，同时细心的读者是否注意到了一点，一个 URL 请求但是左边栏里面为什么会有那么多的资源请求 (这些都是静态文件，go 对于静态文件有专门的处理方式)。

这个就是浏览器的一个功能，第一次请求 url，服务器端返回的是 html 页面，然后浏览器开始渲染 HTML：当解析到 HTML DOM 里面的图片连接，css 脚本和 js 脚本的链接，浏览器就会自动发起一个请求静态资源的 HTTP 请求，获取相对应的静态资源，然后浏览器就会渲染出来，最终将所有资源整合、渲染，完整展现在我们面前的屏幕上。

网页优化方面有一项措施是减少 HTTP 请求次数，就是把尽量多的 css 和 js 资源合并在一起，目的是尽量减少网页请求静态资源的次数，提高网页加载速度，同时减缓服务器的压力。

#### HTTP 和 HTTPS 

**一般http中存在如下问题：**

- 请求信息明文传输，容易被窃听截取。
- 数据的完整性未校验，容易被篡改
- 没有验证对方身份，存在冒充危险

HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。

**SSL（Secure Socket Layer，安全套接字层）**

[TLS](https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A)（Transport Layer Security，传输层安全）及其前身**SSL**是一种[安全协议](https://zh.wikipedia.org/wiki/安全协议)，目的是为[互联网](https://zh.wikipedia.org/wiki/網際網路)通信提供安全及数据[完整性](https://zh.wikipedia.org/wiki/完整性)保障。

SSL握手过程：

![SSL安全套接层_服务端](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/wKioL1f680WxnnUsAAAfPPyWg7w510.png)

1.客户端发送client hello消息（消息中包括，ssl版本、加密算法列表、随机数）

2.服务端回应server hello消息（消息中包括，确认ssl版本、确认加密算法、随机数、server证书）

3.客户端收到消息后，首先检查证书的有效期，证书链，CRL等，确认身份，客户端再次生成随机数，然后利用证书公钥将3个随机数进行加密并发送给server

4.服务端收到消息后，利用私钥将加密信息解密得到三个随机数，并生成会话密钥



#### HTTP 与 HTTPS 的区别	***

|              |        HTTP        |                  HTTPS                  |
| :----------: | :----------------: | :-------------------------------------: |
|     端口     |         80         |                   443                   |
|    安全性    | 无加密，安全性较差 |         有加密机制，安全性较高          |
|   资源消耗   |        较少        |       由于加密处理，资源消耗更多        |
| 是否需要证书 |       不需要       |                  需要                   |
|     协议     | 运行在TCP协议之上  | 运行在SSL协议之上，SSL运行在TCP协议之上 |

#### 什么是对称加密与非对称加密	**

- 对称加密

  **对称加密指加密和解密使用同一密钥**，优点是运算速度快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有DES、AES等等。

- 非对称加密

  **非对称加密指的是加密和解密使用不同的密钥，一把公开的公钥，一把私有的私钥**。公钥加密的信息只有私钥才能解密，私钥加密的信息只有公钥才能解密。优点解决了对称加密中存在的问题。**缺点是运算速度较慢**。常见的非对称加密算法有RSA、DSA、ECC等等。

  **非对称加密的工作流程**：A生成一对非对称密钥，将公钥向所有人公开，B拿到A的公钥后使用A的公钥对信息加密后发送给A，经过加密的信息只有A手中的私钥能解密。这样B可以通过这种方式将自己的公钥加密后发送给A，两方建立起通信，可以通过对方的公钥加密要发送的信息，接收方用自己的私钥解密信息。

#### HTTPS的加密过程	***

上面已经介绍了对称加密和非对称加密的优缺点，**HTTPS是将两者结合起来，使用的对称加密和非对称加密的混合加密算法**。具体做法就是**使用非对称加密来传输对称密钥来保证安全性，使用对称加密来保证通信的效率**。

简化的**工作流程**：服务端生成一对非对称密钥，将公钥发给客户端。客户端生成对称密钥，用服务端发来的公钥进行加密，加密后发给服务端。服务端收到后用私钥进行解密，得到客户端发送的对称密钥。通信双方就可以通过对称密钥进行高效地通信了。

但是仔细想想这**其中存在一个很大地问题，就是客户端最开始如何判断收到的这个公钥就是来自服务端而不是其他人冒充的？**

这就需要证书上场了，服务端会**向一个权威机构申请一个证书来证明自己的身份**，到时候将证书（证书中包含了公钥）发给客户端就可以了，客户端收到证书后既证明了服务端的身份又拿到了公钥就可以进行下一步操作了。

HTTPS的加密过程：

1. 客户端向服务端发起第一次握手请求，告诉服务端客户端所支持的SSL的指定版本、加密算法及密钥长度等信息。
2. 服务端将自己的公钥发给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名，并给服务器颁发公钥证书。
3. 服务端将证书发给客户端。
4. 客户端利用数字认证机构的公钥，向数字证书认证机构验证公钥证书上的数字签名，确认服务器公开密钥的真实性。
5. 客户端使用服务端的公开密钥加密自己生成的对称密钥，发给服务端。
6. 服务端收到后利用私钥解密信息，获得客户端发来的对称密钥。
7. 通信双方可用对称密钥来加密解密信息。

上述流程存在的一个问题是客户端哪里来的数字认证机构的公钥，其实，在很多浏览器开发时，会**内置常用数字证书认证机构的公钥**。

流程图如下：

![在这里插入图片描述](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/1460000038526733)

#### 常用HTTP状态码	***

> 这也是一个面试经常问的题目,背下来就行了.

| 状态码 |       类别       |
| :----: | :--------------: |
|  1XX   |   信息性状态码   |
|  2XX   |    成功状态码    |
|  3XX   |   重定向状态码   |
|  4XX   | 客户端错误状态码 |
|  5XX   | 服务端错误状态码 |

常见的HTTP状态码

**1XX**

- 100 Continue：表示正常，客户端可以继续发送请求
- 101 Switching Protocols：切换协议，服务器根据客户端的请求切换协议。

**2XX**

- 200 OK：请求成功
- 201 Created：已创建，表示成功请求并创建了新的资源
- 202 Accepted：已接受，已接受请求，但未处理完成。
- 204 No Content：无内容，服务器成功处理，但未返回内容。
- 205 Reset Content：重置内容，服务器处理成功，客户端应重置文档视图。
- 206 Partial Content：表示客户端进行了范围请求，响应报文应包含Content-Range指定范围的实体内容

**3XX**

- 301 Moved Permanently：永久性重定向
- 302 Found：临时重定向
- 303 See Other：和301功能类似，但**要求客户端采用get方法**获取资源
- 304 Not Modified：所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。
- 305 Use Proxy：所请求的资源必须通过代理访问
- 307 Temporary Redirect： 临时重定向，与302类似，要求使用get请求重定向。

**4XX**

- 400 Bad Request：客户端请求的语法错误，服务器无法理解。
- 401 Unauthorized：表示发送的请求需要有认证信息。
- 403 Forbidden：服务器理解用户的请求，但是拒绝执行该请求
- 404 Not Found：服务器无法根据客户端的请求找到资源。
- 405 Method Not Allowed：客户端请求中的方法被禁止
- 406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求
- 408 Request Time-out：服务器等待客户端发送的请求时间过长，超时

**5XX**

- 500 Internal Server Error：服务器内部错误，无法完成请求
- 501 Not Implemented：服务器不支持请求的功能，无法完成请求
- 502 示作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的
- 503 服务器尚未处于可以接受请求的状态

#### 常见的HTTP方法　***

|  方法   | 作用                                                         |
| :-----: | :----------------------------------------------------------- |
|   GET   | 获取资源                                                     |
|  POST   | 用于将实体提交到指定的资源，通常**导致在服务器上的状态变化或副作用** |
|   PUT   | 用请求有效载荷替换目标资源的所有当前表示                     |
| DELETE  | 删除指定的资源                                               |
|  HEAD   | 和GET方法类似，但只返回报文首部，不返回报文实体主体部分      |
|  PATCH  | 对资源进行部分修改                                           |
| OPTIONS | 查询指定的URL支持的方法                                      |
| CONNECT | 要求用隧道协议连接代理                                       |
|  TRACE  | 服务器会将通信路径返回给客户端                               |

为了方便记忆，可以将PUT、DELETE、POST、GET理解为客户端对服务端的增删改查。

- PUT：上传文件，向服务器添加数据，可以看作增，put是幂等的
- DELETE：删除文件
- POST：传输数据，向服务器提交数据，对服务器数据进行更新。
- GET：获取资源，查询服务器资源

[post和put的区别](https://blog.csdn.net/mad1989/article/details/7918267)

#### GET和POST区别　***

- 作用

  GET用于获取资源，POST用于传输实体主体

- 参数位置

  **GET的参数放在URL中，POST的参数存储在实体主体中**，并且GET方法提交的请求的URL中的数据做多是2048字节，POST请求没有大小限制。

- 安全性

  GET方法因为参数放在URL中，安全性相对于POST较差一些

- 幂等性

  GET方法是具有幂等性的，而POST方法不具有幂等性。这里**幂等性指客户端连续发出多次请求，收到的结果都是一样的**.

#### HTTP 1.0、HTTP 1.1及HTTP 2.0的主要区别是什么　***

HTTP 1.0和HTTP 1.1的区别

- **长连接**

  HTTP 1.1支持长连接和请求的流水线操作。**长连接是指不在需要每次请求都重新建立一次连接**，HTTP 1.0默认使用短连接，每次请求都要重新建立一次TCP连接，资源消耗较大。**请求的流水线操作是指客户端在收到HTTP的响应报文之前可以先发送新的请求报文**，不支持请求的流水线操作需要等到收到HTTP的响应报文后才能继续发送新的请求报文。

- **缓存处理**

  在HTTP 1.0中主要使用header中的If-Modified-Since,Expires作为缓存判断的标准，HTTP 1.1引入了Entity tag，If-Unmodified-Since, If-Match等更多**可供选择的缓存头来控制缓存策略**。

- **错误状态码**

  在HTTP 1.1新增了24个错误状态响应码

- **HOST域**

  在HTTP 1.0 中认为每台服务器都会绑定唯一的IP地址，所以，请求中的URL并没有传递主机名。但后来一台服务器上可能存在多个虚拟机，它们共享一个IP地址，所以**HTTP 1.1中请求消息和响应消息都应该支持Host域**。

- **带宽优化及网络连接的使用**

  在HTTP 1.0中会存在浪费带宽的现象，**主要是因为不支持断点续传功能**，客户端只是需要某个对象的一部分，服务端却将整个对象都传了过来。**在HTTP 1.1中请求头引入了range头域，它支持只请求资源的某个部分**，返回的状态码为206。

HTTP 2.0的新特性

- **新的二进制格式**：HTTP 1.x的解析是基于文本，HTTP 2.0的解析采用二进制，实现方便，健壮性更好。
- **多路复用**：每一个request对应一个id，一个连接上可以有多个request，每个连接的request可以随机混在一起，这样接收方可以根据request的id将request归属到各自不同的服务端请求里。
- **header压缩**：在HTTP 1.x中，header携带大量信息，并且每次都需要重新发送，HTTP 2.0采用编码的方式减小了header的大小，**同时通信双方各自缓存一份header fields表**，避免了header的重复传输。
- **服务端推送**：客户端在请求一个资源时，会把相关资源一起发给客户端，这样客户端就不需要再次发起请求。

### Session、Cookie和Token的主要区别　***

HTTP协议是无状态的，即服务器无法判断用户身份。Session和Cookie可以用来进行身份辨认。

- Cookie

  **Cookie是保存在客户端一个小数据块**，其中包含了用户信息。当客户端向服务端发起请求，服务端会像客户端浏览器发送一个Cookie，客户端会把Cookie存起来，当下次客户端再次请求服务端时，会携带上这个Cookie，服务端会通过这个Cookie来确定身份。

- Session

  Session是通过Cookie实现的，和Cookie不同的是，**Session是存在服务端的**。当客户端浏览器第一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。比如浏览器访问的是购物网站，将一本《图解HTTP》放到了购物车，当浏览器再次访问服务器时，服务器会取出Cookie中的sessionid，并根据sessionid获取会话中的存储的信息，确认浏览器的身份是上次将《图解HTTP》放入到购物车那个用户。

  服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个**缺陷**：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。

- Token

  **客户端在浏览器第一次访问服务端时，服务端生成的一串字符串作为Token发给客户端浏览器**，下次浏览器在访问服务端时携带token即可无需验证用户名和密码，省下来大量的资源开销。看到这里很多人感觉这不是和sessionid作用一样吗？其实是不一样的，但是本文章主要针对面试，知识点很多，篇幅有限，几句话也解释不清楚，大家可以看看这篇文章，我觉得说的非常清楚了。[cookie、session与token的真正区别](https://link.segmentfault.com/?enc=GrshIvnLLcEv71iAkclwMg%3D%3D.nQrOC%2BH9qvoTZhrXWFV4ZMAVGKc6nprghE4D1yrALbQ337UyBWFRjmZxFN5i6fuS6B07x1WbMeYHaDO5MtQ2Uw%3D%3D)

  下面为了方便记忆，做了一个表格进行对比。

  |         |   存放位置   | 占用空间 | 安全性 |      应用场景      |
  | :-----: | :----------: | :------: | :----: | :----------------: |
  | Cookie  | 客户端浏览器 |    小    |  较低  |  一般存放配置信息  |
  | Session |    服务端    |    多    |  较高  | 存放较为重要的信息 |

#### 如果客户端禁止 cookie 能实现 session 还能用吗？　＊

可以，Session的作用是在服务端来保持状态，通过sessionid来进行确认身份，但sessionid一般是通过Cookie来进行传递的。如果Cooike被禁用了，可以通过在URL中传递sessionid。

#### Token	 ***

在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。

以下几点特性会让你在程序中使用基于Token的身份验证

1. 无状态、可扩展
2. 支持移动设备
3. 跨程序调用
4. 安全

##### **Token的起源**

在介绍基于Token的身份验证的原理与优势之前，不妨先看看之前的认证都是怎么做的。

**基于服务器的验证**

我们都是知道**HTTP协议是无状态的**，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。

在这之前，程序都是通过在服务端存储的登录信息来辨别请求的。这种方式一般都是通过存储Session来完成。

随着Web，应用程序，已经移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。

**基于服务器验证方式暴露的一些问题**

1. **Seesion：**每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。
2. **可扩展性：**在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。
3. **CORS(跨域资源共享)：**当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。
4. **CSRF(跨站请求伪造)：**用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。

在这些问题中，可扩展行是最突出的。因此我们有必要去寻求一种更有行之有效的方法。

**基于Token的验证原理**

基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。

这种概念解决了在服务端存储信息时的许多问题

> NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。

基于Token的身份验证的过程如下:

1. 用户通过用户名和密码发送请求。
2. 程序验证。
3. 程序返回一个签名的token 给客户端。
4. 客户端储存token,并且每次用于每次发送请求。
5. 服务端验证token并返回数据。

每一次请求都需要token。**token应该在HTTP的头部发送从而保证了Http请求无状态**。我们同样通过设置服务器属性Access-Control-Allow-Origin:* ，让服务器能接受到来自所有域的请求。

需要主要的是，在ACAO头部标明(designating)*时，不得带有像HTTP认证，客户端SSL证书和cookies的证书。

实现思路：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/20190509111955368.jpg)

1. 用户登录校验，校验成功后就返回Token给客户端。
2. 客户端收到数据后保存在客户端
3. 客户端每次访问API是携带Token到服务器端。
4. 服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码

当我们在程序中认证了信息并取得token之后，我们便能通过这个Token做许多的事情。

我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特定的token）

##### **Token的优势**

**无状态、可扩展**

在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。

如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用户量大时，可能会造成一些拥堵。

但是不要着急。使用tokens之后这些问题都迎刃而解，因为tokens自己hold住了用户的验证信息。

**安全性**

请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。

token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。

**可扩展性**

Tokens能够创建与其它程序共享权限的程序。例如，能将一个随便的社交帐号和自己的大号(Fackbook或是Twitter)联系起来。当通过服务登录Twitter(我们将这个过程Buffer)时，我们可以将这些Buffer附到Twitter的数据流上(we are allowing Buffer to post to our Twitter stream)。

使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens。

**多平台跨域**

我们提前先来谈论一下CORS(跨域资源共享)，对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。

> Having our API just serve data, we can also make the design choice to serve assets from a CDN. This eliminates the issues that CORS brings up after we set a quick header configuration for our application.

只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。

Access-Control-Allow-Origin: *   

基于标准创建token的时候，你可以设定一些选项。我们在后续的文章中会进行更加详尽的描述，但是标准的用法会在JSON Web Tokens体现。

最近的程序和文档是供给JSON Web Tokens的。它支持众多的语言。这意味在未来的使用中你可以真正的转换你的认证机制。

### Servlet是线程安全的吗	*

Servlet不是线程安全的，多线程的读写会导致数据不同步的问题。



## 传输层

### TCP与UDP有什么区别	***

|      | 是否面向连接 | 可靠性 |  传输形式  | 传输效率 | 消耗资源 |   应用场景    | 首部字节 |
| :--: | :----------: | :----: | :--------: | :------: | :------: | :-----------: | :------: |
| TCP  |   面向连接   |  可靠  |   字节流   |    慢    |    多    | 文件/邮件传输 |  20~60   |
| UDP  |    无连接    | 不可靠 | 数据报文段 |    快    |    少    | 视频/语音传输 |    8     |

> 有时候面试还会问到TCP的首部都包含什么

#### TCP首部：

前20个字节是固定的，后面有4n个字节是根据需而增加的选项，所以TCP首部最小长度为20字节。

![在这里插入图片描述](https://segmentfault.com/img/remote/1460000038526734)

- **源、目标端口号字段：占16比特**。TCP协议通过使用"端口"来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，操作系统动态地为客户端的应用程序分配端口号。在服务器端，每种服务在"众所周知的端口"（Well-Know Port）为用户提供服务。
- 顺序号字段：占**32比特**。用来**标识从TCP源端向TCP目标端发送的数据字节流**，它表示在这个报文段中的第一个数据字节。
- 确认号字段：占**32比特**。**只有ACK标志为1时，确认号字段才有效**。它包含目标端所期望收到源端的下一个数据字节。
- 头部长度字段（数据偏移）：占**4比特**。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。
- 标志位字段（U、A、P、R、S、F）：占6比特。各比特的含义如下：
  - URG：紧急指针（urgent pointer）有效。
  - ACK：确认序号有效。
  - PSH：接收方应该尽快将这个报文段交给应用层。
  - RST：重建连接。
  - SYN：发起一个连接。
  - FIN：释放一个连接。
- 窗口大小字段：占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。
- TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。
- 紧急指针字段：占16比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。
- 选项字段：占32比特。可能包括"窗口扩大因子"、"时间戳"等选项。

#### UDP首部

UDP的首部只有8个字节，**源端口号、目的端口号、长度和校验和各两个字节**。

![在这里插入图片描述](https://segmentfault.com/img/remote/1460000038526736)



### TCP协议如何保证可靠传输	***

> 主要有校验和、序列号、超时重传、流量控制及拥塞避免等几种方法。

- **校验和：在发送算和接收端分别计算数据的校验和，**如果两者不一致，则说明数据在传输过程中出现了差错，TCP将丢弃和不确认此报文段。
- **序列号：TCP会对每一个发送的字节进行编号**，接收方接到数据后，会对发送方发送确认应答(ACK报文)，并且这个ACK报文中带有相应的确认编号，告诉发送方，下一次发送的数据从编号多少开始发。如果发送方发送相同的数据，接收端也可以通过序列号判断出，直接将数据丢弃。如果

![](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/1460000038526737)

- **超时重传**：在上面说了序列号的作用，但如果发送方在发送数据后一段时间内（可以设置重传计时器规定这段时间）没有收到确认序号ACK，那么发送方就会重新发送数据。

  这里**发送方没有收到ACK可以分两种情况**，**如果是发送方发送的数据包丢失了**，接收方收到发送方重新发送的数据包后会马上给发送方发送ACK；**如果是接收方之前接收到了发送方发送的数据包，而返回给发送方的ACK丢失了**，这种情况，发送方重传后，接收方会**直接丢弃发送方冲重传的数据包**，然后**再次发送ACK响应报文**。

  如果数据被重发之后**还是没有收到接收方的确认应答**，则进行再次发送。此时，**等待确认应答的时间将会以2倍、4倍的指数函数延长，直到最后关闭连接**。

- **流量控制**：如果发送端发送的数据太快，接收端来不及接收就会出现丢包问题。为了解决这个问题，**TCP协议利用了滑动窗口进行了流量控制**。在TCP首部有一个16位字段大小的窗口，**窗口的大小就是接收端接收数据缓冲区的剩余大小**。接收端会在收到数据包后发送ACK报文时，将自己的窗口大小填入ACK中，**发送方会根据ACK报文中的窗口大小进而控制发送速度**。如果窗口大小为零，发送方会停止发送数据。

- **拥塞控制**：如果网络出现拥塞，则会产生丢包等问题，这时发送方会将丢失的数据包继续重传，网络拥塞会更加严重，所以在网络出现拥塞时应注意控制发送方的发送数据，降低整个网络的拥塞程度。**拥塞控制主要有四部分组成：慢开始、拥塞避免、快重传、快恢复**。

  ![在这里插入图片描述](https://segmentfault.com/img/remote/1460000038526742)

这里的**发送方会维护一个拥塞窗口的状态变量（congestion window，cwnd）**，它和流量控制的滑动窗口是不一样的，滑动窗口是根据接收方数据缓冲区大小确定的，而**拥塞窗口是根据网络的拥塞情况动态确定的**，一般来说发送方真实的发送窗口为滑动窗口和拥塞窗口中的最小值。

1. **慢开始**：为了**避免一开始发送大量的数据而产生网络阻塞**，会先初始化cwnd为1，当收到ACK后到下一个传输轮次，cwnd为2，以此类推成指数形式增长。

2. **拥塞避免**：因为cwnd的数量在慢开始是指数增长的，为了防止cwnd数量过大而导致网络阻塞，会设置一个慢开始的门限值ssthresh，当cwnd>=ssthresh时，进入到拥塞避免阶段，cwnd每个传输轮次加1。但网络出现超时，会**将门限值ssthresh变为出现超时cwnd数值的一半**，**cwnd重新设置为1**，如上图，在第12轮出现超时后，cwnd变为1，ssthresh变为12。

3. **快重传**：在**网络中如果出现超时或者阻塞，则按慢开始和拥塞避免算法进行调整**。但**如果只是丢失某一个报文段**，如下图(图片来源于网络)，则使用快重传算法。

   ![在这里插入图片描述](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/1460000038526741)

从上图可知，**接收方正确地接收到M1和M2，而M3丢失，由于没有接收到M3，在接收方收到M5、M6和M7时，并不会进行确认，也就是不会发送ACK。**这时根据前面说的保证TCP可靠性传输中的序列号的作用，接收方这时不会接收M5，M6，M7，接收方可以什么都不会，因为发送方长时间未收到M3的确认报文，会对M3进行重传。**除了这样，接收方也可以重复发送M2的确认报文**，这样发送端长时间未收到M3的确认报文也会继续发送M3报文。

**但是根据快重传算法，要求在这种情况下，需要快速向发送端发送M2的确认报文，在发送方收到三个M2的确认报文后，无需等待重传计时器所设置的时间，可直接进行M3的重传，这就是快重传。**(面试时说这一句就够了，前面是帮助理解)

4. **快恢复**：从上图可以看到，当发送收到三个重复的ACK，会进行快重传和快恢复。**快恢复是指将ssthresh设置为发生快重传时的cwnd数量的一半，而cwnd不是设置为1而是设置为为门限值ssthresh，并开始拥塞避免阶段**。

### TCP的三次握手及四次挥手	***

> 必考题

在介绍三次握手和四次挥手之前，先介绍一下TCP头部的一些常用字段。

- 序号：seq，占32位，用来标识从发送端到接收端发送的字节流。
- 确认号：ack，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。
- 标志位：
  - SYN：发起一个新连接。
  - FIN：释放一个连接。
  - ACK：确认序号有效。

#### 三次握手

> 三次握手的本质就是确定发送端和接收端具备收发信息的能力，在能流畅描述三次握手的流程及其中的字段含义作用的同时还需要记住每次握手时**接收端和发送端的状态**。这个比较容易忽略。

先看一张很经典的图（图片来源于网络），**发送端有CLOSED、SYN-SENT、ESTABLISHED**三种状态，**接收端有CLOSED、LISTEN、SYN-RCVD、ESTABLISHED四种状态**。![在这里插入图片描述](https://segmentfault.com/img/remote/1460000038526739)

假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是CLOSE。

- 第一次握手：客户端向服务端发起建立连接请求，**客户端会随机生成一个起始序列号x**，客户端向服务端发送的字段中包含标志位SYN=1，序列号seq=100。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN
- 第二次握手：服务端在收到客户端发来的报文后，会**随机生成一个服务端的起始序列号y**，然后给客户端回复一段报文，其中包括标志位SYN=1，ACK=1，序列号seq=y，确认号ack=x+1。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT。（其中SYN=1表示要和客户端建立一个连接，ACK=1表示确认序号有效）
- 第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK=1，序列号seq=x+1，确认号ack=y+1。第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED。

> 需要注意的一点是，第一次握手，**客户端向服务端发起建立连接报文，会占一个序列号**。但是第三次握手，同样是客户端向服务端发送报文，这次却不占序列号，所以建立连接后，**客户端向服务端发送的第一个数据的序列号为x+1**。

#### 四次挥手

客户端在四次挥手过程中有ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、TIME-WAIT、CLOSED等五个状态，服务端有ESTABLISHED、CLOSE-WAIT、LAST-ACK、CLOSED等四种状态。最好记住每次挥手时服务端和客户端的状态。

假设客户端首先发起的断开连接请求
![在这里插入图片描述](https://segmentfault.com/img/remote/1460000038526740)

- 第一次挥手：客户端向服务端发送的数据完成后，**向服务端发起释放连接报文**，报文包含标志位FIN=1，序列号seq=u。此时客户端只能接收数据，不能向服务端发送数据。
- 第二次挥手：服务端收到客户端的释放连接报文后，向客户端发送确认报文，包含标志位ACK=1，序列号seq=v，确认号ack=u+1。**此时客户端到服务端的连接已经释放掉，客户端不能向服务端发送数据，服务端也不能向客户端发送数据。**但服务端到客户端的**单向连接还能正常传输数据**。
- 第三次挥手：**服务端发送完数据后向客户端发出连接释放报文**，报文包含标志位FIN=1，标志位ACK=1，序列号seq=w，确认号ack=u+1。
- 第四次挥手：客户端收到服务端发送的释放连接请求，向服务端发送确认报文，包含标志位ACK=1，序列号seq=u+1，确认号ack=w+1。

#### 为什么TCP连接的时候是3次？两次是否可以？

不可以，主要从以下两方面考虑（假设客户端是首先发起连接请求）：

1. 假设建立TCP连接仅需要两次握手，**那么如果第二次握手时，服务端返回给客户端的确认报文丢失了，客户端这边认为服务端没有和他建立连接，而服务端却以为已经和客户端建立了连接，**并且可能向服务端已经开始向客户端发送数据，但客户端并不会接收这些数据，浪费了资源。如果是三次握手，不会出现双方连接还未完全建立成功就开始发送数据的情况。
2. **如果服务端接收到了一个早已失效的来自客户端的连接请求报文**，会向客户端发送确认报文同意建立TCP连接。但因为客户端并不需要向服务端发送数据，所以此次TCP连接没有意义并且浪费了资源。

#### 为什么TCP连接的时候是3次，关闭的时候却是4次？

**因为需要确保通信双方都能通知对方释放连接，假设客服端发送完数据向服务端发送释放连接请求**，当客服端并不知道，服务端是否已经发送完数据，所以此次断开的是客服端到服务端的单向连接，服务端返回给客户端确认报文后，服务端还能继续单向给客户端发送数据。当服务端发送完数据后还需要向客户端发送释放连接请求，客户端返回确认报文，TCP连接彻底关闭。所以断开TCP连接需要客户端和服务端分别通知对方并分别收到确认报文，一共需要四次。

#### TIME_WAIT和CLOSE_WAIT的区别在哪?

默认客户端首先发起断开连接请求

- 从上图可以看出，**CLOSE_WAIT是被动关闭形成的**，当客户端发送FIN报文，服务端返回ACK报文后进入CLOSE_WAIT。
- **TIME_WAIT是主动关闭形成的**，当第四次挥手完成后，客户端进入TIME_WAIT状态。

#### 为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？

**MSL的意思是报文的最长寿命**，可以从两方面考虑：

1. 客户端发送第四次挥手中的报文后，再经过2MSL，**可使本次TCP连接中的所有报文全部消失**，不会出现在下一个TCP连接中。
2. 考虑丢包问题，**如果第四挥手发送的报文在传输过程中丢失了，那么服务端没收到确认ack报文就会重发第三次挥手的报文**。如果客户端发送完第四次挥手的确认报文后直接关闭，而这次报文又恰好丢失，则会造成服务端无法正常关闭。

#### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

**如果TCP连接已经建立，在通信过程中，客户端突然故障，那么服务端不会一直等下去，过一段时间就关闭连接了**。具体原理是TCP有一个**保活机制，主要用在服务器端**，用于检测已建立TCP链接的客户端的状态，防止因客户端崩溃或者客户端网络不可达，而服务器端一直保持该TCP链接，占用服务器端的大量资源(因为Linux系统中可以创建的总TCP链接数是有限制的)。

**保活机制原理**：设置TCP保活机制的保活时间keepIdle，**即在TCP链接超过该时间没有任何数据交互时，发送保活探测报文**；设置保活探测报文的发送时间间隔keepInterval；设置保活探测报文的总发送次数keepCount。如果在keepCount次的保活探测报文均没有收到客户端的回应，则服务器端即关闭与客户端的TCP链接。

## 网络层

### 概述

因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上**只提供简单灵活的、无连接的、尽最大努力交互的数据报服务**。

使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。

[![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38643737396162372d666663632d343763362d393065632d6564653832363062323336382e706e67)](https://camo.githubusercontent.com/8583dbfe01c04f3328e2ee5e4e47f5025916b6ab7194f5fecdf5659b1187e2bb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38643737396162372d666663632d343763362d393065632d6564653832363062323336382e706e67)



与 IP 协议配套使用的还有三个协议：

- 地址解析协议 ARP（Address Resolution Protocol）
- 网际控制报文协议 ICMP（Internet Control Message Protocol）
- 网际组管理协议 IGMP（Internet Group Management Protocol）

### IP 数据报格式

[![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38356330356662312d353534362d346335302d393232312d3231663233316364633863352e6a7067)](https://camo.githubusercontent.com/e458e8998827725dfdd45430ff7ea4e3dcc4f261a6ba7fb934deb7be102527d8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38356330356662312d353534362d346335302d393232312d3231663233316364633863352e6a7067)



- **版本** : 有 4（IPv4）和 6（IPv6）两个值；
- **首部长度** : 占 4 位，因此**最大值为 15**。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值**最小为 5**。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。
- **区分服务** : 用来获得更好的服务，一般情况下不使用。
- **总长度** : **包括首部长度和数据部分长度**。
- **生存时间** ：TTL，它的**存在是为了防止无法交付的数据报在互联网中不断兜圈子**。以**路由器跳数为单位**，当 TTL 为 0 时就丢弃数据报。
- **上层协议标识** ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。
- **首部检验和** ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。
- **标识** : 在**数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符**。
- **片偏移** : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。

[![img](https://camo.githubusercontent.com/5a2935c7e397acf88b53a3b9ff7ad79a254cc814c581d667673a55cd4387c020/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32336261383930652d653131632d343565322d613230632d3634643231376638333433302e706e67)](https://camo.githubusercontent.com/5a2935c7e397acf88b53a3b9ff7ad79a254cc814c581d667673a55cd4387c020/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32336261383930652d653131632d343565322d613230632d3634643231376638333433302e706e67)



### IP 地址编址方式

IP 地址的编址方式经历了三个历史阶段：

- 分类
- 子网划分
- 无分类

#### 1. 分类

由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。

IP 地址 ::= {< 网络号 >, < 主机号 >}

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63626635306562382d323262342d343532382d613265372d6431383731343364353766372e706e67)



#### 2. 子网划分

通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。

IP 地址 ::= {< 网络号 >, < 子网号 >, < 主机号 >}

要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。

注意，外部网络看不到子网的存在。

#### 3. 无分类

无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。

IP 地址 ::= {< 网络前缀号 >, < 主机号 >}

CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。

CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。

一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 **构成超网** 。

在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。

#### 子网掩码

子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种**用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码**。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。

它的主要作用有两个，一是**用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上**，还是在远程网上。二是用于将一个大的IP网络划分为若干小的子网络。

**例子**

**1、255.255.255.0**

**子网掩码由连续的1和0组成**，**连续的1表示网络地址**，**连续的0表示主机地址**，**通过0的个数可以计算出子网的容量**（子网中主机的IP地址范围）。首先来看看默认的子网掩码255.255.255.0是怎么划分子网的，将该子网掩码的二进制由24个1和8个0组成，8个0表示该子网掩码划分出的子网容量为256（2的8次方），也就是说192.168.1.0-255都在同一个子网中，这256个地址中可用地址只有254个，因为规定每个子网的第一个IP地址为网段地址，最后一个IP地址为广播地址，都不可用。举例说明：对于网段192.168.1.0，如果子网掩码设置255.255.255.0，192.168.1.1-192.168.1.254为可用IP地址，设置这个范围内的IP地址，计算机之间能正常联网。

![img](https://pic4.zhimg.com/v2-141ad9160a6ad61a371d19c6d07e22d3_r.jpg)

**2、255.255.255.252**

当然上面是默认的情况，也是最简单的情况。下面我们分析子网掩码255.255.255.252是怎么划分子网的。将该子网掩码转换成二进制为30个1和2个0，表示每个子网中只有4个IP地址（2的2次方），192.168.1.0-255的地址段共可划分64个子网，第一个子网的地址范围是192.168.1.0-192.168.1.3，第二个子网的地址范围是192.168.1.4-192.168.1.7，依次类推。**其中每个子网第一个和最后一个IP地址不可用**，可用的只有2个IP地址。也就是说：如果子网掩码设置为255.255.255.252，那么该子网只能容纳两台电脑，而且这两台电脑的IP必须在一个子网内才能正常联网，例如一台电脑的IP设为192.168.1.10，另外一台电脑的IP必须设置为192.168.1.9。

![img](https://pic1.zhimg.com/v2-0c0f5766af51e86d46309413859569a4_r.jpg)


**3、子网划分实战**

通过以上两个例子读者应该明白子网掩码的作用了，下面通过一个实际的例子检验刚才的学习成果。某个小型公司有四个部门：行政、研发、营销、售后，每个部门各40台计算机接入公司局域网交换机，如果要在192.168.1.0网段为每个部门划分子网，子网掩码应该怎么设置，每个子网的地址范围分别是什么？

192.168.1.0网段共256个地址，划分4个子网，每个子网需要64个地址；64是2的6次方，子网掩码应该以6个0结尾，剩下的用1补齐，由26个1和6个0组成，转换成十进制是255.255.255.192；每个子网共64个IP地址，掐头去尾后可用地址只有62个，第1个子网的可用IP地址范围是：192.168.1.1-62，第2个子网可用IP地址范围是192.168.1.65-126，第3个子网的可用IP地址范围是：192.168.1.129-190，第4个子网可用IP地址范围是192.168.1.193-254；该公司各部门计算机按照3中的IP地址范围进行设置，所有计算机的子网掩码都必须设置为255.255.255.192，设置完毕后各部门内的计算机能正常联网，不同部门间的计算机无法直接联通。

### 有了IP地址，为什么还要用MAC地址？　＊＊

> 简单来说，标识网络中的一台计算机，比较常用的就是IP地址和MAC地址，但计算机的IP地址可由用户自行更改，管理起来相对困难，而MAC地址不可更改，所以一般会把IP地址和MAC地址组合起来使用。具体是如何组合使用的在上面的ARP协议中已经讲的很清楚了。
>
> 那只用MAC地址不用IP地址可不可以呢？其实也是不行的，因为在最早就是MAC地址先出现的，并且当时并不用IP地址，只用MAC地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可，这个过程就是上面说的ARP协议。
>
> 那为什么要用IP地址呢？是因为IP地址是和地域相关的，对于同一个子网上的设备，IP地址的前缀都是一样的，这样路由器通过IP地址的前缀就知道设备在在哪个子网上了，而只用MAC地址的话，路由器则需要记住每个MAC地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。
>
> IP地址可以比作为地址，MAC地址为收件人，在一次通信过程中，两者是缺一不可的。

### 说一下ping的过程　＊＊

ping是ICMP(网际控制报文协议)中的一个重要应用，ICMP是网络层的协议。ping的作用是测试两个主机的连通性。

ping的工作过程：

1. 向目的主机发送多个ICMP回送请求报文
2. 根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包往返时间及丢包率。

### 路由器和交换机的区别？　＊

|        | 所属网络模型的层级 |                             功能                             |
| :----: | :----------------: | :----------------------------------------------------------: |
| 路由器 |       网络层       | 识别IP地址并根据IP地址转发数据包，维护数据表并基于数据表进行最佳路径选择 |
| 交换机 |     数据链库层     |              识别MAC地址并根据MAC地址转发数据帧              |

### ICMP

ICMP是（Internet Control Message Protocol）Internet控制 [报文](http://baike.baidu.com/view/175122.htm) 协议。它是 [TCP/IP协议族](http://baike.baidu.com/view/2221037.htm) 的一个子协议，用于在IP [主机](http://baike.baidu.com/view/23880.htm) 、 [路由](http://baike.baidu.com/view/18655.htm) 器之间传递控制消息。控制消息是指 [网络通](http://baike.baidu.com/view/8079702.htm) 不通、 [主机](http://baike.baidu.com/view/23880.htm) 是否可达、 [路由](http://baike.baidu.com/view/18655.htm) 是否可用等网络本身的消息

在IPv4协议中最常用的ICMP消息类型有以下几种:

- **回显应答(类型0)和回显请求(类型8):这是Ping程序发送的信息。**
- **目标不可达(类型3)**
- 源抑制(类型4):这是一种用于通知发送者路由器或者主机出现阻塞现象的ICMP消息，发送者需要降低发送速度。
- 重定向(类型5):这个消息用来向可以访问两台路由器的主机说“请使用另一台路由器”。
- 路由器信息应答(类型9)和路由器信息请求(类型10)
- 超时(类型11):这个消息有两种用途。第一，当超过IP生存期时向发送系统发出错误信息。第二，如果分段的IP数据报没有在某种时限内重新组合，这个消息将通知发送系统。

### IGMP

**互联网组管理协议**（**I**nternet **G**roup **M**anagement **P**rotocol，IGMP）是用于管理网路协议[多播](https://zh.wikipedia.org/wiki/多播)组成员的一种通信协议。IP主机和相邻的路由器利用IGMP来创建多播组的组成员。像[ICMP](https://zh.wikipedia.org/wiki/ICMP)用于单播连接一样，IGMP也是IP多播说明的一个完整部分。 IGMP为互联网协议的一种，属于开放系统链接(OSI) 模块的第三层协议，IP主机用它将主机的多点发送成员人数报告给临近的多点发送路由器。

## 数据链路层

### ARP协议＊＊

地址解析协议 ARP, **ARP协议属于网络层的协议**，主要作用是实现从IP地址转换为MAC地址。在每个主机或者路由器中都建有一个ARP缓存表，表中有IP地址及IP地址对应的MAC地址。先来看一下什么时IP地址和MAC地址。

- IP地址：**IP地址是指互联网协议地址**，IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。
- MAC地址：**MAC地址又称物理地址**，由网络设备制造商生产时写在硬件内部，不可更改，并且每个以太网设备的MAC地址都是唯一的。

ARP 实现由 IP 地址得到 MAC 地址。

[![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62396437396135612d653761662d343939622d623938392d6631303438336537316238622e6a7067)](https://camo.githubusercontent.com/81c45941a689239d8a0ef8c121b17a5a82ba3a626e92a7bf5c3cf53c6035ea26/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62396437396135612d653761662d343939622d623938392d6631303438336537316238622e6a7067)

数据在传输过程中，会先从高层传到底层，然后在通信链路上传输。从下图可以看到TCP报文在网络层会被封装成IP数据报，在数据链路层被封装成MAC帧，然后在通信链路中传输。在网络层使用的是IP地址，在数据据链路层使用的是MAC地址。MAC帧在传送时的源地址和目的地址使用的都是MAC地址，在通信链路上的主机或路由器也都是根据MAC帧首部的MAC地址接收MAC帧。并且在数据链路层是看不到IP地址的，只有当数据传到网络层时去掉MAC帧的首部和尾部时才能在IP数据报的首部中找到源IP地址和目的地址。

![在这里插入图片描述](https://segmentfault.com/img/remote/1460000038526732)

**网络层实现的是主机之间的通信**，而**链路层实现的是链路之间的通信**，所以从下图可以看出，在数据传输过程中，IP数据报的源地址(IP1)和目的地址(IP2)是一直不变的，而MAC地址(硬件地址)却一直随着链路的改变而改变。

![在这里插入图片描述](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/1460000038526738)

ARP的工作流程(面试时问ARP协议主要说这个就可以了)：

1. 在局域网内，主机A要向主机B发送IP数据报时，首先会在主机A的ARP缓存表中查找是否有IP地址及其对应的MAC地址，如果有，则将MAC地址写入到MAC帧的首部，并通过局域网将该MAC帧发送到MAC地址所在的主机B。
2. 如果主机A的ARP缓存表中没有主机B的IP地址及所对应的MAC地址，主机A会在局域网内广播发送一个ARP请求分组。局域网内的所有主机都会收到这个ARP请求分组。
3. 主机B在看到主机A发送的ARP请求分组中有自己的IP地址，会像主机A以单播的方式发送一个带有自己MAC地址的响应分组。
4. 主机A收到主机B的ARP响应分组后，会在ARP缓存表中写入主机B的IP地址及其IP地址对应的MAC地址。
5. 如果主机A和主机B不在同一个局域网内，即使知道主机B的MAC地址也是不能直接通信的，必须通过路由器转发到主机B的局域网才可以通过主机B的MAC地址找到主机B。并且主机A和主机B已经可以通信的情况下，主机A的ARP缓存表中寸的并不是主机B的IP地址及主机B的MAC地址，而是主机B的IP地址及该通信链路上的下一跳路由器的MAC地址。这就是上图中的源IP地址和目的IP地址一直不变，而MAC地址却随着链路的不同而改变。
6. 如果主机A和主机B不在同一个局域网，参考上图中的主机H1和主机H2，这时主机H1需要先广播找到路由器R1的MAC地址，再由R1广播找到路由器R2的MAC地址，最后R2广播找到主机H2的MAC地址，建立起通信链路。

### RARP

**逆地址解析协议**（Reverse Address Resolution Protocol，RARP），是一种[网络协议](https://zh.wikipedia.org/wiki/网络协议)，[互联网工程任务组](https://zh.wikipedia.org/wiki/互联网工程任务组)（IETF）在RFC903中描述了RARP。RARP使用与ARP相同的报头结构，作用与[ARP](https://zh.wikipedia.org/wiki/ARP)相反。RARP用于将[MAC地址](https://zh.wikipedia.org/wiki/MAC地址)转换为[IP地址](https://zh.wikipedia.org/wiki/IP地址)。其因为较限于IP地址的运用以及其他的一些缺点，因此渐为更新的[BOOTP](https://zh.wikipedia.org/wiki/BOOTP)或[DHCP](https://zh.wikipedia.org/wiki/DHCP)所取代。

##### 工作原理

1. 发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；
2. 本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；
3. 如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；
4. 如果不存在，RARP服务器对此不做任何的响应；
5. 源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。

## 物理层

### 通信方式

根据信息在传输线上的传送方向，分为以下三种通信方式：

- 单工通信：单向传输
- 半双工通信：双向交替传输
- 全双工通信：双向同时传输

### 带通调制

模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。

[![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63333466343530332d663632632d343034332d396463362d3365303332383836353764662e6a7067)](https://camo.githubusercontent.com/59e58745fe8f7b2ec9020e6fb10da969ee0ecc5ba40bb04318690171449586bc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63333466343530332d663632632d343034332d396463362d3365303332383836353764662e6a7067)

## 网络攻击

**拒绝服务攻击**（Denial-of Service （ DoS） attack）

- 弱点攻击。这涉及向一台目标主机上运行的易受攻击的应用程序或操作系统**发送制作精细的报文**。如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务器可能停止运行，或者更糟糕的是主机可能崩溃。 

- 带宽洪泛。攻击者向目标主机**发送大量的分组**，分组数量之多使得目标的接入链路变得拥塞，**使得合法的分组无法到达服务器**。 

- 连接洪泛。攻击者在目标主机中**创建大量的半开或全开TCP连接**。该主机因这些伪造的连接而陷入困境，并停止接受合法的连接

分组嗅探器(packet sniffer) 

IP哄骗（IP spoofing）

## 面试题

[参考](https://www.eet-china.com/mp/a68780.html)

### 1. 说说HTTP常用的状态码及其含义？

**思路:** 这道面试题主要考察候选人，是否掌握HTTP状态码这个基础知识点。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-de0ffa968b5a19102cdb73625f149d5f.png)

**不管是不是面试需要，我们都要知道，日常开发中的这几个状态码的含义哈：**

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-0953009dec9311039e7eedcd69dd6f07.png)

### 2. HTTP 常用的请求方式，区别和用途？

**思路:** 这道题主要考察候选人，是否掌握**HTTP请求方式**这个基础知识点，我们用得比较多就是**GET和POST**啦。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-24c57f6fb43b3c2766849173af549dee.png)

### 3. 请简单说一下你了解的端口及对应的服务？

![img](http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-b651e46b88d855f852c6a8f0d93fcc08.png)

### 4. 说下计算机网络体系结构

**思路:** 这道题主要考察候选人，**计算机网络体系结构**这个基础知识点。计算机网路体系结构呢，有三层：ISO七层模型、TCP/IP四层模型、五层体系结构。大家可以记住这个图，如下

![img](http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-7943d7dc8a2afb50c58f3467d45fa768.png)计算机网络体系结构

#### 4.1 ISO七层模型

ISO七层模型是国际标准化组织（International Organization for Standardization）制定的一个用于计算机或通信系统间互联的标准体系。

> ★
>
> - 应用层：网络服务与最终用户的一个接口，常见的协议有：**HTTP FTP  SMTP SNMP DNS**.
> - 表示层：数据的表示、安全、压缩。，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。
> - 会话层：建立、管理、终止会话,对应主机进程，指本地主机与远程主机正在进行的会话.
> - 传输层：定义传输数据的协议端口号，以及流控和差错校验,协议有**TCP UDP**.
> - 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择,协议有**ICMP IGMP IP等**.
> - 数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。
> - 物理层：建立、维护、断开物理连接。
>
> ”

#### 4.2 TCP/IP 四层模型

> ★
>
> - 应用层：对应于OSI参考模型的（应用层、表示层、会话层）。
> - 传输层: 对应OSI的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。
> - 网际层：对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。
> - 网络接口层：与OSI参考模型的数据链路层、物理层对应。
>
> ”

#### 4.3 五层体系结构

> ★
>
> - 应用层：对应于OSI参考模型的（应用层、表示层、会话层）。
> - 传输层：对应OSI参考模型的的传输层
> - 网络层：对应OSI参考模型的的网络层
> - 数据链路层：对应OSI参考模型的的数据链路层
> - 物理层：对应OSI参考模型的的物理层。
>
> ”

### 5 如何理解HTTP协议是无状态的

**思路:** 这道题主要考察候选人，是否理解Http协议，它为什么是无状态的呢？如何使它有状态呢？

如何理解无状态这个词呢？

> ★
>
> 当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。简言之，服务器不会去记住你是谁，所以是无状态协议。
>
> ”

可以通过一个生活中的例子，来更好理解并记住它：

**有状态场景：**

- 小红：今天吃啥子？
- 小明：罗非鱼~
- 小红：味道怎么样呀？
- 小明：还不错，好香。

**无状态的场景：**

- 小红：今天吃啥子？
- 小明：罗非鱼~
- 小红：味道怎么样呀？
- 小明：？啊？你说啥？什么鬼？什么味道怎么样？

**Http加了Cookie的话**：

- 小红：今天吃啥子？
- 小明：罗非鱼~
- 小红：你今天吃的罗非鱼，味道怎么样呀？
- 小明：还不错，好香。

### 6.从浏览器地址栏输入url到显示主页的过程

**思路:** 这道题主要考察的知识点是HTTP的请求过程，**DNS解析，TCP三次握手，四次挥手这几个要点**，我们都可以讲下。

1. DNS解析，查找域名对应的IP地址。
2. 与服务器通过三次握手，建立TCP连接
3. 向服务器发送HTTP请求
4. 服务器处理请求，返回网页内容
5. 浏览器解析并渲染页面
6. TCP四次挥手，连接结束

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-99845059382a3c88ea6190ef462d5432.png)

### 7. 说下HTTP/1.0，1.1，2.0的区别

**思路:** 这道题主要考察的知识点是HTTP几个版本的区别，我们记住**HTTP/1.0**默认是短连接，可以强制开启，HTTP/1.1默认长连接，HTTP/2.0采用**多路复用**就差不多啦。

**HTTP/1.0**

- 默认使用**短连接**，**每次请求都需要建立一个TCP连接**。它可以设置`Connection: keep-alive` 这个字段，强制开启长连接。

**HTTP/1.1**

- 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用。
- 分块传输编码，即服务端没产生一块数据，就发送一块，用”流模式”取代”缓存模式”。
- **管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求**。

**HTTP/2.0**

- 二进制协议，1.1版本的头信息是文本（ASCII编码），数据体可以是文本或者二进制；2.0中，**头信息和数据体都是二进制**。
- **完全多路复用**，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。
- **报头压缩**，HTTP协议不带有状态，每次请求都必须附上所有信息。Http/2.0引入了头信息压缩机制，使用gzip或compress压缩后再发送。
- **服务端推送**，允许服务器未经请求，主动向客户端发送资源。

### 8.  POST和GET有哪些区别？

**思路:** 这道题主要考察的知识点是POST和GET的区别，可以从**数据包、编码方式、请求参数、收藏为书签、历史记录、安全性**等几方面去回答哈。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-1d6684f23ca9fad8e14a636e9d2b3d36.png)

### 9. 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？

这个问题记住`keep-alive`就好，也就是说，在HTTP中响应体的**Connection**字段指定为`keep-alive`即可

### 10. HTTP 如何实现长连接？在什么时候会超时？

**思路:** 这道题实际上是考察TCP长连接的知识点，HTTP的长连接实质是指TCP的长连接。至于什么时候超时，我们记住这几个参数如**tcp_keepalive_time**、**tcp_keepalive_probes**就好啦

**什么是HTTP的长连接？**

- 1. HTTP分为长连接和短连接，**本质上说的是TCP的长短连接**。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才具有真正的长连接和短连接这一说法哈。

     

  2. TCP长连接可以复用一个TCP连接，来发起多次的HTTP请求，这样就可以减少资源消耗，比如一次请求HTML，如果是短连接的话，可能还需要请求后续的JS/CSS。

**如何设置长连接？**

通过在头部（请求和响应头）设置**Connection**字段指定为`keep-alive`，HTTP/1.0协议支持，但是是默认关闭的，从HTTP/1.1以后，连接默认都是长连接。

**在什么时候会超时呢？**

> ★
>
> - HTTP一般会有httpd守护进程，里面可以设置**keep-alive timeout**，当tcp连接闲置超过这个时间就会关闭，也可以在HTTP的header里面设置超时时间
> - TCP 的**keep-alive**包含三个参数，支持在系统内核的net.ipv4里面设置；当 TCP 连接之后，闲置了**tcp_keepalive_time**，则会发生侦测包，如果没有收到对方的ACK，那么会每隔 tcp_keepalive_intvl再发一次，直到发送了**tcp_keepalive_probes**，就会丢弃该连接。
>
> ”

```
1. tcp_keepalive_intvl = 15
2. tcp_keepalive_probes = 5
3. tcp_keepalive_time = 1800
```

### 11. HTTP 与 HTTPS 的区别。

**思路:** 这道题实际上考察的知识点是HTTP与HTTPS的区别，这个知识点非常重要，可以**从安全性、数据是否加密、默认端口**等这几个方面去回答哈。其实，当你理解HTTPS的整个流程，就可以很好回答这个问题啦。

**我的答案如下**：

HTTP，即超文本传输协议，是一个基于TCP/IP通信协议来传递明文数据的协议。HTTP会存在这**几个问题**：

- 请求信息是明文传输，容易被窃听截取。
- 没有验证对方身份，存在被冒充的风险
- 数据的完整性未校验，容易被中间人篡改

为了解决Http存在的问题，Https出现啦。

**Https是什么？**

**HTTPS= HTTP+SSL/TLS**，可以理解Https是身披SSL(Secure Socket Layer，安全套接层)的HTTP。

它们主要区别如下：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-9c2878c02a4e5545681e7c7b478e7b8c.png)

### 12 . Https流程是怎样的？

**思路:** 这道题实际上考察的知识点是HTTPS的工作流程，大家需要回答这几个要点，**公私钥、数字证书、加密、对称加密、非对称加密**。

- HTTPS = HTTP + SSL/TLS，也就是用SSL/TLS对数据进行加密和解密，Http进行传输。
- SSL，即Secure Sockets Layer（安全套接层协议），是**网络通信提供安全及数据完整性的一种安全协议**。
- TLS，即Transport Layer Security(安全传输层协议)，它是SSL3.0的后续版本。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-2fc53ca265032a799cb042bef2328eff.png)Https工作流程

1. 客户端发起Https请求，连接到服务器的443端口。
2. 服务器必须要有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。
3. 服务器将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。
4. 客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个**随机的对称密钥**，用证书的公钥加密。
5. 客户端将公钥加密后的密钥发送到服务器。
6. 服务器接收到客户端发来的密文密钥之后，用自己之前保留的**私钥对其进行非对称解密**，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。
7. 服务器将加密后的密文返回到客户端。
8. 客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。

### 13. 说说HTTP的状态码，301和302的区别？

**思路:** 这道题考查的知识点，也是HTTP状态码，302和301都有重定向的含义，但是它们也是有区别的。

- 301：（永久性转移）**请求的网页已被永久移动到新位置**。服务器返回此响应时，会自动将请求者转到新位置。
- 302：（暂时性转移）**服务器目前正从不同位置的网页响应请**求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应GET和HEAD请求的301代码类似，会自动将请求者转到不同的位置。

网上有个很**形象的例子**比喻：

> ★
>
> 当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，打个比方说，我有一套房子，但是最近走亲戚去亲戚家住了，过两天我还回来的。而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的，就比如你的那套房子其实是租的，现在租期到了，你又在另一个地方找到了房子，之前租的房子不住了。
>
> ”

### 14. 说说什么是数字签名？什么是数字证书？

**思路:** 这道题考查的知识点，不仅仅是数字签名，数字证书，很可能面试官也会问你https的原理的，因为https原理跟数字证书有关的哈，大家需要掌握https原理哦。

**数字证书是指在互联网通讯中标志通讯各方身份信息的一个数字认证**，人们可以在网上用它来识别对方的身份。它的出现，是为了避免身份被篡改冒充的。比如Https的数字证书，就是为了避免公钥被中间人冒充篡改：![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-203531ea8afd45f9e5977a413fdf0d39.png)

**数字证书构成**

- 公钥和个人等信息，**经过Hash摘要算法加密**，形成消息摘要；**将消息摘要拿到拥有公信力的认证中心（CA）**，用它的私钥对消息摘要加密，形成**数字签名**。
- 公钥和个人信息、数字签名共同构成**数字证书**。

### 15. 对称加密与非对称加密有什么区别

**思路:** 这道题考察的知识点是对称加密与非对称加密算法，什么是对称加密，什么是非对称加密呢？

对称加密：**指加密和解密使用同一密钥**，优点是运算速度较快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有：DES、AES等。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-5160c7c63880378968c9482fbd50b965.png)

非对称加密：**指的是加密和解密使用不同的密钥（即公钥和私钥）**。**公钥与私钥是成对存在的**，如果用公钥对数据进行加密，只有对应的私钥才能解密。常见的非对称加密算法有RSA。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-4c5bb2ec3c707d21fa13bed41beb9675.png)

### 16. 说说DNS的解析过程？

**思路:** 这道题考察的知识点是**DNS域名解析**，http请求的过程，是涉及到DNS域名解析的，这道面试题也挺经典的，大家可以看下《图解HTTP》那本书哈。

> ★
>
> DNS，英文全称是**domain name system**，域名解析系统，是Internet上作为域名和IP相互映射的一个分布式数据库。它的作用很明确，就是可以根据域名查出对应的IP地址。在浏览器缓存、本地DNS服务器、根域名服务器都是怎么查找的，大家回答的时候都可以说下哈。
>
> ”

DNS的解析过程如下图：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-7f57724c1058b99576f01aa357d09e4c.png)

假设你要查询**www.baidu.com**的IP地址:

> ★
>
> - 首先会查找浏览器的缓存,看看是否能找到**www.baidu.com**对应的IP地址，找到就直接返回；否则进行下一步。
> - 将请求发往给本地DNS服务器，如果查找到也直接返回，否则继续进行下一步；
> - 本地DNS服务器向**根域名服务器**发送请求，根域名服务器返回负责`.com`的顶级域名服务器的IP地址的列表。
> - 本地DNS服务器再向其中一个负责`.com`的顶级域名服务器发送一个请求，返回负责`.baidu`的权威域名服务器的IP地址列表。
> - 本地DNS服务器再向其中一个权威域名服务器发送一个请求，返回**www.baidu.com**所对应的IP地址。
>
> ”

### 17. 什么是CSRF攻击，如何避免

**思路:** 这道题考察的知识点是**CSRF攻击**，它是属于网络安全这块的知识点，还有**Xss攻击、SQL注入、DDoS**等这些常见的网络攻击，我们都需要知道攻击的流程哈。

**什么是CSRF 攻击？**

> ★
>
> CSRF，**跨站请求伪造**（英文全称是Cross-site request forgery），是一种**挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法**。
>
> ”

**CSRF是如何攻击的呢？**

来看一个来自百度百科的例子哈：

![img](http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-33e6252a833c8a51353bbbff2422a993.png)



- 1. Tom 登陆银行，没有退出，浏览器包含了Tom在银行的身份认证信息。

     

  2. 黑客Jerry将伪造的转账请求，包含在在帖子

     

  3. Tom在银行网站保持登陆的情况下，浏览帖子

     

  4. 将伪造的转账请求连同身份认证信息，发送到银行网站

     

  5. 银行网站看到身份认证信息，以为就是Tom的合法操作，最后造成Tom资金损失。

**怎么解决CSRF攻击呢？**

- 检查Referer字段。
- 添加校验token。

### 18. 聊聊五层计算机网络体系结构中，每一层对应的网络协议有哪些？

![img](http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-ba1e2d8a01c7492d49d39cb93378550f.png)

### 19. 说说 WebSocket与socket的区别

**思路:** 这是一个比较基础的知识点，经常有小伙伴会搞混。

- Socket其实就是等于**IP地址 + 端口 + 协议**。

> ★
>
> 具体来说，Socket是一套标准，它完成了对TCP/IP的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。
>
> ”

- **WebSocket是一个持久化的协议**，它是伴随H5而出的协议，用来解决**http不支持持久化连接**的问题。
- Socket一个是**网络编程的标准接口**，而WebSocket则是**应用层通信协议**。

### 20. 什么是DoS、DDoS、DRDoS攻击？

**思路:** 这是涉及网络安全的一个知识点，DDos还会挺常见的，如SYN Flood。

> ★
>
> - **DOS**: (Denial of Service),翻译过来就是**拒绝服务**,一切能引起DOS行为的攻击都被称为DOS攻击。最常见的DoS攻击就有**计算机网络宽带攻击**、**连通性攻击**。
> - **DDoS**: (Distributed Denial of Service),翻译过来是**分布式拒绝服务**。是指处于不同位置的多个攻击者同时向一个或几个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。常见的DDos有**SYN Flood、Ping of Death、ACK Flood、UDP Flood**等。
> - **DRDoS**: (Distributed Reflection Denial of Service)，中文是**分布式反射拒绝服务**，该方式靠的是发送大量带有被害者IP地址的数据包给攻击主机，然后攻击主机对IP地址源做出大量回应，从而形成拒绝服务攻击。
>
> ”

### 21. 什么是XSS攻击，如何避免?

**思路:** XSS攻击也是比较常见，XSS，叫**跨站脚本攻击（Cross-Site Scripting）**，因为会与层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，因此有人将跨站脚本攻击缩写为XSS。它指的是**恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的**。XSS攻击一般分三种类型：**存储型 、反射型 、DOM型XSS**

#### 21.1 XSS是如何攻击的呢？

拿反射型举个例子吧，流程图如下：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-31e42588913eadf80cb3e3e4e758f522.png)

#### 21.2 如何解决XSS攻击问题？

- 对输入进行过滤，过滤标签等，只允许合法值。
- HTML转义
- 对于链接跳转，如`<a href="xxx"` 等，要校验内容，禁止以script开头的非法链接。
- 限制输入长度

### 22. Http请求的过程与原理

**思路:** HTTP请求，一个非常非常基础的知识点，一定需要掌握的。其实觉得跟浏览器地址栏输入url到显示主页这道题有点类似。

**我的答案如下**：

HTTP是一个基于TCP/IP协议来传递数据的超文本传输协议，传输的数据类型有HTML,图片等。以访问百度有例子，看下一次Http的请求过程吧

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-d58966fe4854169509511d6bfc90de9d.png)Http请求过程

1. 客户端进行DNS域名解析，得到对应的IP地址
2. 根据这个IP，找到对应的服务器建立连接（三次握手）
3. 建立TCP连接后发起HTTP请求（一个完整的http请求报文）
4. 服务器响应HTTP请求，客户端得到html代码
5. 客户端解析html代码，用html代码中的资源(如js,css,图片等等)渲染页面。
6. 服务器关闭TCP连接（四次挥手）

### 23.  forward和redirect的区别？

**思路:** 这道题有点偏Java web方向的。以前记得刚出来实习找工作的时候，面试官可喜欢问这道题啦，当时我记的答案就是，forward是转发，redirect是重定向。

**我的答案如下**：

> ★
>
> - **直接转发方式（Forward）** ，客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。
> - **间接转发方式（Redirect）** 实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。
>
> ”

举个通俗的例子：

> ★
>
> - 直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；
> - 间接转发就相当于："A找B借钱，B说没有，让A去找C借"。**
>
> ”

看下这两个图，可以更容易理解一些:

- Redirect 的工作原理：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-cefd503ecf09d013ccca358f11037b83.png)

- forward 的工作原理

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-715a25ba54d8cfa72f52e05bc456f6fc.png)

### 24. 聊聊SQL注入？

**思路:** SQL注入是最经典的安全问题。无论你是前端开发还是后端开发，都必须掌握的。

> ★
>
> SQL注入是一种代码注入技术，一般被应用于攻击web应用程序。它**通过在web应用接口传入一些特殊参数字符，来欺骗应用服务器，执行恶意的SQL命令**，以达到非法获取系统信息的目的。它目前是黑客对数据库进行攻击的最常用手段之一。
>
> ”

#### 24.1 SQL注入是如何攻击的？

举个常见的**业务场景**：在web表单搜索框输入员工名字，然后后台查询出对应名字的员工。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-7fd7ced8659cbab7f5b89fc5dd808e62.png)

这种场景下，一般都是前端页面,把一个名字参数name传到后台，然后后台通过SQL把结果查询出来

```
name = "田螺"; //前端传过来的

SQL= "select * from staff where name=" + name;  //根据前端传过来的name参数，查询数据库员工表staff
```

因为SQL是直接拼接的，如果我们完全信任前端传的参数的话。假如前端传这么一个参数时`'' or '1'='1'`，SQL就变成酱紫的啦。

```
select * from staff where name='' or '1'='1';
```

这个SQL会把所有的员工信息全都查出来了，酱紫就请求用户已经越权啦。请求者可以获取所有员工的信息，信息已经暴露了啦。

#### 24.2 如何预防SQL注入问题

**1). 使用#{}而不是 ${}**

在MyBatis中,使用`#{}`而不是`${}`，可以很大程度防止sql注入。

- 因为`#{}`是一个参数占位符，对于字符串类型，会自动加上""，其他类型不加。由于Mybatis采用**预编译**，其后的参数不会再进行SQL编译，所以一定程度上防止SQL注入。
- `${}`是一个简单的字符串替换，字符串是什么，就会解析成什么，存在SQL注入风险

**2). 不要暴露一些不必要的日志或者安全信息，比如避免直接响应一些sql异常信息。**

如果SQL发生异常了，不要把这些信息暴露响应给用户，可以自定义异常进行响应

**3). 不相信任何外部输入参数，过滤参数中含有的一些数据库关键词关键词**

可以加个参数校验过滤的方法，过滤`union，or`等数据库关键词

**4). 适当的权限控制**

在你查询信息时，先校验下当前用户是否有这个权限。比如说，实现代码的时候，可以让用户多传一个企业Id什么的，或者获取当前用户的session信息等，在查询前，先校验一下当前用户是否是这个企业下的等等，是的话才有这个查询员工的权限。

### 25. Session和Cookie的区别。

**我们先来看Session和Cookie的概念吧：**

- Cookie是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个Cookie，客户端就把Cookie保存起来。在客户端下次向同一服务器再发起请求时，Cookie被携带发送到服务器。服务器就是根据这个Cookie来确认身份的。
- session指的就是服务器和客户端一次会话的过程。Session利用Cookie进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个Session结束时，其实就是意味着这个Cookie就过期了。Session对象存储着特定用户会话所需的属性及配置信息。

**Session 和Cookie的区别主要有这些：**

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-1a7151f7c2bb75d9f9f56a0e5184c1c1.png)

来看个图吧：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-644bd68fcbe1dfa2f637b894aac49579.png)

> ★
>
> - 用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的Session，请求返回时将此Session的唯一标识信息SessionID返回给浏览器，浏览器接收到服务器返回的SessionID信息后，会将此信息存入Cookie中，同时Cookie记录此SessionID是属于哪个域名。
> - 当用户第二次访问服务器时，请求会自动判断此域名下是否存在Cookie信息，如果存在，则自动将Cookie信息也发送给服务端，服务端会从Cookie中获取SessionID，再根据 SessionID查找对应的 Session信息，如果没有找到，说明用户没有登录或者登录失效，如果找到Session证明用户已经登录可执行后面操作。
>
> ”

### 26. IP地址有哪些分类？

一般可以这么认为，IP地址=网络号+主机号。

1. 网络号：它标志主机所连接的网络地址表示属于互联网的哪一个网络。
2. 主机号：它标志主机地址表示其属于该网络中的哪一台主机。

IP地址分为A，B，C，D，E五大类：

- A类地址(1~126)：**以0开头，网络号占前8位**，主机号占后面24位。
- B类地址(128~191)：**以10开头，网络号占前16位**，主机号占后面16位。
- C类地址(192~223)：**以110开头，网络号占前24位**，主机号占后面8位。
- D类地址(224~239)：以1110开头，保留位多播地址。
- E类地址(240~255)：以11110开头，保留位为将来使用

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-faa187d21caaf4e7283eb57118ab21dc.png)IP地址分类

### 27. 说下ARP 协议的工作过程？

ARP 协议协议，**Address Resolution Protocol**，**地址解析协议**，它是用于实现IP地址到MAC地址的映射。

> ★
>
> - 1. 首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。
>   2. 当源主机需要将一个数据包要发送到目的主机时，会首先检查自己的ARP列表，是否存在该IP地址对应的MAC地址；如果有﹐就直接将数据包发送到这个MAC地址；如果没有，就向**本地网段发起一个ARP请求的广播包**，查询此目的主机对应的MAC地址。此ARP请求的数据包里，包括源主机的IP地址、硬件地址、以及目的主机的IP地址。
>   3. 网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同，就会忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。
>   4. 源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。
>
> ”

### 28. 有了IP地址，为什么还要用MAC地址？

> ★
>
> - 简而言之，标识网络中的一台计算机，比较常用的就是**IP地址和MAC地址**，但计算机的IP地址可由用户自行更改，管理起来就相对困难，而MAC地址不可更改，所以一般会把IP地址和MAC地址组合起来使用。
> - 那只使用MAC地址不用IP地址行不行呢？不行的！因为最早就是MAC地址先出现的，并且当时并不用IP地址，只用MAC地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可。
> - 那为什么要用IP地址呢？是因为IP地址是和地域相关的，对于同一个子网上的设备，IP地址的前缀都是一样的，这样路由器通过IP地址的前缀就知道设备在在哪个子网上了，而只用MAC地址的话，路由器则需要记住每个MAC地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。
> - I**P地址可以比作为地址，MAC地址为收件人**，在一次通信过程中，两者是缺一不可的。
>
> ”

### 29. TCP 和 UDP 分别对应的常见应用层协议有哪些？

**基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH**

- **HTTP**：HyperText Transfer Protocol（超文本传输协议），默认端口80
- **FTP**: File Transfer Protocol (文件传输协议), 默认端口(20用于传输数据，21用于传输控制信息)
- **SMTP**: Simple Mail Transfer Protocol (简单邮件传输协议) ,默认端口25
- **TELNET**: Teletype over the Network (网络电传), 默认端口23
- **SSH**：Secure Shell（安全外壳协议），默认端口 22

**基于UDP的应用层协议：DNS、TFTP、SNMP**

- **DNS** : Domain Name Service (域名服务),默认端口 53
- **TFTP**: Trivial File Transfer Protocol (简单文件传输协议)，默认端口69
- **SNMP**：Simple Network Management Protocol（简单网络管理协议），通过UDP端口161接收，只有Trap信息采用UDP端口162。

### 30. 聊聊保活计时器的作用

除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了TCP连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。

服务器每收到一次客户的数据，就**重新设置保活计时器，时间的设置通常是两个小时**。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75秒钟发送一次。若连续发送10个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。

### 31. 如果服务器出现了大量CLOSE_WAIT状态如何解决。

我们先来复习下TCP的四次挥手

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-44ee0cb73ea8397feb1977d138f8f995.png)

- 服务器端收到客户端发送的`FIN`后，TCP协议栈就会**自动发送ACK**，接着进入**CLOSE_WAIT**状态。
- 但是如果服务器端不执行socket的close()操作，那么就没法进入LAST_ACK,导致大量连接处于CLOSE_WAIT状态
- 所以，如果服务器出现了大量**CLOSE_WAIT**状态，一般是**程序Bug，或者关闭socket不及时**。

### 32. URI和URL的区别

- URI，全称是Uniform Resource Identifier)，中文翻译是**统一资源标志符**，主要作用是唯一标识一个资源。
- URL，全称是Uniform Resource Location)，中文翻译是**统一资源定位符**，主要作用是提供资源的路径。打个经典比喻吧，URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。

### 33. ICMP协议的功能

ICMP,Internet Control Message Protocol ,Internet控制消息协议。

- ICMP协议是一种**面向无连接**的协议，用于传输出错报告控制信息。
- 它是一个非常重要的协议，它对于网络安全具有极其重要的意义。它属于**网络层协议**，主要用于在主机与路由器之间传递控制信息，包括**报告错误、交换受限控制和状态信息**等。
- 当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。

比如我们日常使用得比较多的**ping**，就是基于ICMP的。

### 35. 说下ping的原理

> ★
>
> ping，**Packet Internet Groper**，是一种因特网包探索器，用于测试网络连接量的程序。Ping是工作在TCP/IP网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送ICMP（Internet Control Message Protocol 因特网报文控制协议） 请求报文，测试目的站是否可达及了解其有关状态
>
> ”

一般来说，ping可以用来检测网络通不通。它是基于`ICMP`协议工作的。假设**机器A** ping**机器B**，工作过程如下：

1. ping通知系统，新建一个固定格式的ICMP请求数据包
2. ICMP协议，将该数据包和目标机器B的IP地址打包，一起转交给IP协议层
3. IP层协议将本机IP地址为源地址，机器B的IP地址为目标地址，加上一些其他的控制信息，构建一个IP数据包
4. 先获取目标机器B的MAC地址。
5. 数据链路层构建一个数据帧，目的地址是IP层传过来的**MAC地址**，源地址是本机的**MAC地址**
6. 机器B收到后，对比目标地址，和自己本机的MAC地址是否一致，符合就处理返回，不符合就丢弃。
7. 根据目的主机返回的ICMP回送回答报文中的时间戳，从而计算出往返时间
8. 最终显示结果有这几项：发送到目的主机的IP地址、发送 & 收到 & 丢失的分组数、往返时间的最小、最大& 平均值

### 36. 请详细介绍一下TCP 的三次握手机制

**思路:** TCP连接的三次握手机制，最重要的知识点，必须得会，通讯过程以及客户端、服务器的对应的状态都需要记住哈。

TCP提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的就是同步连接双方的序列号和确认号并交换TCP窗口大小信息。我们一起来看下流程图哈：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-eaaf3fdfd9c7a2b0390fa7a7973f2218.png)TCP三次握手

- 第一次握手(SYN=1, seq=x)，发送完毕后，客户端就进入SYN_SEND状态
- 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服务器端就进入SYN_RCV状态。
- 第三次握手(ACK=1，ACKnum=y+1)，发送完毕后，客户端进入ESTABLISHED状态，当服务器端接收到这个包时，也进入ESTABLISHED状态。

### 37. TCP握手为什么是三次，为什么不能是两次？不能是四次？

**思路:** TCP握手为什么不能是两次，为什么不能是四次呢？为了方便理解，我们以男孩子和女孩子谈恋爱为例子：两个人能走到一起，最重要的事情就是相爱，就是**我爱你，并且我知道，你也爱我**，接下来我们以此来模拟三次握手的过程：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-f795189dd1254b2b5765b0a617198b9c.png)

**为什么握手不能是两次呢？**

如果只有两次握手，女孩子可能就不知道，她的那句**我也爱你**，男孩子是否**收到**，恋爱关系就不能愉快展开。

**为什么握手不能是四次呢？**

因为握手不能是四次呢？因为三次已经够了，三次已经能让双方都知道：你爱我，我也爱你。而四次就多余了。

### 38. 说说TCP四次挥手过程

**思路:** TCP的四次挥手，也是最重要的知识点，一般跟三次握手会一起考的，必须得记住。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-8d9d9e5c274d6b4cc3deb1767d67d1f8.png)TCP四次挥手过程

1. 第一次挥手(FIN=1，seq=u)，发送完毕后，客户端进入**FIN_WAIT_1**状态。
2. 第二次挥手(ACK=1，ack=u+1,seq =v)，发送完毕后，服务器端进入**CLOSE_WAIT**状态，客户端接收到这个确认包之后，进入**FIN_WAIT_2**状态。
3. 第三次挥手(FIN=1，ACK1,seq=w,ack=u+1)，发送完毕后，服务器端进入**LAST_ACK**状态，等待来自客户端的最后一个ACK。
4. 第四次挥手(ACK=1，seq=u+1,ack=w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入TIME_WAIT状态，**等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后**，没有收到服务器端的ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入CLOSED状态。服务器端接收到这个确认包之后，关闭连接，进入CLOSED状态。

### 39. TCP挥手为什么需要四次呢？

**思路：** TCP挥手为什么需要四次呢？为了方便大家理解，再举个生活的例子吧。

> ★
>
> 小明和小红打电话聊天，通话差不多要结束时，小红说，“我没啥要说的了”。小明回答，“我知道了”。但是小明可能还有要说的话，小红不能要求小明跟着她自己的节奏结束通话，于是小明可能又叽叽歪歪说了一通，最后小明说，“我说完了”，小红回答，“我知道了”，这样通话才算结束。
>
> ”

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-d1851a1a8ede59ee850fd57e2f09b05b.png)

### 40. TCP四次挥手过程中，为什么需要等待2MSL,才进入CLOSED关闭状态

**思路：** 这个**问得频率特别高**。去面试前，一定要把这道题拿下哈。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-44ee0cb73ea8397feb1977d138f8f995.png)

2MSL，**two Maximum Segment Lifetime**，即两个最大段生命周期。假设**主动发起挥手的是客户端**，那么需要2MSL的原因是：

> ★
>
> - **1.为了保证客户端发送的最后一个ACK报文段能够到达服务端。** 这个ACK报文段有可能丢失，因而使处在**LAST-ACK**状态的服务端就收不到对已发送的**FIN + ACK**报文段的确认。服务端会超时重传这个FIN+ACK 报文段，而客户端就能在 2MSL 时间内（**超时 + 1MSL 传输**）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动2MSL计时器。最后，客户端和服务器都正常进入到**CLOSED**状态。
> - **2. 防止已失效的连接请求报文段出现在本连接中**。客户端在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。
>
> ”

### 41. TCP的粘包和拆包

TCP是面向流，没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一**个完整的包可能会被TCP拆分成多个包进行发送**，**也有可能把多个小的包封装成一个大的数据包发送**，这就是所谓的TCP粘包和拆包问题。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-8dec9e57094f083991b19a6ba95c49fe.png)TCP的粘包和拆包

**为什么会产生粘包和拆包呢?**

- 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；
- 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；
- 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度>MSS。

**解决方案：**

- 发送端将每个数据包封装为固定长度
- 在数据尾部增加特殊字符进行分割
- 将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。

### 42. 聊聊TCP的流量控制

TCP三次握手，发送端和接收端进入到ESTABLISHED状态，它们即可以愉快地传输数据啦。

但是发送端不能疯狂地向接收端发送数据，因为接收端接收不过来的话，接收方只能把处理不过来的数据存在缓存区里。如果缓存区都满了，发送方还在疯狂发送数据的话，接收方只能把收到的数据包丢掉，这就浪费了网络资源啦。

> ★
>
> TCP 提供一种机制可以**让发送端根据接收端的实际接收能力控制发送的数据量**，这就是**流量控制**。
>
> ”

TCP通过滑动窗口来控制流量，我们看下流量控制的**简要流程**吧：

首先双方三次握手，初始化各自的窗口大小，均为 400 个字节。

![img](http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-8f6389c120734508b1e3367a8a8c4d9f.png)TCP的流量控制

1. 假如当前发送方给接收方发送了200个字节，那么，发送方的`SND.NXT`会右移200个字节，也就是说当前的可用窗口减少了200 个字节。
2. 接受方收到后，放到缓冲队列里面，REV.WND =400-200=200字节，所以win=200字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口200字节
3. 发送方又发送200字节过来，200字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理100字节，剩余的100字节继续放到缓冲队列。这时候，REV.WND = 400-200-100=100字节，即win=100返回发送方。
4. 发送方继续干活，发送100字节过来，这时候，接受窗口win变为0。
5. 发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到win大于0，才继续开始发送。

### 43. 说说半连接队列和 SYN Flood攻击的关系

**思路讲解：** 我以前面试的时候，面试官就问我什么是半连接队列、什么是全连接队列，哈哈。我们需要掌握半连接队列、全连接对列是啥，还需要清楚半连接队列和 SYN Flood攻击有什么关系。

**我的答案如下：**

TCP进入三次握手前，服务端会从**CLOSED**状态变为**LISTEN**状态,同时在内部创建了两个队列：半连接队列（SYN队列）和全连接队列（ACCEPT队列）。

什么是**半连接队列（SYN队列）** 呢? 什么是**全连接队列（ACCEPT队列）** 呢？回忆下TCP三次握手的图：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-7038b6e7d52a9cc580b6071a705ad61a.png)

- TCP三次握手时，客户端发送SYN到服务端，服务端收到之后，便回复**ACK和SYN**，状态由**LISTEN变为SYN_RCVD**，此时这个连接就被推入了**SYN队列**，即半连接队列。
- 当客户端回复ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入ACCEPT队列，即全连接队列。

SYN Flood是一种典型的DDos攻击，它在短时间内，伪造**不存在的IP地址**,向服务器大量发起SYN报文。当服务器回复SYN+ACK报文后，不会收到ACK回应报文，导致服务器上建立大量的半连接半连接队列满了，这就无法处理正常的TCP请求啦。

那么有哪些方案应对呢？主要有 **syn cookie**和**SYN Proxy防火墙**等。

> ★
>
> - **syn cookie**：在收到SYN包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个cookie值作为自己的SYNACK包的序列号，回复SYN+ACK后，服务器并不立即分配资源进行处理，等收到发送方的ACK包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。
> - **SYN Proxy防火墙**：服务器防火墙会对收到的每一个SYN报文进行代理和回应，并保持半连接。等发送方将ACK包返回后，再重新构造SYN包发到服务器，建立真正的TCP连接。
>
> ”

### 44. 聊聊TCP的滑动窗口

**思路讲解：** TCP滑动窗口是个高频考点，我们需要知道TCP报文首部有个字段**win**控制窗口大小的，同时也需要掌握，滑动窗口是怎么滑的。

TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。这样的话就会有个缺点：效率会比较低。

> ★
>
> 这就好像我们面对面在聊天，你说完一句，我应答之后，你才能说下一句。那么，如果我在忙其他事情，没有能够及时回复你呢？你说完一句后，要等到我忙完回复你，你才说下句，这显然不现实，效率太低。
>
> ”

为了解决这个问题，TCP引入了**窗口**，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。

TCP头部有个字段叫win，也即那个**16位的窗口大小**，它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到**流量控制**的目的。

> ★
>
> 通俗点讲，就是接受方每次收到数据包，在发送确认报文的时候，同时告诉发送方，自己的缓存区还有多少空余空间，缓冲区的空余空间，我们就称之为接受窗口大小。这就是win。
>
> ”

TCP 滑动窗口分为两种: 发送窗口和接收窗口。**发送端的滑动窗口**包含四大部分，如下：

- 已发送且已收到ACK确认
- 已发送但未收到ACK确认
- 未发送但可以发送
- 未发送也不可以发送

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-ae709e0823e9e85ae50a98d6254ef491.png)

- 虚线矩形框，就是发送窗口。
- SND.WND: 表示发送窗口的大小,上图虚线框的格子数是14个，即发送窗口大小是14。
- SND.NXT：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。
- SND.UNA: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。

接收方的滑动窗口包含三大部分，如下：

- 已成功接收并确认
- 未收到数据但可以接收
- 未收到数据并不可以接收的数据

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-886a4ca16926fd89d193095a8c6ccb5f.png)

- 虚线矩形框，就是接收窗口。
- REV.WND: 表示接收窗口的大小,上图虚线框的格子就是9个。
- REV.NXT:下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。

### 45. TCP的拥塞控制

**思路讲解：** TCP拥塞机制也是个高频考点，需要掌握**它跟流量控制**的区别，也需要掌握拥塞控制的这几种算法：**慢启动算法、拥塞避免、拥塞发生、快速恢复算法**。

拥塞控制是**作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况**。它的目标主要是最大化利用网络上瓶颈链路的带宽。它跟**流量控制**又有什么区别呢？流量控制是**作用于接收者**的，根据**接收端的实际接收能力控制发送速度**，防止分组丢失的。

我们可以把网络链路比喻成一根水管，如果我们想最大化利用网络来传输数据，那就是尽快让水管达到最佳充满状态。

![img](http://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/xinyu-images/MBXY-CR-e05ea7c279a7308a5bc041dbab7152f6.png)

发送方维护一个**拥塞窗口cwnd（congestion window）** 的变量，用来估算在一段时间内这条链路（水管）可以承载和运输的数据（水）的数量。它大小代表着网络的拥塞程度，并且是动态变化的，但是为了达到最大的传输效率，我们该如何知道这条水管的运送效率是多少呢？

一个比较简单的方法就是不断增加传输的水量，直到水管快要爆裂为止（对应到网络上就是发生丢包），用 TCP的描述就是：

> ★
>
> 只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。
>
> ”

实际上，拥塞控制主要有这几种常用算法

- 慢启动
- 拥塞避免
- 拥塞发生
- 快速恢复

#### 45.1 慢启动算法

慢启动算法，表面意思就是，别急慢慢来。它表示TCP建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，**每收到一个ACK，就将拥塞窗口cwnd大小就加1（单位是MSS）**。**每轮次**发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。

- TCP连接完成，初始化cwnd = 1，表明可以传一个MSS单位大小的数据。
- 每当收到一个ACK，cwnd就加一;
- 每当过了一个RTT，cwnd就增加一倍; 呈指数让升

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-8b9d6208fc78c82a044d96f57d5ff787.png)

为了防止cwnd增长过大引起网络拥塞，还需设置一个**慢启动阀值ssthresh**（slow start threshold）状态变量。当`cwnd`到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当**cwnd >ssthresh**时，进入了**拥塞避免**算法。

#### 45.2 拥塞避免算法

一般来说，慢启动阀值ssthresh是65535字节，`cwnd`到达**慢启动阀值**后

- 每收到一个ACK时，cwnd = cwnd + 1/cwnd
- 当每过一个RTT时，cwnd = cwnd + 1

显然这是一个线性上升的算法，避免过快导致网络拥塞问题。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-0bce7b07782db19233b98cdd54ed6121.png)

#### 45.3 拥塞发生

当网络拥塞发生**丢包**时，会有两种情况：

- RTO超时重传
- 快速重传

如果是发生了**RTO超时重传**，就会使用拥塞发生算法

- 慢启动阀值sshthresh =  cwnd /2
- cwnd 重置为 1
- 进入新的慢启动过程

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-373e0f394792af9c44face0f2852abff.png)

这真的是**辛辛苦苦几十年，一朝回到解放前**。其实还有更好的处理方式，就是**快速重传**。发送方收到3个连续重复的ACK时，就会快速地重传，不必等待**RTO超时**再重传。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-311271a6e184c49c37a2e3b2bfd9af61.png)image.png

慢启动阀值ssthresh 和 cwnd 变化如下：

- 拥塞窗口大小 cwnd = cwnd/2
- 慢启动阀值 ssthresh = cwnd
- 进入快速恢复算法

#### 45.4 快速恢复

快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有3个重复ACK收到，说明网络也没那么糟糕，所以没有必要像RTO超时那么强烈。

正如前面所说，进入快速恢复之前，cwnd 和 sshthresh已被更新：

```
- cwnd = cwnd /2
- sshthresh = cwnd
```

然后，真正的快速算法如下：

- cwnd = sshthresh  + 3
- 重传重复的那几个ACK（即丢失的那几个数据包）
- 如果再收到重复的 ACK，那么 cwnd = cwnd +1
- 如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-8537366c7623840fd7065dd671ddbe40.png)

### 46.请简述TCP和UDP的区别

**思路：** 这道题，校招的时候，问的概率高点，概念性的东西，**TCP是面向连接，而UDP是无连接**。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-fd1699aa297fdd9d109808150b5a71fa.png)

### 47. 说说TCP是如何确保可靠性的呢？

**思路：** TCP是可靠的连接，为什么具有可靠性呢？记住这些点：**连接和断开的可靠性（三次握手，四次挥手）、有状态（哪些数据发送了，哪些没发）、可控制（超时重传、流量控制、拥塞控制等）**。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-40cdc0971e2f18c22df708ddeca79ade.png)

- 首先，TCP的连接是基于**三次握手**，而断开则是基于**四次挥手**。确保连接和断开的可靠性。
- 其次，TCP的可靠性，还体现在**有状态**;TCP会记录哪些数据发送了，哪些数据被接收了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。
- 再次，TCP的可靠性，还体现在**可控制**。它有数据包校验、ACK应答、**超时重传(发送方)**、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。

### 48. 说说TCP报文首部有哪些字段，其作用又分别是什么？

**思路：** 小伙伴们，可以记下这个图。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-cf87753017b42de921f71c11746cc6cf.png)

- **16位端口号**：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序
- **32位序号**：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。
- **32位确认号**：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。
- **4位头部长度**：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。
- **6位标志位**：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）
- **16位窗口大小**：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。
- **16位校验和**：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。
- **16位紧急指针**：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。

### 49. Nagle 算法与延迟确认

#### 49.1 Nagle算法

如果发送方疯狂地向接收方发送很小的数据包，比如一次就发送1个字节，那么显然会有问题。

> ★
>
> TCP/IP协议中，无论发送多少数据，总是需要在数据前面加上协议头，同时，对方接收到数据，也需要发送ACK表示确认。为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的数据。**Nagle算法**就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。
>
> ”

Nagle算法：**任意时刻，最多只能有一个未被确认的小段**。所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。

Nagle算法的实现规则：

> ★
>
> - 如果包长度达到MSS，则允许发送；
> - 如果该包含有FIN，则允许发送；
> - 设置了TCP_NODELAY选项，则允许发送；
> - 未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；
> - 上述条件都未满足，但发生了超时（一般为200ms），则立即发送。
>
> ”

#### 49.2 延迟确认

如果接受方刚接收到发送方的数据包，在很短很短的时间内，又接收到第二个包。那么请问接收方是一个一个地回复好点，还是合在一起回复好呢？

> ★
>
> 接收方收到数据包后，如果暂时没有数据要发给对端，它可以等一小段时间，再确认（Linux上默认是40ms）。如果这段时间刚好有数据要传给对端，ACK就随着数据传输，而不需要单独发送一次ACK。如果超过时间还没有数据要发送，也发送ACK，避免对端以为丢包。
>
> ”

但是有些场景不能用延迟确认，比如发现了**乱序包**、**接收到了大于一个 frame 的报文，且需要调整窗口大小**等。

一般情况下，**Nagle算法和延迟确认**不能一起使用，Nagle算法意味着延迟发，**延迟确认**意味着延迟接收，酱紫就会造成更大的延迟，会产生性能问题。

### 50. 说说TCP的重传机制

**思路讲解：** TCP的重传机制，也是道非常高频的面试题。重传包括**超时重传、快速重传、带选择确认的重传（SACK）、重复SACK四种**。

#### 50.1 超时重传

超时重传，是TCP协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。

这个一定时间内，一般是多少比较合理呢？来看下什么叫**RTT（Round-Trip Time，往返时间）**。

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-69f6f681275c215367e3018831d76ac8.png)

RTT就是数据完全发送完，到收到确认信号的时间，即数据包的一次往返时间。超时重传时间，就是RTO（Retransmission Timeout)。

那么，**RTO到底设置多大呢？**

- 如果RTO设置很大，等了很久都没重发，这样肯定就不行。
- 如果RTO设置很小，那很可能数据都没有丢失，就开始重发了，这会导致网络阻塞，从而恶性循环，导致更多的超时出现。

一般来说，RTO略微大于RTT，效果是最佳的。其实，RTO有个标准方法的计算公式，也叫**Jacobson / Karels 算法**。一起来看下吧：

**1. 首先计算SRTT（即计算平滑的RTT）**

```
SRTT = (1 - α) * SRTT + α * RTT  //求 SRTT 的加权平均
```

**2. 其次，计算RTTVAR (round-trip time variation)**

```
RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|) //计算 SRTT 与真实值的差距
```

**3. 最后，得出最终的RTO**

```
RTO = µ * SRTT + ∂ * RTTVAR  =  SRTT + 4·RTTVAR  
```

一般情况，α、β等的参数取值如下：

```
α = 0.125，β = 0.25， μ = 1，∂ = 4
```

别问这些参数是怎么来的，它们是大量实践，调出的最优参数。

超时重传不是十分完美的重传方案，它有这些缺点：

> ★
>
> - 当一个报文丢失时，会等待一定的超时周期，才重传分组，增加了端到端的时延。
> - 当一个报文丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。
>
> ”

并且，对于TCP，如果发生一次超时重传，时间间隔下次就会加倍。

#### 50.2 快速重传

其实可以使用**快速重传**，来解决超时重发的时间等待问题。它不以时间驱动，而是以数据驱动。它是基于接收端的反馈信息来引发重传的。快速重传流程如下：

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-fc905a42c5917b66a1d9476b7fa1e71b.png)快速重传流程

发送方发送了 1，2，3，4，5,6份数据:

- 第一份 Seq=1 先送到了，于是就 Ack回2；
- 第二份 Seq=2 也送到了，于是ACK回3；
- 第三份 Seq=3 由于网络等某些原因，没送到；
- 第四份 Seq=4 送到了，但是由于Seq=3没收到。因此ACK还是回3；
- 后面的 Seq=5,6的也送到了，ACK还是回复3，因为Seq=3没有收到。
- 发送方连着收到三个重复冗余ACK=3的确认（其实是4个哈，但是因为前面的一个是正常的ACK，后面三个才是重复冗余的），于是知道哪个报文段在传输过程中丢失了；发送方在定时器过期之前，重传该报文段。
- 最后，接收方收到了 Seq=3，此时因为 Seq=4，5，6都收到了，于是它回ACK=7。

但是呢，**快速重传**也可能有问题：ACK只向告知发送方，最大的有序报文段。到底是哪个报文丢失了呢？**并不确定**！那到底该重传多少个包呢？

> ★
>
> 是重传 Seq=3 ？还是重传 Seq=3、Seq=4、Seq=5、Seq=6 呢？因为发送端并不清楚这三个连续的 ACK=3 是谁传回来的。
>
> ”

#### 50.3 带选择确认的重传（SACK）

为了解决：**应该重传多少个包**的问题? TCP提供了**带选择确认的重传**（即SACK，Selective Acknowledgment）。

> ★
>
> **SACK机制**就是，在快速重传的基础上，接收方返回最近收到报文段的序列号范围，这样发送方就知道接收方哪些数据包是没收到的。这样就很清楚应该重传哪些数据包啦。
>
> ”

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-2f299dcc517551ba3f3e2da95457e661.png)SACK机制

如上图中，发送方收到了三次同样的ACK=30的确认报文，于是就会触发快速重发机制，通过SACK信息发现只有`30~39`这段数据丢失，于是重发时，就只选择了这个`30~39`的TCP报文段进行重发。

#### 50.4 重复SACK（D-SACK）

> ★
>
> D-SACK，英文是Duplicate SACK，是在SACK的基础上做了一些扩展，主要用来告诉发送方，有哪些数据包，自己重复接受了。DSACK的目的是帮助发送方判断，是否发生了包失序、ACK丢失、包重复或伪重传。让TCP可以更好的做网络流控。来看个图吧：
>
> ”

![img](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/MBXY-CR-597f59d6bb0af8567da78be599e27ddc.png)
