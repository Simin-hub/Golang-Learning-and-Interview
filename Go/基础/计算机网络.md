# 计算机网络

[参考](https://segmentfault.com/a/1190000038526729)

## 网络协议

### 什么是网络协议，为什么要对网络协议分层

网络协议是计算机在通信过程中要遵循的一些约定好的规则。

网络分层的原因：

- 易于实现和维护，因为各层之间是独立的，层与层之间不会收到影响。
- 有利于标准化的制定

### 计算机网络的各层协议及作用

> 计算机网络体系可以大致分为一下三种，**OSI七层模型**、**五层模型和TCP/IP四层模型**，一般面试能流畅回答出五层模型就可以了，表示层和会话层被问到的不多。

![](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/1460000038526735.png)

- 应用层

  应用层的任务是**通过应用进程之间的交互来完成特定的网络作用**，常见的应用层协议有**域名系统DNS，HTTP协议**等。

- 表示层

  表示层的**主要作用是数据的表示、安全、压缩**。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。

- 会话层

  会话层的**主要作用是建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话**，决定通信是否被中断以及通信中断时决定从何处重新发送。

- 传输层

  传输层的**主要作用是负责向两台主机进程之间的通信提供数据传输服务。**传输层的协议主要有**传输控制协议TCP和用户数据协议UDP**。

- 网络层

  网络层的**主要作用是选择合适的网间路由和交换结点，确保数据及时送达**。常见的协议有**IP协议**。

- 数据链路层

  数据链路层的作用是**在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）**在信道上无差错的传输，并进行各电路上的动作系列。 **常见的协议有SDLC、HDLC、PPP**等。

- 物理层

  物理层的主要作用是实现相邻计算机结点之间比特流的透明传输，并尽量屏蔽掉具体传输介质和物理设备的差异。

## 应用层

### URI和URL的区别

- URI(Uniform Resource Identifier)：中文全称为**统一资源标志符，主要作用是唯一标识一个资源**。
- URL(Uniform Resource Location)：中文全称为**统一资源定位符，主要作用是提供资源的路径**。

有个经典的比喻是URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。



### DNS

#### DNS的工作流程

DNS的定义：DNS的全称是domain name system，即域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的去访问互联网而不用去记住能够被机器直接读取的IP地址。比如大家访问百度，更多地肯定是访问www.baidu.com，而不是访问112.80.248.74，因为这几乎无规则的IP地址实在太难记了。DNS要做的就是将www.baidu.com解析成112.80.248.74。



## 传输层

### TCP与UDP有什么区别

|      | 是否面向连接 | 可靠性 |  传输形式  | 传输效率 | 消耗资源 |   应用场景    | 首部字节 |
| :--: | :----------: | :----: | :--------: | :------: | :------: | :-----------: | :------: |
| TCP  |   面向连接   |  可靠  |   字节流   |    慢    |    多    | 文件/邮件传输 |  20~60   |
| UDP  |    无连接    | 不可靠 | 数据报文段 |    快    |    少    | 视频/语音传输 |    8     |

> 有时候面试还会问到TCP的首部都包含什么

- TCP首部(图片来源于网络)：

  前20个字节是固定的，后面有4n个字节是根据需而增加的选项，所以TCP首部最小长度为20字节。

![在这里插入图片描述](https://segmentfault.com/img/remote/1460000038526734)

- UDP首部(图片来源于网络)：

  UDP的首部只有8个字节，**源端口号、目的端口号、长度和校验和各两个字节**。

![在这里插入图片描述](https://segmentfault.com/img/remote/1460000038526736)

### TCP协议如何保证可靠传输

> 主要有校验和、序列号、超时重传、流量控制及拥塞避免等几种方法。

- **校验和：在发送算和接收端分别计算数据的校验和，**如果两者不一致，则说明数据在传输过程中出现了差错，TCP将丢弃和不确认此报文段。
- **序列号：TCP会对每一个发送的字节进行编号**，接收方接到数据后，会对发送方发送确认应答(ACK报文)，并且这个ACK报文中带有相应的确认编号，告诉发送方，下一次发送的数据从编号多少开始发。如果发送方发送相同的数据，接收端也可以通过序列号判断出，直接将数据丢弃。如果

![在这里插入图片描述](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/1460000038526737)

- **超时重传**：在上面说了序列号的作用，但如果发送方在发送数据后一段时间内（可以设置重传计时器规定这段时间）没有收到确认序号ACK，那么发送方就会重新发送数据。

  这里**发送方没有收到ACK可以分两种情况**，**如果是发送方发送的数据包丢失了**，接收方收到发送方重新发送的数据包后会马上给发送方发送ACK；**如果是接收方之前接收到了发送方发送的数据包，而返回给发送方的ACK丢失了**，这种情况，发送方重传后，接收方会**直接丢弃发送方冲重传的数据包**，然后再次发送ACK响应报文。

  如果数据被重发之后**还是没有收到接收方的确认应答**，则进行再次发送。此时，**等待确认应答的时间将会以2倍、4倍的指数函数延长，直到最后关闭连接**。

- **流量控制**：如果发送端发送的数据太快，接收端来不及接收就会出现丢包问题。为了解决这个问题，**TCP协议利用了滑动窗口进行了流量控制**。在TCP首部有一个16位字段大小的窗口，**窗口的大小就是接收端接收数据缓冲区的剩余大小**。接收端会在收到数据包后发送ACK报文时，将自己的窗口大小填入ACK中，发送方会根据ACK报文中的窗口大小进而控制发送速度。如果窗口大小为零，发送方会停止发送数据。

- **拥塞控制**：如果网络出现拥塞，则会产生丢包等问题，这时发送方会将丢失的数据包继续重传，网络拥塞会更加严重，所以在网络出现拥塞时应注意控制发送方的发送数据，降低整个网络的拥塞程度。**拥塞控制主要有四部分组成：慢开始、拥塞避免、快重传、快恢复**，如下图(图片来源于网络)。

  ![在这里插入图片描述](https://segmentfault.com/img/remote/1460000038526742)

这里的发送方会维护一个拥塞窗口的状态变量，它和流量控制的滑动窗口是不一样的，滑动窗口是根据接收方数据缓冲区大小确定的，而拥塞窗口是根据网络的拥塞情况动态确定的，一般来说发送方真实的发送窗口为滑动窗口和拥塞窗口中的最小值。

1. **慢开始**：为了避免一开始发送大量的数据而产生网络阻塞，会先初始化cwnd为1，当收到ACK后到下一个传输轮次，cwnd为2，以此类推成指数形式增长。

2. **拥塞避免**：因为cwnd的数量在慢开始是指数增长的，为了防止cwnd数量过大而导致网络阻塞，会设置一个慢开始的门限值ssthresh，当cwnd>=ssthresh时，进入到拥塞避免阶段，cwnd每个传输轮次加1。但网络出现超时，会将门限值ssthresh变为出现超时cwnd数值的一半，cwnd重新设置为1，如上图，在第12轮出现超时后，cwnd变为1，ssthresh变为12。

3. 快重传：在**网络中如果出现超时或者阻塞，则按慢开始和拥塞避免算法进行调整**。但**如果只是丢失某一个报文段**，如下图(图片来源于网络)，则使用快重传算法。

   ![在这里插入图片描述](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/1460000038526741)

从上图可知，**接收方正确地接收到M1和M2，而M3丢失，由于没有接收到M3，在接收方收到M5、M6和M7时，并不会进行确认，也就是不会发送ACK。**这时根据前面说的保证TCP可靠性传输中的序列号的作用，接收方这时不会接收M5，M6，M7，接收方可以什么都不会，因为发送方长时间未收到M3的确认报文，会对M3进行重传。除了这样，接收方也可以重复发送M2的确认报文，这样发送端长时间未收到M3的确认报文也会继续发送M3报文。

**但是根据快重传算法，要求在这种情况下，需要快速向发送端发送M2的确认报文，在发送方收到三个M2的确认报文后，无需等待重传计时器所设置的时间，可直接进行M3的重传，这就是快重传。**(面试时说这一句就够了，前面是帮助理解)

1. 快恢复：从上上图圈4可以看到，当发送收到三个重复的ACK，会进行快重传和快恢复。**快恢复是指将ssthresh设置为发生快重传时的cwnd数量的一半，而cwnd不是设置为1而是设置为为门限值ssthresh，并开始拥塞避免阶段**。

### TCP的三次握手及四次挥手

> 必考题

在介绍三次握手和四次挥手之前，先介绍一下TCP头部的一些常用字段。

- 序号：seq，占32位，用来标识从发送端到接收端发送的字节流。
- 确认号：ack，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。
- 标志位：
  - SYN：发起一个新连接。
  - FIN：释放一个连接。
  - ACK：确认序号有效。

#### 三次握手

> 三次握手的本质就是确定发送端和接收端具备收发信息的能力，在能流畅描述三次握手的流程及其中的字段含义作用的同时还需要记住每次握手时**接收端和发送端的状态**。这个比较容易忽略。

先看一张很经典的图（图片来源于网络），**发送端有CLOSED、SYN-SENT、ESTABLISHED**三种状态，**接收端有CLOSED、LISTEN、SYN-RCVD、ESTABLISHED四种状态**。![在这里插入图片描述](https://segmentfault.com/img/remote/1460000038526739)

假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是CLOSE。

- 第一次握手：客户端向服务端发起建立连接请求，**客户端会随机生成一个起始序列号x**，客户端向服务端发送的字段中包含标志位SYN=1，序列号seq=100。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN
- 第二次握手：服务端在收到客户端发来的报文后，会**随机生成一个服务端的起始序列号y**，然后给客户端回复一段报文，其中包括标志位SYN=1，ACK=1，序列号seq=y，确认号ack=x+1。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT。（其中SYN=1表示要和客户端建立一个连接，ACK=1表示确认序号有效）
- 第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK=1，序列号seq=x+1，确认号ack=y+1。第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED。

> 需要注意的一点是，第一次握手，**客户端向服务端发起建立连接报文，会占一个序列号**。但是第三次握手，同样是客户端向服务端发送报文，这次却不占序列号，所以建立连接后，**客户端向服务端发送的第一个数据的序列号为x+1**。

#### 四次挥手

和三次握手一样，先看一张非常经典的图（图片来源于网络），客户端在四次挥手过程中有ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、TIME-WAIT、CLOSED等五个状态，服务端有ESTABLISHED、CLOSE-WAIT、LAST-ACK、CLOSED等四种状态。最好记住每次挥手时服务端和客户端的状态。
假设客户端首先发起的断开连接请求
![在这里插入图片描述](https://segmentfault.com/img/remote/1460000038526740)

- 第一次挥手：客户端向服务端发送的数据完成后，**向服务端发起释放连接报文**，报文包含标志位FIN=1，序列号seq=u。此时客户端只能接收数据，不能向服务端发送数据。
- 第二次挥手：服务端收到客户端的释放连接报文后，向客户端发送确认报文，包含标志位ACK=1，序列号seq=v，确认号ack=u+1。**此时客户端到服务端的连接已经释放掉，客户端不能向服务端发送数据，服务端也不能向客户端发送数据。**但服务端到客户端的**单向连接还能正常传输数据**。
- 第三次挥手：**服务端发送完数据后向客户端发出连接释放报文**，报文包含标志位FIN=1，标志位ACK=1，序列号seq=w，确认号ack=u+1。
- 第四次挥手：客户端收到服务端发送的释放连接请求，向服务端发送确认报文，包含标志位ACK=1，序列号seq=u+1，确认号ack=w+1。

#### 为什么TCP连接的时候是3次？两次是否可以？

不可以，主要从以下两方面考虑（假设客户端是首先发起连接请求）：

1. 假设建立TCP连接仅需要两次握手，**那么如果第二次握手时，服务端返回给客户端的确认报文丢失了，客户端这边认为服务端没有和他建立连接，而服务端却以为已经和客户端建立了连接，**并且可能向服务端已经开始向客户端发送数据，但客户端并不会接收这些数据，浪费了资源。如果是三次握手，不会出现双方连接还未完全建立成功就开始发送数据的情况。
2. **如果服务端接收到了一个早已失效的来自客户端的连接请求报文**，会向客户端发送确认报文同意建立TCP连接。但因为客户端并不需要向服务端发送数据，所以此次TCP连接没有意义并且浪费了资源。

#### 为什么TCP连接的时候是3次，关闭的时候却是4次？

**因为需要确保通信双方都能通知对方释放连接，假设客服端发送完数据向服务端发送释放连接请求**，当客服端并不知道，服务端是否已经发送完数据，所以此次断开的是客服端到服务端的单向连接，服务端返回给客户端确认报文后，服务端还能继续单向给客户端发送数据。当服务端发送完数据后还需要向客户端发送释放连接请求，客户端返回确认报文，TCP连接彻底关闭。所以断开TCP连接需要客户端和服务端分别通知对方并分别收到确认报文，一共需要四次。

#### TIME_WAIT和CLOSE_WAIT的区别在哪?

默认客户端首先发起断开连接请求

- 从上图可以看出，CLOSE_WAIT是被动关闭形成的，当客户端发送FIN报文，服务端返回ACK报文后进入CLOSE_WAIT。
- TIME_WAIT是主动关闭形成的，当第四次挥手完成后，客户端进入TIME_WAIT状态。

#### 为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？

MSL的意思是报文的最长寿命，可以从两方面考虑：

1. 客户端发送第四次挥手中的报文后，再经过2MSL，可使本次TCP连接中的所有报文全部消失，不会出现在下一个TCP连接中。
2. 考虑丢包问题，如果第四挥手发送的报文在传输过程中丢失了，那么服务端没收到确认ack报文就会重发第三次挥手的报文。如果客户端发送完第四次挥手的确认报文后直接关闭，而这次报文又恰好丢失，则会造成服务端无法正常关闭。

#### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

如果TCP连接已经建立，在通信过程中，客户端突然故障，那么服务端不会一直等下去，过一段时间就关闭连接了。具体原理是TCP有一个保活机制，主要用在服务器端，用于检测已建立TCP链接的客户端的状态，防止因客户端崩溃或者客户端网络不可达，而服务器端一直保持该TCP链接，占用服务器端的大量资源(因为Linux系统中可以创建的总TCP链接数是有限制的)。

保活机制原理：设置TCP保活机制的保活时间keepIdle，即在TCP链接超过该时间没有任何数据交互时，发送保活探测报文；设置保活探测报文的发送时间间隔keepInterval；设置保活探测报文的总发送次数keepCount。如果在keepCount次的保活探测报文均没有收到客户端的回应，则服务器端即关闭与客户端的TCP链接。

