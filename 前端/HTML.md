# HTML和CSS

## 基础概念

### Web、网页、浏览器

#### Web

Web（World Wide Web）即全球广域网，也称为万维网。

我们常说的`Web端`就是网页端。

#### 网页

**网页是构成网站的基本元素**。网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。

我们在浏览器上输入网址后，打开的任何一个页面，都是属于网页。

#### 浏览器

浏览器是网页运行的平台，常见的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera等。

关于浏览器的详细介绍，可以看下一篇文章：《浏览器的介绍》。

### Web标准

#### W3C组织

**W3C**：World Wide Web Consortium，万维网联盟组织，用来制定web标准的机构（组织）。

W3C 万维网联盟是国际最著名的标准化组织。1994年成立后，至今已发布近百项相关万维网的标准，对万维网发展做出了杰出的贡献。

W3C 组织就类似于现实世界中的联合国。

为什么要遵循WEB标准呢？因为很多浏览器的浏览器内核不同，导致页面解析出来的效果可能会有差异，给开发者增加无谓的工作量。因此需要指定统一的标准。

#### Web 标准

**Web标准**：制作网页要遵循的规范。

Web标准不是某一个标准，而是由W3C组织和其他标准化组织制定的一系列标准的集合。

**1、Web标准包括三个方面**：

- 结构标准（HTML）：用于对网页元素进行整理和分类。
- 表现标准（CSS）：用于设置网页元素的版式、颜色、大小等外观样式。
- 行为标准（JS）：用于定义网页的交互和行为。

根据上面的Web标准，可以将 Web前端分为三层，如下。

**2、Web前端分三层**：

- HTML（HyperText Markup Language）：超文本标记语言。从**语义**的角度描述页面的**结构**。相当于人的身体组织结构。
- CSS（Cascading Style Sheets）：层叠样式表。从**审美**的角度美化页面的**样式**。相当于人的衣服和打扮。
- JS：JavaScript。从**交互**的角度描述页面的**行为**。相当于人的动作，让人有生命力。

## HTML

### HTML的概念

**HTML** 全称为 HyperText Markup Language，译为**超文本标记语言**。

HTML 不是一种编程语言，是一种描述性的**标记语言**。

**作用**：HTML是负责描述文档**语义**的语言。

#### 超文本

所谓的超文本，有两层含义：

（1）图片、音频、视频、动画、多媒体等内容，成为超文本，因为它们超出了文本的限制。

（2）不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件进行连接。即：超级链接文本。

#### 标记语言

HTML 不是一种编程语言，是一种描述性的**标记语言**。这主要有两层含义：

（1）**标记语言是一套标记标签**。比如：标签`<a>`表示超链接、标签`<img>`表示图片、标签`<h1>`表示一级标题等等，它们都是属于 HTML 标签。

说的通俗一点就是：网页是由网页元素组成的，这些元素是由 HTML 标签描述出来，然后通过浏览器解析，就可以显示给用户看了。

（2）编程语言是有编译过程的，而标记语言没有编译过程，HTML标签是直接由浏览器解析执行。

#### HTML是负责描述文档语义的语言

HTML 格式的文件是一个纯本文文件（就是用txt文件改名而成），用一些标签来描述语义，这些标签在浏览器页面上是无法直观看到的，所以称之为“超文本标记语言”。

接下来，我们需要学习 HTML 中的很多“标签对儿”，这些“标签对儿”能够给文本不同的语义。

比如，面试的时候问你，`<h1>` 标签有什么作用？

- 正确答案：给文本增加主标题的语义。
- 错误答案：给文字加粗、加黑、变大。

关乎“语义”的更深刻理解，等接下来我们学习了各种标签，就明白了。

### HTML的专有名词

- 网页 ：由各种标记组成的一个页面就叫网页。
- 主页(首页) : 一个网站的起始页面或者导航页面。
- 标记： 比如`<p>`称为开始标记 ，`</p>`称为结束标记，也叫标签。每个标签都规定好了特殊的含义。
- 元素：比如`<p>内容</p>`称为元素.
- 属性：给每一个标签所做的辅助信息。
- XHTML：符合XML语法标准的HTML。
- DHTML：dynamic，动态的。`javascript + css + html`合起来的页面就是一个 DHTML。
- HTTP：超文本传输协议。用来规定客户端浏览器和服务端交互时数据的一个格式。SMTP：邮件传输协议，FTP：文件传输协议。

### HTML的基本语法特性

#### （1）HTML对换行不敏感，对tab不敏感

HTML只在乎标签的嵌套结构，嵌套的关系。谁嵌套了谁，谁被谁嵌套了，和换行、tab无关。换不换行、tab不tab，都不影响页面的结构。

也就是说，HTML不是依靠缩进来表示嵌套的，而是看标签的嵌套关系。但是，我们发现有良好的缩进，代码更易读。建议大家都正确缩进标签。

#### （2）空白折叠现象

HTML中所有的**文字之间**，如果有空格、换行、tab都将被折叠为一个空格显示。

举例如下：

![img](http://img.smyhvae.com/20170629_2230.jpg)

#### （3）标签要严格封闭

标签不封闭的结果是灾难性的。

标签不封闭的举例如下：

![img](http://img.smyhvae.com/20170629_2245.jpg)

### 标签

[HTML标签主要参考](https://www.w3school.com.cn/tags/html_ref_byfunc.asp)

​	标签列表:

​		基础：

```
<!DOCTYPE>		定义文档类型，告知web浏览器页面，使用了HTML的哪个版本
<html>			定义一个 HTML 文档，标签告知浏览器这是一个 HTML 文档。							
<head>			标签表示文档的头部，其中包含了与该文档有关的信息，在元素内部：<title> 必需、<style>、<link>、<meta>、<script>、<base><noscript>	
<title>			为文档定义一个标题，在所有 HTML 文档中是必需的													主要作用：												
				定义浏览器工具栏中的标题								
				提供页面被添加到收藏夹时的标题							
				显示在搜索引擎结果中的页面标题	
<body>			定义文档的主体
<h1> to <h6>	定义 HTML 标题
<p>				定义一个段落
<br />			定义简单的换行，是一个空标签
<hr />			定义水平线
<!--...-->		定义一个注释
```

​		元信息：

```
<meta>	签提供了 HTML 文档的元数据。元数据不会显示在客户端，当时会被浏览器解析。META元素通常用于指定网页的描述，关键词，的文件的最后修改，作者，和其他元数据。元数据可以被使用浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 Web 服务调用。

<base>	规定页面上所有链接的默认 URL 和默认目标，在一个文档中，最多能使用一个<base> 元素。<base> 标签必须位于 <head> 元素内部，且应放在第一位。如果使用了 <base> 标签，则必须具备 href 属性或者target 属性或者两个属性都具备。有以下属性：	
		href：	URL 	规定页面所有相对链接的基准URL				
		target：		
			_blank 		浏览器会另开一个新窗口显示链接					
			_parent 	将链接的文件载入含有该链接框架的父框架集或父窗口中				
			_self 		在同一框架或窗口中打开所链接的文档。此参数为默认值，通常不用指定		
			_top 		在当前的整个浏览器窗口中打开所链接的文档，因而会删除所有框架framename 规定页面中所有的超链接和表单在何处打开。该属性会被每个链接中的 target 属性覆盖。
```

​		格式：

```
缩写：
<acronym>		定义只取首字母的缩写。
<abbr>			定义缩写。
信息：
<address>		定义文档作者或拥有者的联系信息。
<progress>		定义任何类型的任务的进度。
文本格式
<b>				定义粗体文本。
<bdi>			定义文本的文本方向，使其脱离其周围文本的方向设置。
<bdo>			定义文字方向。
<big>			定义大号文本。
<small>			定义小号文本。
<em>			定义强调文本。
<strong>		定义语气更为强烈的强调文本。
<code>			定义计算机代码文本。
<samp>			定义计算机代码样本
<del>			定义被删除文本。
<i>				定义斜体文本。
<ins>			定义被插入文本。
<kbd>			定义键盘文本。
<mark>			定义有记号的文本。
<sup>			定义上标文本。
<sub>			定义下标文本。
<pre>			定义预格式文本。
<var>			定义文本的变量部分。
引用：
<blockquote>	定义长的引用。
<q>				定义短的引用
<cite>			定义引用(citation)。
<meter>			定义预定义范围内的度量。

<rp>			定义若浏览器不支持 ruby 元素显示的内容。
<rt>			定义 ruby 注释的解释。
<ruby>			定义 ruby 注释。

<time>			定义日期/时间。
<tt>			定义打字机文本。
<dfn>			定义定义项目。
<wbr>			定义可能的换行符。
```

​		样式：

```
<style>	标签定义 HTML 文档的样式信息													属性：												
		type:text css	规定样式的类型								
        media:media_quary 为样式表规定不同的媒体类型。					
        scoped 如果使用该属性，则样式仅仅应用到 style 元素的父元素及其子元素。												
<div>	标签定义 HTML 文档中的一个分隔区块或者一个区域部分，常用于组合块级元素，以便通过 CSS 来对这些元素进行格式化。																		
<span>	用于对文档中的行内元素进行组合，标签提供了一种将文本的一部分或者文档的一部分独立出来的方式。																											
<header>	标签定义文档或者文档的一部分区域的页眉，元素应该作为介绍内容或者导航链接栏的容器，在一个文档中，您可以定义多个 <header> 元素。<header> 标签不能被放在 <footer>、<address> 或者另一个 <header> 元素内部、																			
<footer>	标签定义文档或者文档的一部分区域的页脚。元素应该包含它所包含的元素的信息。在典型情况下，该元素会包含文档创作者的姓名、文档的版权信息、使用条款的链接、联系信息等等。在一个文档中，您可以定义多个 <footer> 元素。插入联系信息，应该在 <footer> 元素内使用 <address> 标签									
<section>	标签定义了文档的某个区域。比如章节、头部、底部或者文档的其他区域。																
<article>	标签定义独立的内容。定义其所处内容之外的内容。定义的内容本身必须是有意义的且必须是独立于文档的其余部分，例如：论坛帖子、博客文章、新闻故事、评论																							
<aside>		标签用来表示跟当前页面的内容，内容应该与附近的内容相关，通常用于显示侧边栏或者补充的内容，例如：目录、索引等。																					
<details>	定义了用户可见的或者隐藏的需求的补充细节。只有 Chrome 和 Safari 6 支持 <details> 标签。 标签规定了用户可见的或者隐藏的需求的补充细节。用来供用户开启关闭的交互式控件。任何形式的内容都能被放在 <details> 标签里边。元素的内容对用户是不可见的，除非设置了 open 属性，即open=open																
<summary>	为 <details> 元素定义一个可见的标题。当用户点击标题时会显示出详细信息。		
<dialog>	定义一个对话框或者窗口
```

​		表格：

```
<table>		定义一个表格，一个 HTML 表格包括 <table> 元素，一个或多个 <tr>、<th> 以及 <td> 元素。<tr> 元素定义表格行，<th> 元素定义表头，<td> 元素定义表格单元。更复杂的 HTML 表格也可能包括 <caption>、<col>、<colgroup>、<thead>、<tfoot> 以及 <tbody> 元素。									
<caption>	定义表格标题。标签必须直接放置到 <table> 标签之后。																		
<tr>	定义表格中的行。一个 <tr> 元素包含一个或多个 <th> 或 <td> 元素。	
<th>	定义表格中的表头单元格 - 包含头部信息。如果需要将内容横跨多个行或列，请使用 colspan 和 rowspan 属性！													
<td>	定义表格中的标准单元格 - 包含数据。								
<thead>	标签用于组合 HTML 表格的表头内容，应该与 <tbody> 和 <tfoot> 元素结合起来使用，用来规定表格的各个部分（表头、主体、页脚）。通过使用这些元素，使浏览器有能力支持独立于表格表头和表格页脚的表格主体滚动。当包含多个页面的长的表格被打印时，表格的表头和页脚可被打印在包含表格数据的每张页面上。				
<tbody>	标签用于组合 HTML 表格的主体内容。具体同上
<tfoot>	标签用于组合 HTML 表格的页脚内容。具体同上							
<colgroup>	定义表格中供格式化的列组。标签用于对表格中的列进行组合，以便对其进行格式化。通过使用 <colgroup> 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。只能在 <table> 元素之内，在任何一个 <caption> 元素之后，在任何一个 <thead>、<tbody>、<tfoot>、<tr> 元素之前使用 <colgroup> 标签。														
<col>	定义表格中一个或多个列的属性值。通过使用 <col> 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。
示例：
<table border="1">
  <colgroup>
    <col span="2" style="background-color:red">
    <col style="background-color:yellow">
  </colgroup>
  <thead>
  	<tr>
  	  <th>ISBN</th>
  	  <th>Title</th>
 	   <th>Price</th>
 	 </tr>
  </thead>
  <tbody>
 	 <tr>
 	   <td>3476896</td>
	    <td>My first HTML</td>
 	   <td>$53</td>
 	 </tr>
  </tbody>
  <tfoot>
 	 <tr>
 	   <td>5869207</td>
 	   <td>My first CSS</td>
  	  <td>$49</td>
 	 </tr>
  </tfoot>
</table>
```

​		列表：

```
<ul>	定义一个无序列表
<ol>	定义一个有序列表， 列表排序以数字来显示。
<li>	定义一个列表项													
<dl>	标签定义一个描述列表。与 <dt> （定义项目/名字）和 <dd> （描述每一个项目/名字）一起使用。
<dt>	定义一个定义定义列表中的项目。
<dd>	标签被用来对一个描述列表中的项目/名字进行描述。									
<ul>
	<li></li>
	<li></li>
</ul>
<ol>
	<li></li>
	<li></li>
</ol>
<dl>
	<dt></dt>
		<dd></dd>
	<dt></dt>
		<dd></dd>
</dl>
```

​		表单：

```
<form>		定义供用户输入的 HTML 表单。
<input>		定义输入控件。
<label>		定义 input 元素的标注。
<textarea>	定义多行的文本输入控件。

<button>	定义按钮。
<optgroup>	定义选择列表中相关选项的组合。
<option>	定义选择列表中的选项。
<datalist>	定义下拉列表。
<select>	定义选择列表（下拉列表）

<fieldset>	定义围绕表单中元素的边框。
<legend>	定义 fieldset 元素的标题。

<keygen>	定义生成密钥。
<output>	定义输出的一些类型。
```

​		链接：

```
<a>		标签定义超链接,元素最重要的属性是 href 属性，它指定链接的目标。			
		download	filename		指定下载链接									
    	href		URL				规定链接的目标 URL。								
    	hreflang	language_code	规定目标 URL 的基准语言。仅在 href 属性存在时使
    	media	media_query	规定目标 URL 的媒介类型。默认值：all。仅在 href 属性存在时使用target _blank _parent _self _top framename 规定页面中所有的超链接和表单在何处打开type 规定目标URL的MIME类型												
<a href="URL"></a>
        
<link>	定义文档与外部资源的关系。最常见的用途是链接样式表。此元素只能存在于 head 部分，不过它可出现任何次数。														
		href		URL				定义被链接文档的位置	
        hreflang	language_code	定义被链接文档中文本的语言。				
        media		media_query		规定被链接文档将显示在什么设备上。			
        rel			alternate archives author bookmark external first help icon last license next nofollow noreferrer pingback prefetch prev search sidebar stylesheet tagup 必需。定义当前文档与被链接文档之间的关系。						
        type 		MIME_TYPE 		 规定被链接文档的 MIME 类型。
<head>
	<link rel="stylesheet" type="text/css" href="css文件路径">
</head>	

<nav>	标签定义导航链接的部分,并不是所有的 HTML 文档都要使用到 <nav> 元素。<nav> 元素只是作为标注一个导航链接的区域。
```

​		图像：

```
<img>	标签定义 HTML 页面中的图像,标签有两个必需的属性：src 和 alt。
		属性：															
		src URL 规定显示图片的URL									
        alt		规定图像的替代文本。										
        height  规定图像的高度.可用css设置										
        width	规定图像的宽度											
        lsmap 	将图像规定为服务器端图像映射。								
        usemap	将图像定义为客户器端图像映射。
<img src="URL" alt="内容" width="42" height="42">
	
<map>	定义图像映射。<img>中的 usemap 属性可引用 <map> 中的 id 或 name 属性（取决于浏览器），所以我们应同时向 <map> 添加 id 和 name 属性。area 元素永远嵌套在 map 元素内部。area 元素可定义图像映射中的区域。				
<area>	 标签定义图像映射内部的区域（图像映射指的是带有可点击区域的图像）。	元素始终嵌套在 <map> 标签内部。									

<img src="w3cnote://file/getImage?fileId=planetsgif"width="145" height="126"alt="Planets"usemap="#planetmap">

<mapname="planetmap">
	<area shape="rect" coords="0,0,82,126" href="https://www.w3cschool.cn/html5/sun.htm" alt="Sun">
	<area shape="circle" coords="90,58,3" href="https://www.w3cschool.cn/html5/mercur.htm" alt="Mercury">
	<area shape="circle" coords="124,58,8" href="https://www.w3cschool.cn/html5/venus.htm" alt="Venus">
</map>

<canvas>	通过脚本（通常是 JavaScript）来绘制图形（比如图表和其他图像）。
<figcaption>	标签为 <figure> 元素定义标题。元素应该被置于 <figure> 元素的第一个或最后一个子元素的位置。
<figure>	figure 标签用于对元素进行组合。标签规定独立的流内容（图像、图表、照片、代码等等）。元素的内容应该与主内容相关，同时元素的位置相对于主内容是独立的。如果被删除，则不应对文档流产生影响。
```

​		音视频：

```
<audio>		定义声音，比如音乐或其他音频流。
<video>		定义一个音频或者视频
<source>	标签为媒体元素（比如 <video> 和 <audio>）定义媒体资源。					
			属性：															
			media media_query 规定媒体资源的类型，供浏览器决定是否下载			
			src	URL	规定媒体文件的 URL										
			type MIME_type	规定媒体资源的 MIME 类型
<audio controls> 
	<source src="horse.ogg" type="audio/ogg"> 
	<source src="horse.mp3" type="audio/mpeg"> 您的浏览器不支持 audio 元素。
</audio>

<track>	为媒体(<video> 和 <audio>)元素定义外部文本轨道。

```

​		程序：

```
<script>	定义客户端脚本。
<noscript>	元素用来定义在脚本未被执行时的替代内容（文本）。此标签可被用于可识别 <noscript> 标签但无法支持其中的脚本的浏览器。														
<embed>	定义了一个容器，用来嵌入外部应用或者互动程序（插件）					
		src 规定被嵌入内容的 URL										
        type 	规定嵌入内容的 MIME 类型。								
        height 规定嵌入内容的高度										
        width 规定嵌入内容的宽度
<embed src="URL">
	
<object>	标签定义一个嵌入的对象。请使用此元素向您的 XHTML 页面添加多媒体。此元素运行您规定插入 HTML 文档中的对象的数据和参数，以及可用来显示和操作数据的代码。
<param>	标签为<object>标签提供嵌入内容的运行时参数的name与value对。
<object data="horse.wav">
  <param name="autoplay" value="true">
</object>
```

### HTML 5

## CSS

### 选择器

CSS 选择器：就是指定 CSS 要作用的标签，那个标签的名称就是选择器。意为：选择哪个容器。

CSS 的选择器分为两大类：基本选择题和扩展选择器。

#### 四种基本选择器

**基本选择器：**

- 标签选择器：针对**一类**标签
- ID 选择器：针对某**一个**特定的标签使用
- 类选择器：针对**你想要的所有**标签使用
- 通用选择器（通配符）：针对所有的标签都适用（不建议使用）

##### 1、标签选择器：选择器的名字代表 html 页面上的标签

标签选择器，选择的是页面上所有这种类型的标签，所以经常描述“**共性**”，无法描述某一个元素的“个性”。

举例：

```html
p{ font-size:14px; }
```

上方选择器的意思是说：所有的`<p>`标签里的内容都将显示 14 号字体。

【总结】需要注意的是：

（1）所有的标签，都可以是选择器。比如 ul、li、label、dt、dl、input。

（2）无论这个标签藏的多深，一定能够被选择上。

（3）选择的所有，而不是一个。

##### 2、ID 选择器：规定用`#`来定义

针对某一个特定的标签来使用，只能使用一次。css 中的 ID 选择器以”#”来定义。

举例：

```html
#mytitle{ border:3px dashed green; }
```

i**d 选择器的选择符是“#”**。

任何的 HTML 标签都可以有 id 属性。表示这个标签的名字。这个标签的名字，可以任取，但是：

（1）只能有字母、数字、下划线。

（2）必须以字母开头。

（3）不能和标签同名。比如 id 不能叫做 body、img、a。

另外，特别强调的是：**HTML 页面，不能出现相同的 id，哪怕他们不是一个类型**。比如页面上有一个 id 为 pp 的 p，一个 id 为 pp 的 div，是非法的！

**一个标签可以被多个 css 选择器选择：**

比如，我们可以同时让标签选择器和 id 选择器作用于同一个标签。

##### 3、类选择器：规定用圆点`.`来定义

、针对**你想要的所有**标签使用。优点：灵活。

css 中用`.`来表示类。举例如下：

```
.one{ width:800px; }
```

和 id 非常相似，任何的标签都可以携带 id 属性和 class 属性。class 属性的特点：

- 特性 1：**类选择器可以被多种标签使用**。
- 特性 2：同一个标签可以使用多个类选择器。用**空格**隔开。举例如下：（正确）

```html
<h3 class="teshu  zhongyao">我是一个h3啊</h3>
```

初学者常见的错误，就是写成了两个 class。举例如下：（错误）

```html
<h3 class="teshu" class="zhongyao">我是一个h3啊</h3>
```

（1）不要去试图用一个类名，把某个标签的所有样式写完。这个标签要多携带几个类，共同完成这个标签的样式。

（2）每一个类要尽可能小，有“公共”的概念，能够让更多的标签使用。

问题：到底用 id 还是用 class？

答案：尽可能的用 class，除非极特殊的情况可以用 id。

原因**：id 是 js 用的。也就是说，js 要通过 id 属性得到标签，所以 css 层面尽量不用 id，要不然 js 就很别扭**。另一层面，我们会认为一个有 id 的元素，有动态效果。

**类上样式，id 上行为**。意思是说，`class`属性交给 css 使用，`id`属性交给 js 使用。

**上面这三种选择器的区别：**

- 标签选择器针对的是页面上的一类标签。
- ID 选择器是只针对特定的标签(一个)，ID 是此标签在此页面上的唯一标识。
- 类选择器可以被多种标签使用。

##### 通配符`*`：匹配任何标签

通用选择器，将匹配任何标签。不建议使用，IE 有些版本不支持，大网站增加客户端负担。

效率不高，如果页面上的标签越多，效率越低，所以页面上不能出现这个选择器。

举例：

```
* {
    margin-left: 0px;
    margin-top: 0px;
}
```

#### 高级选择器

**高级选择器：**

- 后代选择器：用空格隔开
- 交集选择器：选择器之间紧密相连
- 并集选择器（分组选择器）：用逗号隔开
- 伪类选择器

##### 1、后代选择器: 定义的时候用空格隔开

对于`E F`这种格式，表示**所有属于 E 元素后代的 F 元素**，有这个样式。空格就表示后代。

后代选择器，就是一种平衡：共性、特性的平衡。当要把**某一个部分的所有的什么**，进行样式改变，就要想到后代选择器。

**后代选择器，描述的是祖先结构**。

看定义可能有点难理解，我们来看例子吧。

举例 1：

```html
<style type="text/css">
    .div1 p {
        color: red;
    }
</style>
```

空格就表示后代。`.div1 p` 表示`.div1`的后代所有的`p`。是`p`的样式进行修改。

这里强调一下：这两个标签不一定是连续紧挨着的，只要保持一个后代的关联即可。也就是说，选择的是后代，不一定是儿子。

##### 2、交集选择器：定义的时候紧密相连

定义交集选择器的时候，**两个选择器之间紧密相连**。一般是以标签名开头，比如`div.haha`，再比如`p.special`。

如果后一个选择器是类选择器，则写为`div.special`；如果后一个选择器 id 选择器，则写为`div#special`。

来看下面这张图就明白了：

![img](http://img.smyhvae.com/20170711_1851.png)

```css
h3.special {
    color: red;
}
```

选择的元素要求同时满足两个条件：必须是 h3 标签，然后必须是 special 标签。

举例：

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>交集选择器测试</title>
        <style type="text/css">
            h3.special {
                color: red;
            }
        </style>
    </head>
    <body>
        <h3 class="special zhongyao">标题1</h3>
        <h3 class="special">我也是标题</h3>
        <p>我是段落</p>
    </body>
</html>
```

注意，交集选择器没有空格。所以，没有空格的`div.red`（交集选择器）和有空格的`div .red`（后代选择器）不是一个意思。

交集选择器可以连续交：（一般不要这么写）

```css
h3.special.zhongyao {
    color: red;
}
```

上面这种写法，是 IE7 开始兼容的，IE6 不兼容。

##### 3、并集选择器：定义的时候用逗号隔开

**三种基本选择器都可以放进来**。

举例：

```css
p,
h1,
#mytitle,
.one {
    color: red;
}
```

效果：

![img](http://img.smyhvae.com/2015-10-03-css-10.png)

#### 其他选择器

##### 1.子代选择器，用符号`>`表示

> IE7 开始兼容，IE6 不兼容。

只能选择直系（不能是子孙）

```css
div > p {
    color: red;
}
```

div 的儿子 p。和 div 的后代 p 的截然不同。

能够选择：

```html
<div>
    <p>我是div的儿子</p>
</div>
```

不能选择：

```
<div>
    <ul>
        <li>
            <p>我是div的重孙子</p>
        </li>
    </ul>
</div>
```

##### 2.序选择器

> IE8 开始兼容；IE6、7 都不兼容

设置无序列表`<ul>`中的第一个`<li>`为红色：

```html
<style type="text/css">
    ul li:first-child {
        color: red;
    }
</style>
```

设置无序列表`<ul>`中的最后一个`<li>`为红色：

```css
ul li:last-child {
    color: blue;
}
```

序选择器还有更复杂的用法，以后再讲。

由于浏览器的更新需要过程，所以现在如果公司还要求兼容 IE6、7，那么就要自己写类名：

```html
<ul>
    <li class="first">项目</li>
    <li>项目</li>
    <li>项目</li>
    <li>项目</li>
    <li>项目</li>
    <li>项目</li>
    <li>项目</li>
    <li>项目</li>
    <li>项目</li>
    <li class="last">项目</li>
</ul>
```

用类选择器来选择第一个或者最后一个：

```html
ul li.first{ color:red; } ul li.last{ color:blue; }
```

##### 3.下一个兄弟选择器

> IE7 开始兼容，IE6 不兼容。

`+`表示选择下一个兄弟

```html
<style type="text/css">
    h3 + p {
        color: red;
    }
</style>
```

上方的选择器意思是：选择的是 h3 元素后面紧挨着的第一个兄弟。

```html
<h3>我是一个标题</h3>
<p>我是一个段落</p>
<p>我是一个段落</p>
<p>我是一个段落</p>
<h3>我是一个标题</h3>
<p>我是一个段落</p>
<p>我是一个段落</p>
<p>我是一个段落</p>
<h3>我是一个标题</h3>
<p>我是一个段落</p>
<p>我是一个段落</p>
<p>我是一个段落</p>
<h3>我是一个标题</h3>
```

效果如下：

![img](http://img.smyhvae.com/20170711_1950.png)

这种选择器作用不大。

#### 伪类（伪类选择器）

**伪类**：同一个标签，根据其**不同的种状态，有不同的样式**。这就叫做“伪类”。伪类用冒号来表示。

比如div是属于box类，这一点很明确，就是属于box类。但是a属于什么类？不明确。因为需要看用户点击前是什么状态，点击后是什么状态。所以，就叫做“伪类”。

##### 静态伪类和动态伪类

伪类选择器分为两种。

（1）**静态伪类**：只能用于**超链接**的样式。如下：

- `:link` 超链接点击之前
- `:visited` 链接被访问过之后

PS：以上两种样式，只能用于超链接。

（2）**动态伪类**：针对**所有标签**都适用的样式。如下：

- `:hover` “悬停”：鼠标放到标签上的时候
- `:active` “激活”： 鼠标点击标签，但是不松手时。
- `:focus` 是某个标签获得焦点时的样式（比如某个输入框获得焦点）




```
类选择器
.class				.intro				选择所有class="intro"的元素
id选择器
#id					#firstname			选择所有id="firstname"的元素
通用选择器
*					*					选择所有元素	
元素选择器：
element				p					选择所有<p>元素	
群组选择器
element,element		div,p				选择所有<div>元素和<p>元素
后代选择器
element element		div p				选择<div>元素内的所有<p>元素	 包含子孙元素
子元素选择器
element>element		div>p				选择所有父级是 <div> 元素的 <p> 元素  只能是子元素
相邻兄弟选择器
element+element		div+p				选择所有紧接着<div>元素之后的<p>元素	

属性选择器：																	
[attribute]			[target]			选择所有带有target属性元素	
[attribute=value]	[target=-blank]		选择所有使用target="-blank"的元素	
[attribute~=value]	[title~=flower]		选择标题属性包含单词"flower"的所有元素	
[attribute|=value]	[lang|=en]			选择 lang 属性以 en 为开头的所有元素	
[attribute^=value]	a[src^="https"]		选择每一个src属性的值以"https"开头的元素
[attribute$=value]	a[src$=".pdf"]		选择每一个src属性的值以".pdf"结尾的元素
[attribute*=value]	a[src*="runoob"]	选择每一个src属性的值包含子字符串"runoob"的元素																				
伪类：
:link				a:link				选择所有未访问链接	
:visited			a:visited			选择所有访问过的链接	
:active				a:active			选择活动链接	
:hover				a:hover				选择鼠标在链接上面时
:lang(language)		p:lang(it)			选择带有以 "it" 开头的 lang 属性值的每个 <p> 元素
:focus				input:focus			选择具有焦点的输入元素	


伪元素：
:first-letter		p:first-letter		选择每一个<p>元素的第一个字母	
:first-line			p:first-line		选择每一个<p>元素的第一行	
:first-child		p:first-child		指定只有当<p>元素是其父级的第一个子级的样式。	
:before				p:before			在每个<p>元素之前插入内容	
:after				p:after				在每个<p>元素之后插入内容	

element1~element2	p~ul				选择p元素之后的每一个ul元素	
:first-of-type		p:first-of-type		选择每个p元素是其父级的第一个p元素
:last-of-type		p:last-of-type		选择每个p元素是其父级的最后一个p元素
:only-of-type		p:only-of-type		选择每个p元素是其父级的唯一p元素
:only-child			p:only-child		选择每个p元素是其父级的唯一子元素
:nth-child(n)		p:nth-child(2)		选择每个p元素是其父级的第二个子元素
:nth-last-child(n)	p:nth-last-child(2)	选择每个p元素的是其父级的第二个子元素，从最后一个子项计数
:nth-of-type(n)		p:nth-of-type(2)	选择每个p元素是其父级的第二个p元素
:nth-last-of-type(n)p:nth-last-of-type(2)选择每个p元素的是其父级的第二个p元素，从最后一个子项计数
:last-child			p:last-child		选择每个p元素是其父级的最后一个子级。

:root				:root				选择文档的根元素
:empty				p:empty				选择每个没有任何子级的p元素（包括文本节点）
:target				#news:target		选择当前活动的#news元素（包含该锚名称的点击的URL）
:enabled			input:enabled		选择每一个已启用的输入元素
:disabled			input:disabled		选择每一个禁用的输入元素
:checked			input:checked		选择每个选中的输入元素
:not(selector)		:not(p)				选择每个并非p元素的元素
::selection			::selection			匹配元素中被用户选中或处于高亮状态的部分

:out-of-range		:out-of-range		匹配值在指定区间之外的input元素
:in-range			:in-range			匹配值在指定区间之内的input元素
:read-write			:read-write			用于匹配可读及可写的元素
:read-only			:read-only			用于匹配设置 "readonly"（只读） 属性的元素
:optional			:optional			用于匹配可选的输入元素
:required			:required			用于匹配设置了 "required" 属性的元素
:valid				:valid				用于匹配输入值为合法的元素
:invalid			:invalid			用于匹配输入值为非法的元素
```

​	选择器有着不用的优先级：（[主要参考](https://blog.csdn.net/b954960630/article/details/79560590?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)）

​		不同级别：

​		1.在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。

​		2.作为style属性写在元素内的样式

​		3.id选择器

​		4.类选择器

​		5.元素选择器

​		6.通配符选择器

​		7.浏览器自定义或继承

​	总结排序：!important > 行内样式 > ID选择器 > 类选择器 > 元素 > 通配符 > 继承 > 浏览器默认属性

​	1.在级别中，先写的会被后写的覆盖

​	2.同一级别css引入方式不同，优先级不同

​		总结排序：内联(行内)样式 > 内部样式表 > 外部样式表 > 导入样式(@import)。

### CSS样式表的继承性和层叠性

#### CSS的继承性

我们来看下面这样的代码，来引入继承性：

<img src="http://img.smyhvae.com/20170724_2359.png" alt="img" style="zoom:50%;" />

上方代码中，我们给div标签增加红色属性，却发现，div里的每一个子标签`<p>`也增加了红色属性。于是我们得到这样的结论：

> 有一些属性，当给自己设置的时候，自己的后代都继承上了，这个就是**继承性。**

继承性是从自己开始，直到最小的元素。

但是呢，如果再给上方的代码加一条属性：

<img src="http://img.smyhvae.com/20170725_2122.jpg" alt="img" style="zoom:50%;" />

上图中，我们给div加了一个border，但是发现只有div具备了border属性，而p标签却没有border属性。于是我们可以得出结论：

- **关于文字样式的属性，都具有继承性**。这些属性包括：color、 text-开头的、line-开头的、font-开头的。
- **关于盒子、定位、布局的属性，都不能继承**。

以后当我们谈到css有哪些特性的时候，我们要首先想到继承性。而且，要知道哪些属性具有继承性、哪些属性没有继承性。

#### CSS的层叠性

##### 层叠性：计算权重

**层叠性：就是css处理冲突的能力。** 所有的权重计算，没有任何兼容问题！

CSS像艺术家一样优雅，像工程师一样严谨。

我们来看一个例子，就知道什么叫层叠性了。

<img src="http://img.smyhvae.com/20170725_2132.png" alt="img" style="zoom:50%;" />

上图中，三种选择器同时给P标签增加颜色的属性，但是，文字最终显示的是蓝色，这个时候，就出现了层叠性的情况。

当多个选择器，选择上了某个元素的时候，要按照如下**顺序统计权重**：

- id 选择器
- 类选择器、属性选择器、伪类选择器
- 标签选择器、伪元素选择器

因为对于相同方式的样式表，其**选择器排序的优先级为：ID选择器 > 类选择器 > 标签选择器**

针对上面这句话，我们接下来举一些复杂一点的例子。

##### 层叠性举例

举例1：计算权重

![img](http://img.smyhvae.com/20170725_2138.png)

如上图所示，统计各个选择器的数量，优先级高的胜出。文字的颜色为红色。

PS：不进位，实际上能进位（奇淫知识点：255个标签，等于1个类名）但是没有实战意义！

举例2：权重相同时

![img](http://img.smyhvae.com/20170725_2250.png)

上图可以看到，第一个样式和第二个样式的权重相同。但第二个样式的书写顺序靠后，因此以第二个样式为准（就近原则）。

举例3：具有实战性的例子

![img](http://img.smyhvae.com/20170726_2221.png)

现在我要让一个列表实现上面的这种样式：第一个li为红色，剩下的li全部为蓝色。

如果写成下面这种代码是无法实现的：

![img](http://img.smyhvae.com/20170726_2225.png)

无法实现的原因很简单，计算一下三个选择器的权重就清楚了，显然第二个样式被第一个样式表覆盖了。

正确的做法是：（**非常重要**）

![img](http://img.smyhvae.com/20170726_2229.png)

上图中，第二个样式比第一个样式的权重要大。因此在实战中可以实现这种效果：**所有人当中，让某一个人为红，让其他所有人为蓝。**

这种方式好用是好用，但用好很难。

就拿上方代码来举例，为了达到这种效果，即为了防止权重不够，比较稳妥的做法是：**把第二个样式表照着第一个样式表来写，在此基础上，给第二个样式表再加一个权重。**

上面这个例子很具有实战性。

举例4：继承性造成的影响

这里需要声明一点：

> 如果不能直接选中某个元素，通过继承性影响的话，那么权重是0。

为了验证上面这句话，我们来看看下面这样的例子：

![img](http://img.smyhvae.com/20170727_0843.png)

另外：**如果大家的权重相同，那么就采用就近原则：谁描述的近，听谁的**。举例如下：(box3 描述得最近，所以采用 box3 的属性)

![img](http://img.smyhvae.com/20190122_1530.png)

上方代码的文字版如下：

```html
<!DOCTYPE html>
<html lang="">
  <head>
    <meta />
    <meta />
    <meta />
    <title>Document</title>
    <style>
      #box1 {
        color: red;
      }

      #box2 {
        color: green;
      }

      #box3 {
        color: blue;
      }
    </style>
  </head>
  <body>
    <div id="box1">
      <div id="box2">
        <div id="box3"><p>猜猜我是什么颜色</p></div>
      </div>
    </div>
  </body>
</html>
```

##### 层叠性：权重计算的问题大总结（非常重要）

层叠性。层叠性是一种能力，就是处理冲突的能力。当不同选择器，对一个标签的同一个样式，有不同的值，听谁的？这就是冲突。css有着严格的处理冲突的机制。

通过列举上面几个例子，我们对权重问题做一个总结。

![img](http://img.smyhvae.com/20170727_2050.png)

上面这个图非常重要，我们针对这个图做一个文字描述：

- 选择上了，数权重，(id的数量，类的数量，标签的数量)。如果权重一样，谁写在后面听谁的。
- 没有选择上，通过继承影响的，就近原则，谁描述的近听谁的。如果描述的一样近，比如选择器权重，如果权重再一样重，谁写在后面听谁的。

##### CSS样式表的冲突的总结

- 1、对于相同的选择器（比如同样都是类选择器），其样式表排序：行级样式 > 内嵌样式表 > 外部样式表（就近原则）
- 2、对于相同类型的样式表（比如同样都是内部样式表），其选择器排序：ID选择器 > 类选择器 > 标签选择器
- 3、外部样式表的ID选择器 > 内嵌样式表的标签选择器

> 总结：就近原则。ID选择器优先级最大。

举例：如果都是内嵌样式表，优先级的顺序如下：（ID 选择器 > 类选择器 > 标签选择器）

![img](http://img.smyhvae.com/2015-10-03-css-14.png)

另外还有两个冲突的情况：

- 1、对同一个标签，如果用到的都是内嵌样式表，且权重一致，那它的优先级：**定义**的CSS样式表中，谁最近，就用谁。
- 2、对于同一个标签，如果用到的都是外部样式表，且权重一致，那它的优先级：html文件中，引用样式表的位置越近，就用谁。

例如：

![img](http://img.smyhvae.com/2015-10-03-css-16.png)

### CSS盒模型

盒子模型，英文即box model。无论是div、span、还是a都是盒子。

但是，**图片、表单元素一律看作是文本，它们并不是盒子**。这个很好理解，比如说，一张图片里并不能放东西，它自己就是自己的内容。

#### 盒子中的区域

一个盒子中主要的属性就5个：width、height、padding、border、margin。如下：

- width和height：**内容**的宽度、高度（不是盒子的宽度、高度）。
- padding：内边距。
- border：边框。
- margin：外边距。

盒子模型的示意图：

![img](http://img.smyhvae.com/20170727_2128.png)

代码演示：

![img](http://img.smyhvae.com/20170727_2326.png)

上面这个盒子，width:200px; height:200px; 但是真实占有的宽高是302*302。 这是因为还要加上padding、border。

注意：**宽度和真实占有宽度，不是一个概念！**来看下面这例子。

#### 标准盒模型和IE盒模型

> 我们目前所学习的知识中，以标准盒子模型为准。

标准盒子模型：

![img](http://img.smyhvae.com/2015-10-03-css-27.jpg)

IE盒子模型：

![img](http://img.smyhvae.com/2015-10-03-css-30.jpg)

上图显示：

在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式：

- width和height：**内容**的宽度、高度（不是盒子的宽度、高度）。
- padding：内边距。
- border：边框。
- margin：外边距。

CSS盒模型和IE盒模型的区别：

- 在 **标准盒子模型**中，**width 和 height 指的是内容区域**的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。
- **IE盒子模型**中，**width 和 height 指的是内容区域+border+padding**的宽度和高度。

注：Android中也有margin和padding的概念，意思是差不多的，如果你会一点Android，应该比较好理解吧。区别在于，Android中没有border这个东西，而且在Android中，margin并不是控件的一部分，我觉得这样做更合理一些，呵呵。

#### `<body>`标签也有margin

`<body>`标签有必要强调一下。很多人以为`<body>`标签占据的是整个页面的全部区域，其实是错误的，正确的理解是这样的：整个网页最大的盒子是`<document>`，即浏览器。而`<body>`是`<document>`的儿子。浏览器给`<body>`默认的margin大小是8个像素，此时`<body>`占据了整个页面的一大部分区域，而不是全部区域。来看一段代码。

```html
<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="Generator" content="EditPlus®">
  <meta name="Author" content="">
  <meta name="Keywords" content="">
  <meta name="Description" content="">
  <title>Document</title>

	<style type="text/css">

		div{
			width: 100px;
			height: 100px;
			border: 1px solid red;
			padding: 20px;
			margin: 30px;
		}

	</style>

 </head>

 <body>

	<div>有生之年</div>
	<div>狭路相逢</div>

 </body>

</html>
```

上面的代码中，我们对div标签设置了边距等信息。打开google浏览器，按住F12，显示效果如下：

![img](http://img.smyhvae.com/20151003_27.png)

#### 认识width、height

一定要知道，在前端开发工程师眼中，世界中的一切都是不同的。

比如说，丈量稿纸，前端开发工程师只会丈量内容宽度：

![img](http://img.smyhvae.com/20170727_2329.png)

下面这两个盒子，真实占有宽高，都是302*302：

盒子1：

```css
.box1{
	width: 100px;
	height: 100px;
	padding: 100px;
	border: 1px solid red;
}
```

盒子2：

```css
.box2{
	width: 250px;
	height: 250px;
	padding: 25px;
	border: 1px solid red;
}
```

真实占有宽度 = 左border + 左padding + width + 右padding + 右border

上面这两个盒子的盒模型图如下：

![img](http://img.smyhvae.com/20170728_0925.png)

**如果想保持一个盒子的真实占有宽度不变，那么加width的时候就要减padding。加padding的时候就要减width**。因为盒子变胖了是灾难性的，这会把别的盒子挤下去。

#### 认识padding

##### padding区域也有颜色

padding就是内边距。padding的区域有背景颜色，css2.1前提下，并且背景颜色一定和内容区域的相同。也就是说，background-color将填充**所有border以内的区域。**

效果如下：

![img](http://img.smyhvae.com/20170728_1005.png)

##### padding有四个方向

padding是4个方向的，所以我们能够分别描述4个方向的padding。

方法有两种，第一种写小属性；第二种写综合属性，用空格隔开。

小属性的写法：

```css
	padding-top: 30px;
	padding-right: 20px;
	padding-bottom: 40px;
	padding-left: 100px;
```

综合属性的写法：(上、右、下、左)（顺时针方向，用空格隔开。margin的道理也是一样的）

```css
padding:30px 20px 40px 100px;
```

如果写了四个值，则顺序为：上、右、下、左。

如果只写了三个值，则顺序为：上、右、下。??和右一样。

如果只写了两个值，比如说：

```text
padding: 30px 40px;
```

则顺序等价于：30px 40px 30px 40px;

要懂得，**用小属性层叠大属性**。比如：

```text
padding: 20px;
padding-left: 30px;
2
```

上面的padding对应盒子模型为：

![img](http://img.smyhvae.com/20170728_1039.png)

下面的写法：

```text
padding-left: 30px;
padding: 20px;
```

第一行的小属性无效，因为被第二行的大属性层叠掉了。

### 浮动

#### 标准文档流

**（1）空白折叠现象：**

无论多少个空格、换行、tab，都会折叠为一个空格。

**（2）高矮不齐，底边对齐：**

举例如下：

<img src="http://img.smyhvae.com/20170729_1508_2.png" alt="img" style="zoom:50%;" />

**（3）自动换行，一行写不满，换行写。**

#### 行内元素和块级元素

学习的初期，我们就要知道，标准文档流等级森严。标签分为两种等级：

- 行内元素
- 块级元素

**行内元素和块级元素的区别：**（非常重要）

行内元素：

- **与其他行内元素并排**；
- **不能设置宽、高。默认的宽度，就是文字的宽度**。

块级元素：

- **霸占一行**，不能与其他任何元素并列；
- 能接受宽、高。如果不设置宽度，那么宽度将默认变为父亲的100%。

**行内元素和块级元素的分类：**

在以前的HTML知识中，我们已经将标签分过类，当时分为了：文本级、容器级。

从HTML的角度来讲，标签分为：

- 文本级标签：p、span、a、b、i、u、em。
- 容器级标签：div、h系列、li、dt、dd。

> PS：为甚么说p是文本级标签呢？因为p里面只能放文字&图片&表单元素，p里面不能放h和ul，p里面也不能放p。

现在，从CSS的角度讲，CSS的分类和上面的很像，就p不一样：

- 行内元素：**除了p之外，所有的文本级标签，都是行内元素**。p是个文本级，但是是个块级元素。
- 块级元素：**所有的容器级标签都是块级元素，还有p标签**。

##### 行内元素和块级元素的相互转换

我们可以通过`display`属性将块级元素和行内元素进行相互转换。display即“显示模式”。

##### 块级元素可以转换为行内元素：

一旦，给一个块级元素（比如div）设置：

```text
display: inline;
```

那么，这个标签将立即变为行内元素，此时它和一个span无异。inline就是“行内”。也就是说：

- 此时这个div不能设置宽度、高度；
- 此时这个div可以和别人并排了。

##### 行内元素转换为块级元素：

同样的道理，一旦给一个行内元素（比如span）设置：

```text
display: block;
```

那么，这个标签将立即变为块级元素，此时它和一个div无异。block”是“块”的意思。也就是说：

- 此时这个span能够设置宽度、高度
- 此时这个span必须霸占一行了，别人无法和他并排
- 如果**不设置宽度，将撑满父亲**

#### 脱离标准流

标准流里面的限制非常多，导致很多页面效果无法实现。如果我们现在就要并排、并且就要设置宽高，那该怎么办呢？办法是：移民！**脱离标准流**！

css中一共有三种手段，使一个元素脱离标准文档流：

- （1）浮动
- （2）绝对定位
- （3）固定定位

#### 浮动的性质

> 浮动是css里面布局用的最多的属性。

现在有两个div，分别设置宽高。我们知道，它们的效果如下：

<img src="http://img.smyhvae.com/20170729_1722.png" alt="img" style="zoom:50%;" />

此时，如果给这两个div增加一个浮动属性，比如`float: left;`，效果如下：

<img src="http://img.smyhvae.com/20170729_1723.png" alt="img" style="zoom:50%;" />

这就达到了浮动的效果。此时，两个元素并排了，并且两个元素都能够设置宽度、高度了（这在上一段的标准流中，不能实现）。

浮动想学好，一定要知道三个性质。接下来讲一讲。

##### 性质1：浮动的元素脱标

脱标即脱离标准流。我们来看几个例子。

证明1：

<img src="http://img.smyhvae.com/20170729_2028.png" alt="img" style="zoom: 67%;" />

上图中，在默认情况下，两个div标签是上下进行排列的。现在由于float属性让上图中的第一个`<div>`标签出现了浮动，于是这个标签在另外一个层面上进行排列。而第二个`<div>`还在自己的层面上遵从标准流进行排列。

证明2：

<img src="http://img.smyhvae.com/20180111_2320.png" alt="img" style="zoom:67%;" />

上图中，span标签在标准流中，是不能设置宽高的（因为是行内元素）。但是，一旦设置为浮动之后，即使不转成块级元素，也能够设置宽高了。

所以能够证明一件事：**一旦一个元素浮动了，那么，将能够并排了，并且能够设置宽高了。无论它原来是个div还是个span。**所有标签，浮动之后，已经不区分行内、块级了。

##### 性质2：浮动的元素互相贴靠

我们来看一个例子就明白了。

我们给三个div均设置了`float: left;`属性之后，然后设置宽高。当改变浏览器窗口大小时，可以看到div的贴靠效果：

<img src="http://img.smyhvae.com/20170730_1910.gif" alt="img" style="zoom: 50%;" />

上图显示，3号如果有足够空间，那么就会靠着2号。如果没有足够的空间，那么会靠着1号大哥。 如果没有足够的空间靠着1号大哥，3号自己去贴左墙。

不过3号自己去贴墙的时候，注意：

<img src="http://img.smyhvae.com/20170730_1928.gif" alt="img" style="zoom:50%;" />

上图显示，3号贴左墙的时候，并不会往1号里面挤。

同样，float还有一个属性值是`right`，这个和属性值`left`是对称的。

##### 性质3：浮动的元素有“字围”效果

来看一张图就明白了。我们让div浮动，p不浮动。

<img src="http://img.smyhvae.com/20170730_2005.png" alt="img" style="zoom:50%;" />

上图中，我们发现：**div挡住了p，但不会挡住p中的文字**，形成“字围”效果。

总结：**标准流中的文字不会被浮动的盒子遮挡住**。（文字就像水一样）

关于浮动我们要强调一点，浮动这个东西，为避免混乱，我们在初期一定要遵循一个原则：**永远不是一个东西单独浮动，浮动都是一起浮动，要浮动，大家都浮动。**

##### 性质4：收缩

收缩：一个浮动的元素，如果没有设置width，那么将自动收缩为内容的宽度（这点非常像行内元素）。

举例如下：

![img](http://img.smyhvae.com/20170801_1720.png)

上图中，div本身是块级元素，如果不设置width，它会单独霸占整行；但是，设置div浮动后，它会收缩

##### 浮动的补充（做网站时注意）

<img src="http://img.smyhvae.com/20170731_2248.png" alt="img" style="zoom:50%;" />

上图所示，将para1和para2设置为浮动，它们是div的儿子。此时para1+para2的宽度小于div的宽度。效果如上图所示。可如果设置para1+para2的宽度大于div的宽度，我们会发现，para2掉下来了：

<img src="https://raw.githubusercontent.com/Simin-hub/Picture/master/img/image-20220831215203154.png" alt="image-20220831215203154" style="zoom:67%;" />

### CSS属性

#### 定位属性

CSS的定位属性有三种，分别是绝对定位、相对定位、固定定位。

```text
	position: absolute;  <!-- 绝对定位 -->

	position: relative;  <!-- 相对定位 -->

	position: fixed;     <!-- 固定定位 -->
```

##### 相对定位

**相对定位**：让元素**相对于自己原来的位置**，进行位置调整（可用于盒子的位置微调）。

我们之前学习的背景属性中，是通过如下格式：

```text
	background-position:向右偏移量 向下偏移量;
```



但这回的定位属性，是通过如下格式：

```text
	position: relative;
	left: 50px;
	top: 50px;
```

###### 相对定位不脱标

**相对定位**：不脱标，老家留坑，**别人不会把它的位置挤走**。

也就是说，**相对定位的真实位置还在老家**，只不过影子出去了，可以到处飘。

###### 相对定位的用途

如果想做“压盖”效果（把一个div放到另一个div之上），我们一般**不用**相对定位来做。相对定位，就两个作用：

（1）微调元素

（2）做绝对定位的参考，子绝父相

###### 相对定位的定位值

- left：盒子右移
- right：盒子左移
- top：盒子下移
- bottom：盒子上移

##### 绝对定位

**绝对定位**：定义横纵坐标。原点在父容器的左上角或左下角。横坐标用left表示，纵坐标用top或者bottom表示。

格式举例如下：

```text
	position: absolute;  /*绝对定位*/
	left: 10px;  /*横坐标*/
	top/bottom: 20px;  /*纵坐标*/
```

###### 绝对定位脱标

**绝对定位的盒子脱离了标准文档流。**

所以，所有的标准文档流的性质，绝对定位之后都不遵守了。

绝对定位之后，标签就不区分所谓的行内元素、块级元素了，不需要`display:block`就可以设置宽、高了。

###### 绝对定位的参考点（重要）

（1）如果用**top描述**，那么参考点就是**页面的左上角**，而不是浏览器的左上角：

<img src="http://img.smyhvae.com/20180115_2120.png" alt="img" style="zoom:50%;" />

（2）如果用**bottom描述**，那么参考点就是**浏览器首屏窗口尺寸**（好好理解“首屏”二字），对应的页面的左下角：

![img](http://img.smyhvae.com/20180115_2121.png)

为了理解“**首屏**”二字的含义，我们来看一下动态图：

![img](http://img.smyhvae.com/20180115_2200.gif)

###### 以盒子为参考点

一个绝对定位的元素，**如果父辈元素中也出现了已定位**（无论是绝对定位、相对定位，还是固定定位）的元素，那么**将以父辈这个元素，为参考点**。

###### 让绝对定位中的盒子在父亲里居中

我们知道，如果想让一个**标准流中的盒子在父亲里居中**（水平方向看），可以将其设置`margin: 0 auto`属性。

可如果盒子是绝对定位的，此时已经脱标了，如果还想让其居中（位于父亲的正中间），可以这样做：

```text
	div {
		width: 600px;
		height: 60px;
		position: absolute;  绝对定位的盒子
		left: 50%;           首先，让左边线居中
		top: 0;
		margin-left: -300px;  然后，向左移动宽度（600px）的一半
	}
```

##### 固定定位

**固定定位**：就是相对浏览器窗口进行定位。无论页面如何滚动，这个盒子显示的位置不变。

备注：IE6不兼容。

**用途1**：网页右下角的“返回到顶部”

**用途2**：顶部导航条

我们经常能看到固定在网页顶端的导航条，可以用固定定位来做。

需要注意的是，假设顶部导航条的高度是60px，那么，为了防止其他的内容被导航条覆盖，我们要给body标签设置60px的padding-top。

###### 5、z-index属性：

**z-index**属性：表示谁压着谁。数值大的压盖住数值小的。

有如下特性：

（1）属性值大的位于上层，属性值小的位于下层。

（2）z-index值没有单位，就是一个正整数。默认的z-index值是0。

（3）如果大家都没有z-index值，或者z-index值一样，那么在HTML代码里写在后面，谁就在上面能压住别人。定位了的元素，永远能够压住没有定位的元素。

（4）只有定位了的元素，才能有z-index值。也就是说，不管相对定位、绝对定位、固定定位，都可以使用z-index值。**而浮动的元素不能用**。

（5）从父现象：父亲怂了，儿子再牛逼也没用。意思是，如果父亲1比父亲2大，那么，即使儿子1比儿子2小，儿子1也能在最上层。

z-index属性的应用还是很广泛的。当好几个已定位的标签出现覆盖的现象时，我们可以用这个z-index属性决定，谁处于最上方。也就是**层级**的应用。

**层级：**

（1）必须有定位（除去static）

（2）用`z-index`来控制层级数。

### css布局

[主要参考](https://blog.csdn.net/zhang6223284/article/details/81909600)



#### 1.table布局

​		table 的特性决定了它非常适合用来做布局，并且表格中的内容可以自动居中，这是之前用的特别多的一种布局方式。

​		但是它也有自身的局限性，比如 table 比其它 html 标记占更多的字节（造成下载时间延迟,占用服务器更多流量资源），table 会阻挡浏览器渲染引擎的渲染顺序。(会延迟页面的生成速度,让用户等待更久的时间)，但是某些情况下，当采用其他方式不能很好的达到自己的效果时，采用 table 布局能适应当前场景。

#### 2.浮动布局

​		float 布局应该是目前各大网站用的最多的一种布局方式了。浮动元素是脱离文档流的，但不脱离文本流，这是什么意思呢，用过 word 的应该知道有一种图片环绕的方式是文字环绕吧，就是这种效果。

​		特点：

​	1.对自身的影响

​		1.1float 元素可以形成块，如 span 元素。可以让行内元素也拥有宽和高，因为块级元素具有宽高
​		1.2浮动元素的位置尽量靠上
​		1.3尽量靠左（float:left）或右（float:right），如果那一行满足不了浮动元素的宽度要求，则元素会往下掉
​	2.对兄弟元素的影响
​		2.1不影响其他块级元素的位置
​		2.2影响其他块级元素的文本
​		2.3上面贴非 float 元素
​		2.4旁边贴 float 元素或者边框
​	3.对父级元素的影响
​		3.1从布局上 “消失”
​		3.2高度塌陷

​		但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。

​	解决办法有下面几种

​		1.父元素设置 overflow: auto 或者 overflow: hidden

​		2.给父元素加一个 after 伪类

#### 3.定位布局

​	通过position的属性，进行布局，定义各个元素所在的像素位置。

​	position 有如下几个值

​		static（默认情况，存在文档流当中）
​		relative（根据元素本身原来所应该处的位置偏移，不会改变布局的计算）
​		absolute（绝对定位，脱离文档流，不会对别的元素造成影响，相对的是父级最近的 relative 或者 absolute 定位元素）
​		fixed（绝对定位，脱离文档流，相对于的是屏幕，就是那些浮动的广告那样，怎么拉都固定在同一个位置，而 absolute 元素离开屏幕就看不见了）

#### 4.弹性盒子布局

flexbox 布局即弹性盒子布局，它的特点是盒子本来就是并列的，只需要指定宽度，来看一个经典的三栏布局的例子

#### Grid布局

​	Grid布局，是一个基于网格的二维布局系统，目的是用来优化用户界面设计。例如grid960

## less\sass

​		都是css的拓展语言，less和sass最主要的区别是less是通过Javascript编译，而sass是通过ruby编译的，如果没有引入前端工程化，less会消耗客户端性能，sass会消耗服务端性能，但是引入前端工程化的话，gunt，gulp，webpack等，less和sass在打包阶段都会转化成css，所以不会有区别，只是sass是基于ruby，所以每次npm的时候相对慢一点点

​		CSS是一种标记性语言。如果没有calc()方法，CSS是不能进行真正意义上的计算的，更不提函数、变量这些了。

​		less是一种动态样式语言，对css赋予了动态语言的特性，比如变量、继承、运算、函数，既可以运行在客户端，也可以运行在服务器端，依赖JavaScript。

​		sass是一种动态语言，属于缩排语法，比css多出很多功能，比如变量、嵌套、运算、混入、继承、函数等，更容易阅读；

​		sass与scss关系：sass的缩排语法，对于阅读者很不直观，因此sass对语法进行改良，sass3就变成scss，与原来的语法兼容，只是用{}取代了原来的缩进。



​		区别之处：

​		1.less基于JavaScript，是在客户端处理的

​    		很多开发者不会选择Less因为javaScript引擎需要额外的时间来处理代码然后输出修改过的Css到浏览器， 【解决：只在开发阶段使用Less,一旦开发完成，复制Less输出的到一个压缩器，然后用一个单独的css文件来代替Less文件；另一种方式是使用Less App来编译和压缩你的Less文件；这两种方式都是最小化样式输出】

​		2.sass是基于ruby的，是在服务器端处理的

​		变量在less和sass中唯一的区别就是，less使用@，sass使用$

​		3.变量、使用方面的区别

[主要参考](https://www.jianshu.com/p/6a35a548c9e1)

[主要参考](https://www.cnblogs.com/AmyLin-blogs/p/11453646.html)

### less

[less中文网](https://less.bootcss.com/)

1.变量：使用@变量名

```
@width: 10px;
@height: @width + 10px;

#header {
  width: @width;
  height: @height;
}
```

2.混合

3.嵌套

5.运算

6.转义

7.函数

8.命名空间和访问符

9.映射

10.作用域

11.注释

12.导入

### sass

[sass中文文档](https://www.sass.hk/docs/)

​	1.变量

​	2.注释

​	3.数据类型

​	4.运算

​	5.圆括号

​	6.函数

​	7.插值语句

​	8.&

​	9.变量定义

## 学习心得

​		在这部分学习中，主要学习了语义化标签和css事件。大部分的内容都是之前自己看视频和张凡老师讲解过的，学习起来比较轻松，自己也练习大部分的标签和css事件，练习才会深入理解这些标签和事件。通过练习和老师的讲解对标签的语义化也有了更明确的理解。css事件也主要是通过练习才能知道怎么用，怎么区分这些选择器。

​	在老师讲解布局的时候，也明白了模块化设计的重要意义与便利。CCS模块将作用域限制于组件中，从而避免了全局作用域的问题。我们再也不用操心为组件寻找一个好的命名了，因为编译过程已经帮你完成了这个任务。模块化设计的理念是通用的，学到的不是某一种模式，是整个模块化设计的理念，学习的不再是一个简单的运用而是理解其中的原理，分离常用的样式，设置统一的命名空间，代码的复用，对我们以后学习各种设计模式有所帮助。

​		在写笔记的学习的时候，查了很多的资料，也仔细看了一些文章，对加深了对标签和时间的理解和映象，less和sass在之前张凡老师也讲过，主要的用法还是得通过自学才能完成。以后还需要对这一块的知识进行补充。也还需要通过多运用和理解，不断练习提高自己。

​	