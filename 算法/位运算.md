# 位运算

在计算机系统中，数值一律用 **补码** 来表示和存储。**补码的优势：** 加法、减法可以统一处理（CPU只有加法器）。因此，以上方法 **同时适用于正数和负数的加法** 。

## 一：表示法：

### 1、正数5的表示法

假设有一个 int 类型的数，值为5，那么，我们知道它在计算机中表示为：

00000000 00000000 00000000 00000101

5转换成二制是101，不过int类型的数占用4字节（32位。32位机器上为32，64位机器上为64），所以前面填了一堆0。

### 2、负数-5的表示法

现在想知道，-5在计算机中如何表示？在计算机中，负数以原码的补码形式表达。

## 二、概念：

### 1、原码：

**一个正数，按照绝对值大小转换成的二进制数；一个负数按照绝对值大小转换成的二进制数，然后最高位补1，称为原码。**
比如 

00000000 00000000 00000000 00000101 是 5的 原码。

10000000 00000000 00000000 00000101 是 -5的 原码。

  备注：

 比如byte类型,用2^8来表示无符号整数的话,是0 - 255了；如果有符号， 最高位表示符号,0为正,1为负,那么,正常的理解就是 -127 至 +127 了.这就是原码了,值得一提的是,原码的弱点,有2个0,即+0和-0（10000000和00000000）；还有就是,进行异号相加或同号相减时,比较笨蛋,先要判断2个数的绝对值大小,然后进行加减操作,最后运算结果的符号还要与大的符号相同；于是,反码产生了。

#### 2、反码

**正数的反码与原码相同**，**负数的反码为对该数的原码除符号位外各位取反[每一位取反(除符号位)]**。

取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）

比如：

正数00000000 00000000 00000000 00000101 的反码还是 00000000 00000000 00000000 00000101

负数10000000 00000000 00000000 00000101 的反码则是 11111111 11111111 11111111 11111010。

反码是相互的，所以也可称：10000000 00000000 00000000 00000101 和 11111111 11111111 11111111 11111010互为反码。

备注：还是有+0和-0,没过多久，反码就成为了过滤产物,也就是,后来补码出现了。

#### 3、补码

**正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1.**

比如：10000000 00000000 00000000 00000101 的补码是：11111111 11111111 11111111 11111010。
那么，补码为：

11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011

备注：1、从补码求原码的方法跟原码求补码是一样的 ，也可以通过完全逆运算来做，先减一，再取反。

 2、**补码却规定0没有正负之分**

所以，-5 在计算机中表达为：11111111 11111111 11111111 11111011。转换为十六进制：0xFFFFFFFB。

## 四、主要知识点

- 正数的反码和补码都与原码**相同**。
- 负数的反码为对该数的原码**除符号位外各位取反**。
- **负数**的补码为对该数的原码**除符号位外各位取反，然后在最后一位加1**

- 源码：优点在于换算简单 缺点在于两个零 加减法需要独立运算
- 反码：有点在于表示清晰 缺点在于两个零 加减法同样需要独立运算
- 补码：优点在于一个零 范围大 减法可以转为加法 缺点在于理解困难

下面是书上原文：

- 原码表示法规定：**用符号位和数值表示带符号数，正数的符号位用“0”表示，负数的符号位用“1”表示**，数值部分用二进制形式表示。
- 反码表示法规定：正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反。
- 补码表示法规定：正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1.
- **正零和负零的补码相同**，[+0]补=[-0]补=0000 0000B



## 五、特殊情况-128

1000 0000,那么,它的原码是什么呢?从补码求原码的方法跟原码求补码是一样的。先保留符号位其它求反: 1111 1111, 再加1，11000 0000, 超过了8位了。对,用8位数的原码在这里已经无法表示了。

那么,回到原码处, 它的原码也是 1000 0000(超出的自动丢失),1000 0000 在原码表示什么呢? -0, 但补码却规定0没有正负之分。

转换一下思路,看看计算机里,是怎么运算的:

对于负数,先取绝对值,然后求反,加一

-128 -> 128 -> 1000 0000 -> 0111 1111 -> 1000 0000

现在明确了吧

所以, 8位有符号的整数取值范围的补码表示

1000 0000 到 0000 0000, 再到 0111 1111

即 -128 到 0, 再到 127

最终 -128 ~ +127

永远记住：程序里的加减法对 二进制是永远有效的。但是并不一定适合于真实世界。

byte m = -128;

byte q = 1;

byte p = (byte)(m - q); //这一步其实编译器会报错，其实是发现越界了，我们强行转化为byte就可以看出结果。

System.out.println( p); p的结果为：127

## 6. 补码（二进制转十进制）

> 表示正数的补码可以直接转成十进制，表示负数的补码想要转回十进制步骤如下：
>
> - 对表示负数的补码取反码加一得到负数的十进制绝对值补码；
> - 再将负数的十进制绝对值补码转成十进制得到负数的十进制绝对值；
> - 最后加上符号位；

## 补码相加

> 无论是正数加正数（十进制加法）还是正数/负数加负数（十进制减法）都可以用补码加补码表示

**正数加正数的补码计算过程示例：**

| 表达式 |                               补码相加 | 二进制结果 | 十进制结果 |
| :----: | -------------------------------------: | :--------: | :--------: |
|  0+0   | 0000 0000 + 0000 0000 —————— 0000 0000 | 0000 0000  |     0      |
|  0+1   | 0000 0000 + 0000 0001 —————— 0000 0001 | 0000 0001  |     1      |
|  1+1   | 0000 0001 + 0000 0001 —————— 0000 0010 | 0000 0010  |     2      |
|  2+1   | 0000 0010 + 0000 0001 —————— 0000 0011 | 0000 0011  |     3      |

**正数加负数的补码计算过程示例：**

| 表达式 |                                 补码相加 | 二进制结果 | 十进制结果 |
| :----: | ---------------------------------------: | :--------: | :--------: |
| 0+(-0) |   0000 0000 + 0000 0000 —————— 0000 0000 | 0000 0000  |     0      |
| 0+(-1) |   0000 0000 + 1111 1111 —————— 1111 1111 | 1111 1111  |     -1     |
| 1+(-1) | 0000 0001 + 1111 1111 —————— 1,0000 0000 | 0000 0000  |     0      |
| 1+(-2) |   0000 0001 + 1111 1110 —————— 1111 1111 | 1111 1111  |     -1     |
| 2+(-2) | 0000 0010 + 1111 1110 —————— 1,0000 0000 | 0000 0000  |     0      |
| 2+(-1) | 0000 0010 + 1111 1111 —————— 1,0000 0001 | 0000 0001  |     1      |

**负数加负数的补码计算过程示例：**

|  表达式   |                                 补码相加 | 二进制结果 | 十进制结果 |
| :-------: | ---------------------------------------: | :--------: | :--------: |
| (-0)+(-0) |   0000 0000 + 0000 0000 —————— 0000 0000 | 0000 0000  |     0      |
| (-1)+(-1) | 1111 1111 + 1111 1111 —————— 1,1111 1110 | 1111 1110  |     -2     |
| (-1)+(-2) | 1111 1111 + 1111 1110 —————— 1,1111,1101 | 1111 1101  |     -3     |

## 二进制、反码、补码

**同样的一串二进制数字，即可以是反码也可以是补码，如果是补码则其可以通过上述规则转成对应的十进制数值，如果是反码则代表其为计算过程中间值，如果想知道反码在十进制中所表示的数值，可以将其视为补码再通过上述规则转成十进制即可。**

**正数示例：**

| 十进制数值 x | x 取补码 fn1(x)=a | x 取反码 fn2(x)=b | b 的十进制形式 y |
| :----------: | :---------------: | :---------------: | :--------------: |
|      0       |     0000 0000     |     1111 1111     |        -1        |
|      1       |     0000 0001     |     1111 1110     |        -2        |
|      2       |     0000 0010     |     1111 1101     |        -3        |
|      3       |     0000 0011     |     1111 1100     |        -4        |
|      4       |     0000 0100     |     1111 1011     |        -5        |

**负数示例：**

| 十进制数值 x | x 取补码 fn1(x)=a | x 取反码 fn2(x)=b | b 的十进制形式 y |
| :----------: | :---------------: | :---------------: | :--------------: |
|      -0      |     0000 0000     |     1111 1111     |        -1        |
|      -1      |     1111 1111     |     0000 0000     |        0         |
|      -2      |     1111 1110     |     0000 0001     |        1         |
|      -3      |     1111 1101     |     0000 0010     |        2         |

**示例汇总：**

| 十进制数值 x | x 取补码 fn1(x)=a | x 取反码 fn2(x)=b | b 的十进制形式 y | y + 1 | 十进制数值 x |
| :----------: | :---------------: | :---------------: | :--------------: | :---: | :----------: |
|      0       |     0000 0000     |     1111 1111     |        -1        |   0   |      0       |
|      1       |     0000 0001     |     1111 1110     |        -2        |  -1   |      1       |
|      2       |     0000 0010     |     1111 1101     |        -3        |  -2   |      2       |
|      3       |     0000 0011     |     1111 1100     |        -4        |  -3   |      3       |
|      -0      |     0000 0000     |     1111 1111     |        -1        |   0   |      -0      |
|      -1      |     1111 1111     |     0000 0000     |        0         |   1   |      -1      |
|      -2      |     1111 1110     |     0000 0001     |        1         |   2   |      -2      |
|      -3      |     1111 1101     |     0000 0010     |        2         |   3   |      -3      |

通过该表格示例可以得出以下两个规律：

### 规律 一

反码所表示的数值与原数值之间规律如下（**y 代表反码之后的十进制值**）：

- **fn2(x) = -x-1**
- **fn2(x) + 1 = -x**
- **y = -x-1**
- **y +1 = -x**

即如果想得到一个十进制正数值的负数形式（1 => -1）或则得到一个十进制负数值的正数形式可以通过对原值取反码加一得到：

| 十进制数值 x | 十进制取反 -x | 过程               |
| ------------ | ------------- | ------------------ |
| 0            | 0             | 取反码(0)+1 = -1+1 |
| 1            | -1            | 取反码(1)+1 = -2+1 |
| 2            | -2            | 取反码(2)+1 = -3+1 |
| 3            | -3            | 取反码(3)+1 = -4+1 |
| -1           | 1             | 取反码(-1)+1 = 0+1 |
| -2           | 2             | 取反码(-2)+1 = 1+1 |
| -3           | 3             | 取反码(-3)+1 = 2+1 |

### 规律 二

将示例汇总表格再进一步简化：

| 十进制数值 x | x 的反码十进制表示形式 y | 翻译 -1        | 翻译 -2         |
| :----------: | :----------------------: | -------------- | --------------- |
|      0       |            -1            | 0 的反码是 -1  | -1 是 0 的反码  |
|      1       |            -2            | 1 的反码是 -2  | -2 是 1 的反码  |
|      2       |            -3            | 2 的反码是 -3  | -3 是 2 的反码  |
|      3       |            -4            | 3 的反码是 -4  | -4 是 3 的反码  |
|      -0      |            -1            | -0 的反码是 -1 | -1 是 -0 的反码 |
|      -1      |            0             | -1 的反码是 0  | 0 是 -1 的反码  |
|      -2      |            1             | -2 的反码是 1  | 1 是 -2 的反码  |
|      -3      |            2             | -3 的反码是 2  | 2 是 -3 的反码  |

可以看出在十进制格式下，原数值与反码的关系：

- 如果我需要 -1 我可以用 0 的反码代替；
- 如果我需要 -4 我可以用 3 的反码代替；
- 规律：
  - **x = |y| -1**
  - **x + y = -1**

## 位操作

Go 编程语言支持以下按位运算符：

```
&   与运算 	0 & 1 = 0    1 & 1 = 1       0 & 0 = 0
 |   或运算   	0 | 1 = 1    1 | 1 = 1       0 | 0 = 0
 ^   异或运算	0 ^ 1 = 1    1 ^ 1 = 0       0 ^ 0 = 0
&^   与非运算	0 &^ 1 = 0   1 &^ 1 = 0     0 &^ 0 = 0     1 &^ 0 = 1
<<   左移
>>	 右移
```

#### & 运算符

在 Go 中， & 运算符在两个整型操作数中执行按位 AND 操作。AND 操作具有以下属性:

```
Given operands a, b
AND(a, b) = 1; only if a = b = 1
               else = 0
```

AND 运算符具有选择性的把**整型数据的位**清除为 0 的好的效果。 例如，我们可以使用 & 运算符去清除（设置）最后 4 个最低有效位（LSB）全部为 0 。

```
func main() {
    var x uint8 = 0xAC    // x = 10101100
    x = x & 0xF0          // x = 10100000
}
```

所有的位运算都支持简写的赋值形式。 例如，前面的例子可以重写为如下。

```
func main() {
    var x uint8 = 0xAC    // x = 10101100
    x &= 0xF0             // x = 10100000
}
```

另外一个巧妙的技巧是：你可以**用 & 操作去测试一个数字是奇数还是偶数。原因是当一个数字的二进制的最低位是 1 的时候，那他就是奇数**。我们可以用一个数字和 1 进行 & 操作，然后在和 1 做 AND 运算，如果的到的结果是 1 ，那么这个原始的数字就是奇数

#### | 操作符

`|` 对其整型操作数执行按位`或`操作。回想一下`或`操作符具备以下性质：

```
Given operands a, b
OR(a, b) = 1; when a = 1 or b = 1
              else = 0 
```

我们可以利用按位`或`操作符为给定的整数有选择地设置单个位。例如，在如下示例中我们使用按位`或`将示例数（从低位到高位（MSB））中的第 3 ，第 7 和第 8 位置为 1 。

```
func main() {
    var a uint8 = 0
    a |= 196
    fmt.Printf("%b", a)
}

// 打印结果  11000100
            ^^   ^    
```

#### ^ 操作符

在 Go 中 按位 `异或` 操作是用 `^` 来表示的。 `异或`运算符有如下的特点：

```
Given operands a, b
XOR(a, b) = 1; only if a != b
     else = 0
```

**`异或`运算的这个特性可以用来把二进制位的一个值变成另外一个值**。举个例子，给到一个 16 进制的值，我们可以使用以下代码切换前 8 位（从 MSB 开始）的值。

```
func main() {
    var a uint16 = 0xCEFF
    a ^= 0xFF00 // same a = a ^ 0xFF00
}

// a = 0xCEFF   (11001110 11111111)
// a ^=0xFF00   (00110001 11111111)
```

在前面的代码片段中，与 1 进行异或的位被翻转（从 0 到 1 或从 1 到 0）。异或 运算的一个实际用途，例如，可以利用 异或运算去比较两个数字的符号是否一样。当 (a ^ b) ≥ 0 （或相反符号的 (a ^ b) < 0 ）为 true 的时候，两个整数 a，b 具有相同的符号，如下面的程序所示：

```
func main() {
    a, b := -12, 25
    fmt.Println("a and b have same sign?", (a ^ b) >= 0)
}
```

**^ 作为取反位运算符 （非）**

不像其他语言 （c/c++，Java，Python，Javascript，等）， **Go 没有专门的一元取反位运算符**。取而代之的是，XOR 运算符 ^，也可作为一元取反运算符作用于一个数字。对于给定位 x，在 Go 中 x = 1 ^ x 可以翻转该位。在以下的代码段中我们可以看到**使用 ^a 获取变量 a 的取反值的操作。**

```
func main() {
    var a byte = 0x0F
    fmt.Printf("%08b\n", a)
    fmt.Printf("%08b\n", ^a)
}

// 打印结果
00001111     // var a
11110000     // ^a
```

#### &^ 操作符

`&^` 操作符意为 `与非`，是 `与` 和 `非` 操作符的简写形式，它们定义如下。

```
Given operands a, b
AND_NOT(a, b) = AND(a, NOT(b))
```

如果第二个操作数为 1 那么它则具有清除第一个操作数中的位的趣味特性。

```
AND_NOT(a, 1) = 0; clears a
AND_NOT(a, 0) = a; 
```

接下来的代码片段使用 `AND NOT` 操作符，将变量值 `1010 1011` 变为 `1010 0000`，清除了操作数上的低四位。

```
func main() {
    var a byte = 0xAB
     fmt.Printf("%08b\n", a)
     a &^= 0x0F
     fmt.Printf("%08b\n", a)
}

// 打印：
10101011
10100000
```

### **<<和>> 操作符**

与其他 C 的衍生语言类似， Go 使用 << 和 >> 来表示左移运算符和右移运算符，如下所示：

```
Given integer operands a and n,
a << n; shifts all bits in a to the left n times
a >> n; shifts all bits in a to the right n times
```

例如，在下面的代码片段中变量 a （00000011）的值将会左移位运算符分别移动三次。每次输出结果都是为了说明左移的目的。

```
func main() {
    var a int8 = 3
    fmt.Printf("%08b\n", a)
    fmt.Printf("%08b\n", a<<1)
    fmt.Printf("%08b\n", a<<2)
    fmt.Printf("%08b\n", a<<3)
}

// 输出的结果:
00000011
00000110
00001100
00011000
```

## 位运算实现基本运算

[参考](https://www.jianshu.com/p/7bba031b11e7)

### 加法

先来个我们最熟悉的十进制的加法运算：

> 13 + 9 = 22

我们像这样来拆分这个运算过程：

1. 不考虑进位，分别对各位数进行相加，结果为sum：
    个位数3加上9为2；十位数1加上0为1； 最终结果为12；
2. 只考虑进位，结果为carry：
    3 + 9 有进位，进位的值为10；
3. 如果步骤2所得进位结果carry不为0，对步骤1所得sum，步骤2所得carry重复步骤1、 2、3；如果carry为0则结束，最终结果为步骤1所得sum：
    这里即是对sum = 12 和carry = 10重复以上三个步骤，(a) 不考虑进位，分别对各位数进行相加:sum = 22; (b) 只考虑进位: 上一步没有进位，所以carry = 0； (c) 步骤2carry = 0，结束，结果为sum = 22.

我们发现这三板斧行得通！

那我们现在还使用上面的三板斧把十进制运算放在二进制中看看是不是也行的通。

13的二进制为0000 1101，9的二进制为0000 1001:

1. **不考虑进位，分别对各位数进行相加**：
    sum = 0000 1101 + 0000 1001 = 0000 0100
2. **考虑进位**：
    有两处进位，第0位和第3位，只考虑进位的结果为：
    carry = 0001 0010
3. 步骤2carry == 0 ?，不为0，重复步骤1 、2 、3；为0则结束，结果为sum：
    本例中，
    (a)不考虑进位sum = 0001 0110;
    (b)只考虑进位carry  = 0;
    (c)carry == 0，结束，结果为sum = 0001 0110
    转换成十进制刚好是22.

我们发现，适用于十进制的三板斧同样适用于二进制！仔细观察者三板斧，大家能不能发现其实**第一步不考虑进位的加法其实就是异或运算**；而第二部**只考虑进位就是与运算并左移一位**--；第三步就是**重复前面两步操作直到第二步进位结果为0**。

这里关于第三步多说一点。为什么要循环步骤1、 2、 3直到步骤2所得进位carry等于0？其实这是因为有的数做加法时会出现连续进位的情况，举例：3 + 9，我们来走一遍上述逻辑：

> a = 0011, b = 1001;
>  start;

> first loop;
>  1.1 sum = 1010
>  1.2 carry = 0010
>  1.3 carry != 0 , go on;

> second loop;
>  2.1 sum = 1000;
>  2.2 carry = 0100;
>  2.3 carry != 0, go on;

> third loop;
>  3.1 sum = 1100;
>  3.2 carry = 0000;
>  3.3 carry == 0, stop; result = sum;

> end

如上面的栗子，有的加法操作是有连续进位的情况的，所以这里要在第三步检测carry是不是为0，如果为0则表示没有进位了，第一步的sum即为最终的结果。

有了上面的分析，我们不难写出如下代码：



```go
// 递归写法
func add(a int, b int) int {
    if(b == 0)
        return a
    sum := a ^ b
    carry := (a & b) << 1
    return add(sum, carry)
}

// 迭代写法
func add(a int, b int) int {
  carry:=0
  for b!=0{  //相当于进位不等于0
      carry=(a&b)<<1 //算出进位
      a^=b           //算出不带进位的和
      b=carry        //更新进位
  }
  return a
}
```

我们的计算机其实就是通过上述的位运算实现加法运算的（通过加法器，加法器就是使用上述的方法实现加法的），而程序语言中的+ - * /运算符只不过是呈现给程序员的操作工具，计算机底层实际操作的永远是形如0101的位，所以说位运算真的很重要！

### 减法

我们知道了位运算实现加法运算，那减法运算就相对简单一些了。我们实现了加法运算，自然的，我们会想到把**减法运算11 - 6变形为加法运算11 + (-6)**，即一个正数加上一个负数。是的，很聪明，其实我们的计算机也是这样操作的，那有的人会说为什么计算机不也像加法器一样实现一个减法器呢？对的，这样想当然是合理的，但是考虑到减法比加法来的复杂，实现起来比较困难。为什么呢？我们知道加法运算其实只有两个操作，加、 进位，而减法呢，减法会有借位操作，如果当前位不够减那就从高位借位来做减法，这里就会问题了，借位怎么表示呢？加法运算中，进位通过与运算并左移一位实现，而借位就真的不好表示了。所以我们自然的想到将减法运算转变成加法运算。

怎么实现呢？

刚刚我们说了减法运算可转变成一个正数加上一个负数，那首先就要来看看负数在计算机中是怎么表示的。

+8在计算机中表示为二进制的1000，那-8怎么表示呢？

很容易想到，可以将一个二进制位（bit）专门规定为符号位，它等于0时就表示正数，等于1时就表示负数。比如，在8位机中，规定每个字节的最高位为符号位。那么，+8就是00001000，而-8则是10001000。这只是直观的表示方法，其实**计算机是通过2的补码来表示负数**的，那什么是2的补码（同补码，英文是2's complement，其实应该翻译为2的补码）呢？它是一种用二进制表示有号数的方法，也是一种将数字的正负号变号的方式，求取步骤：

- 第一步，每一个二进制位都除符号位外取相反值，0变成1，1变成0（即反码）。
- 第二步，将上一步得到的值（反码）加1。

简单来说就是**取反加一**！

关于补码更详细的内容可参[维基百科-补码](https://link.jianshu.com?t=!https://zh.wikipedia.org/wiki/二補數)，这里不再赘述。

其实我们利用的恰巧是补码的可以将数字的正负号变号的功能，这样我们就可以把减法运算转变成加法运算了，因为负数可以通过其对应正数求补码得到。计算机也是通过增加一个补码器配合加法器来做减法运算的，而不是再重新设计一个减法器。

以上，我们很容易写出了位运算做减法运算的代码：

```go
/*
* num1: 减数
* num2: 被减数
*/
func substract(num1, num2 int)int{
    subtractor := add(^num2, 1)// 先求减数的补码（取反加一） add 是最开始是的加法函数
    result := add(num1, subtractor) // add()即上述加法运算　　
    return result
}
```

### 乘法

我们知道了加法运算的位运算实现，那很容易想到**乘法运算可以转换成加法运算**，被乘数加上乘数倍的自己不就行了么。这里还有一个问题，就是乘数和被乘数的正负号问题，我们这样处理，**先处理乘数和被乘数的绝对值的乘积**，然后根据它们的符号确定最终结果的符号即可。步骤如下：

> (1) 计算绝对值得乘积
>
>  (2) 确定乘积符号（同号为证，异号为负）

有了这个思路，代码就不难写了：



```go
/*
* a: 被乘数
* b: 乘数
*/
func multiply(a, b int) int{ 
    // 取绝对值　　    
    multiplicand := a
    if a < 0{
        multiplicand = add(^a, 1) // add 是一开始的加法函数
    }
    multiplier := b
    if b < 0 {
    	multiplier = add(^b, 1)  // 如果为负则取反加一得其补码，即正数　　   
    }
    // 计算绝对值的乘积　　    
    product := 0
    count := 0   
    for count < multiplier {        
        product = add(product, multiplicand)     
        count = add(count, 1) // 这里可别用count++，都说了这里是位运算实现加法　　    
    }    
    // 确定乘积的符号　　    
    if (a ^ b) < 0 {// 只考虑最高位，如果a,b异号，则异或后最高位为1；如果同号，则异或后最高位为0；　　　　        
        product = add(^product, 1)
    }    
    return product
}
```

上面的思路在步骤上没有问题，但是第一步对绝对值作乘积运算我们是通过不断累加的方式来求乘积的，这在乘数比较小的情况下还是可以接受的，但在乘数比较大的时候，累加的次数也会增多，这样的效率不是最高的。我们可以思考，如何优化求绝对值的乘积这一步。

考虑我们现实生活中手动求乘积的过程，这种方式同样适用于二进制，下面我以13*14为例，向大家演示如何用手动计算的方式求乘数和被乘数绝对值的乘积。

![img](https:////upload-images.jianshu.io/upload_images/1925324-76fc13867d15d580.png?imageMogr2/auto-orient/strip|imageView2/2/w/448/format/webp)

从上图的计算过程可以看出，如果乘数当前位为1，则取被乘数左移一位的结果加到最终结果中；如果当前位为0，则取0加到乘积中（加0也就是什么也不做）；

整理成算法步骤：

> (1) 判断乘数是否为0，为0跳转至步骤(4)
>
> (2) 将乘数与1作与运算，确定末尾位为1还是为0，如果为1，则相加数为当前被乘数；如果为0，则相加数为0；将相加数加到最终结果中；
>
>  (3) 被乘数左移一位，乘数右移一位；回到步骤(1)
>
> (4) 确定符号位，输出结果；

代码如下：



```csharp
func multiply(a, b int) int{
    //将乘数和被乘数都取绝对值　
    // 取绝对值
    multiplicand := a
    if a < 0{
        multiplicand = add(^a, 1) // add 是一开始的加法函数
    }
    multiplier := b
    if b < 0 {
    	multiplier = add(^b, 1)  // 如果为负则取反加一得其补码，即正数　　   
    }

    //计算绝对值的乘积　　
    product := 0
	for multiplier > 0{
        if (multiplier & 0x1) > 0 {// 每次考察乘数的最后一位　　　　
            product = add(product, multiplicand)
        }
        multiplicand = multiplicand << 1 // 每运算一次，被乘数要左移一位　　　　
        multiplier = multiplier >> 1 // 每运算一次，乘数要右移一位（可对照上图理解）　　
    }
    //计算乘积的符号　　
    if (a ^ b) < 0 {
		product = add(^product, 1)
    }
    return product
}
```

显而易见，第二种求乘积的方式明显要优于第一种。

### 除法

除法运算很容易想到可以转换成减法运算，即不停的用除数去减被除数，直到被除数小于除数时，此时所减的次数就是我们需要的商，而此时的被除数就是余数。这里需要注意的是符号的确定，商的符号和乘法运算中乘积的符号确定一样，即取决于除数和被除数，同号为证，异号为负；余数的符号和被除数一样。
 代码如下：



```csharp
/*
* a : 被除数
* b : 除数
*/
func divide(a, b int)int{    
    // 先取被除数和除数的绝对值    
   	// 取绝对值
    dividend := a
    if a < 0{
        dividend = add(^a, 1) // add 是一开始的加法函数
    }
    divisor := b
    if b < 0 {
    	divisor = add(^b, 1)  // 如果为负则取反加一得其补码，即正数　　   
    }

    quotient := 0 // 商    
    remainder := 0 // 余数    
    // 不断用除数去减被除数，直到被除数小于被除数（即除不尽了）    
    for dividend >= divisor{// 直到商小于被除数        
        quotient = add(quotient, 1)
        dividend = substract(dividend, divisor)
    }
    // 确定商的符号    
    if (a ^ b) < 0 {// 如果除数和被除数异号，则商为负数  
        quotient = add(^quotient, 1)
    }    
    // 确定余数符号    
    if b > 0 {
        remainder = dividend
    }else{
        remainder = add(^dividend, 1)
    }
	// fmt.Println(remainder)
    return quotient // 返回商
}
```

这里有和简单版乘法运算一样的问题，如果被除数非常大，除数非常小，那就要进行很多次减法运算，有没有更简便的方法呢？

上面的代码之所以比较慢是因为步长太小，每次只能用1倍的除数去减被除数，所以速度比较慢。那能不能增大步长呢？如果能，应该怎么增大步长呢？

计算机是一个二元的世界，所有的int型数据都可以用[2^0, 21,...,231]这样一组基来表示（int型最高31位）。不难想到用除数的231,230,...,22,21,2^0倍尝试去减被除数，如果减得动，则把相应的倍数加到商中；如果减不动，则依次尝试更小的倍数。这样就可以快速逼近最终的结果。

2的i次方其实就相当于左移i位，为什么从31位开始呢？因为int型数据最大值就是2^31啊。

代码如下：



```csharp
func divide(a, b int)int{    
    // 先取被除数和除数的绝对值    
    dividend := a
    if a < 0{
        dividend = add(^a, 1) // add 是一开始的加法函数
    }
    divisor := b
    if b < 0 {
    	divisor = add(^b, 1)  // 如果为负则取反加一得其补码，即正数　　   
    }

    quotient := 0 // 商    
    remainder := 0 // 余数    
    for i := 31; i >= 0; i-- {
        //比较dividend是否大于divisor的(1<<i)次方，不要将dividend与(divisor<<i)比较，而是用(dividend>>i)与divisor比较，
        //效果一样，但是可以避免因(divisor<<i)操作可能导致的溢出，如果溢出则会可能dividend本身小于divisor，但是溢出导致dividend大于divisor       
        if (dividend >> i) >= divisor {            
            quotient = add(quotient, 1 << i)
            dividend = substract(dividend, divisor << i)
        }    
    }    
    // 确定商的符号    
    if (a ^ b) < 0 {
        // 如果除数和被除数异号，则商为负数        
        quotient = add(^quotient, 1)
    }    
   // 确定余数符号    
    if b > 0 {
        remainder = dividend
    }else{
        remainder = add(^dividend, 1)
    }
	// fmt.Println(remainder)
    return quotient // 返回商
}
```

### 幂运算

幂运算是我们平时写代码的时候最常用的运算之一。根据幂运算的定义我们可以知道，如果我们要求 `x` 的 `N` 次幂，那么想当然的就会写出一个 `N` 次的循环，然后累乘得到结果。所以我们要求幂运算的复杂度仍旧是 O_{(N)}*O*(*N*) ?

那么有没有一种更快的方法呢？

这里给出一种在计算机领域常用的快速幂算法，又叫**蒙哥马利幂（Montgomery reduction）算法**，将 O_{(N)}*O*(*N*) 降为 O_{(logN)}*O*(*l**o**g**N*) 。

我通过例子来讲解这个优化过程：

假设我们要算 `x` 的 `n` 次幂，使用累乘来编写代码：

```python
res = 1
for i in range(n):
    res *= x
```

好的，我们已经完成了 O_{(N)}*O*(*N*) 的解法。

#### 二进制拆分

为了优化这个算法，我们接下来进行数学推导：

我们继续思考当 `N = 10` 这个具体场景，我们可以把 10 写成二进制来表示 `1010(BIN)`，然后我们模拟一次**二进制转十进制的过程（复习一下大学知识）**：

10 = 2^3 \times \underline{1} + 2^2 \times \underline{0} + 2^1 \times \underline{1} + 2^0 \times \underline{0}10=23×1+22×0+21×1+20×0

我用下划线把二进制的 `1010` 标识出来，这样大家就可以发现二进制和十进制转换时的代数式规律。

继续回想刚才的场景，那么我们求 `x` 的 `10` 次幂，则式子我们可以写成这样：

x^{10} = x^{2^3 \times 1 + 2^2 \times 0 + 2^1 \times 1 + 2^0 \times 0}=x^{2^3 \times 1}\times x^{2^2 \times 0}\times x^{2^1 \times 1}\times x^{2^0 \times 0}*x*10=*x*23×1+22×0+21×1+20×0=*x*23×1×*x*22×0×*x*21×1×*x*20×0

我们按照二进制低位到高位从左往右交换一下位置：

x^{10}= (x^{2^0 \times 0})(x^{2^1 \times 1})(x^{2^2 \times 0})(x^{2^3 \times 1})*x*10=(*x*20×0)(*x*21×1)(*x*22×0)(*x*23×1)

我们关注相邻的两项，如果我们不考虑幂指数的 `*0` 和 `*1` ，我们只看前半部分，会发现有这么一个规律：

\frac{x^{2^k}}{x^{2^{k-1}}}=\frac{x^{2^{k-1}*2}}{x^{2^{k-1}}}=\frac{(x^{2^{k-1}})^2}{x^{2^{k-1}}}=x^{2^{k-1}}*x*2*k*−1*x*2*k*=*x*2*k*−1*x*2*k*−1∗2=*x*2*k*−1(*x*2*k*−1)2=*x*2*k*−1

也就是说，不考虑幂指数的 `*0` 和 `*1` 右式，**左式每次只要每次乘以自身，就是下一项的左式**。在我们的例子中其实就是。

这里我们单独看**第三项和第二项的关系**

x^{2^{2}}=(x^{2^1})^2*x*22=(*x*21)2

用编程思维来考虑这个问题，只要我们从 `x` 开始维护这么一个左式，每一次迭代都执行 `x *= x`，然后每次遇到右边是 `*1` 的情况，就记录一下 `res *= x` 是不是就能模拟咱们二进制拆分的计算思路了呢？

#### 编程实现一下 x 的 10 次方

我们用上面的思路，通过代码**来计算一下 2 的 10 次方，答案应该是 1024**。

```cpp
#include <iostream>
using namespace std;

int main() {
    int n = 10; // 幂指数，下面通过二进制拆分成 1010
    int x = 2; // 底数
    int res = 1; // 累乘的答案
    while (n) {
        // 去除二进制的最低位，也就是上面推导中的右式，如果 n & 1 == 1，说明是 *1
        if (n & 1) {
            // 如果是 *1，则根据我们观察出来的规律，对维护的结果做累乘
            res *= x;
        }
        // 转换到下一位
        x *= x;
        // 二进制右移一位，目的是取到下一个低位二进制
        n >>= 1;
    }
    cout << res << endl; // 1024
    return 0;
}
```

是不是发现非常的简单！我们至此已经实现了快速幂算法。我们将 `n`, `x` 做成参数，编写一个快速幂的方法：

```cpp
#include <iostream>
using namespace std;

int qpow(int x, int n) {
    int res = 1;
    while (n) {
        if (n & 1) res *= x;
        x *= x;
        n >>= 1;
    }
    return res;
}

int main() {
    cout << qpow(2, 10) << endl; // 1024
    cout << qpow(4, 2) << endl;  // 16
    cout << qpow(5, 3) << endl;  // 125
    cout << qpow(10, 6) << endl; // 1000000
    return 0;
}
```

#### 复杂度

通过上面对幂指数的拆分，发现快速幂只需要循环拆分的项数就可以完成整个幂运算。

我们不妨设求 x 的 N 次方，**并且令 x 的所有二进制位都为 1**，就可以得到下面这个等式：

2^0+2^1+...+2^k=N20+21+...+2*k*=*N*

那么其实，k 就是计算机需要计算的次数，也就是时间复杂度。套入公比是 1 的等比数列前 k 项和来反推 k 的大小：

\frac{a_1(1-q^k)}{1-q}=2^k-1=N \\ k=log_2{N-1} \Rightarrow O(logN)1−*q**a*1(1−*q**k*)=2*k*−1=*N**k*=*l**o**g*2*N*−1⇒*O*(*l**o**g**N*)

好了，这就是快速幂的全部内容了。你可以使用这道题的知识来求解 [LeetCode 372. Super Pow](https://www.desgard.com/algo/docs/part2/ch01/1-quick-pow/[https://leetcode-cn.com/classic/problems/super-pow/description/](https://leetcode-cn.com/classic/problems/super-pow/description/)) 。下一篇文我们来手把手 AC 这题。
