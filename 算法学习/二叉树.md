

# 二叉树

[链接](https://greyireland.gitbook.io/algorithm-pattern/shu-ju-jie-gou-pian/binary_tree#zhi-shi-dian)

## 二叉树遍历

**前序遍历**：**先访问根节点**，再前序遍历左子树，再前序遍历右子树。 (根左右)

**中序遍历**：先中序遍历左子树，**再访问根节点**，再中序遍历右子树 。(左根右)

**后序遍历**：先后序遍历左子树，再后序遍历右子树，**再访问根节点。**(左右根)

**递归遍历**

注意点

- 以根访问顺序决定是什么遍历
- 左子树都是优先右子树

```go
func preorderTraversal(root *TreeNode)  {
    if root==nil{
        return
    }
    // 1.
    fmt.Println(root.Val) // 先访问根再访问左右 前序遍历
    preorderTraversal(root.Left)
    // 2.
    // fmt.Println(root.Val) // 中序遍历
    preorderTraversal(root.Right)
    // 2.
    // fmt.Println(root.Val) // 后序遍历    
}
```

**前序遍历非递归**

```go
// V3：通过非递归遍历
func preorderTraversal(root *TreeNode) []int {
    // 非递归
    if root == nil{
        return nil
    }
    result:=make([]int,0)
    stack:=make([]*TreeNode,0)

    for root!=nil || len(stack)!=0{
        for root !=nil{
            // 前序遍历，所以先保存结果
            result=append(result, root.Val)
            stack=append(stack, root)
            root=root.Left
        }
        // pop
        node:=stack[len(stack)-1]
        stack=stack[:len(stack)-1]
        root=node.Right
    }
    return result
}
```

![Tree Traversal | zhendecai](https://raw.githubusercontent.com/jiutiananshu/Picture/master/img/pre-order.png)

```go
// 第二种前序非递归
func preorderTraversal(root *TreeNode) []int {
    // 非递归
    if root == nil{
        return nil
    }
    result:=make([]int,0)
    stack:=make([]*TreeNode,0)
    stack = append(stack, root)
    for len(stack) != 0{
        node := stack[len(stack)-1]
        result=append(result, root.Val)
        stack=stack[:len(stack)-1]
        if node != nil{
            stack = append(stack, node.Right)
            stack = append(stack, node.Left)
        } 
    }
    return result
}
```

<img src="https://raw.githubusercontent.com/jiutiananshu/Picture/master/img/20200804093407910.jpg" alt="image" style="zoom: 50%;" />

**中序遍历非递归**

```go
// 思路：通过stack 保存已经访问的元素，用于原路返回
func inorderTraversal(root *TreeNode) []int {
    result := make([]int, 0)
    if root == nil {
        return result
    }
    stack := make([]*TreeNode, 0)
    for len(stack) > 0 || root != nil {
        for root != nil {
            stack = append(stack, root)
            root = root.Left // 一直向左
        }
        // 弹出
        val := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, val.Val)
        root = val.Right
    }
    return result
}
```

