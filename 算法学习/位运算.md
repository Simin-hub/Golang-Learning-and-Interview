# 位运算

[参考地址](https://www.cnblogs.com/Neeo/articles/10536202.html)

## 什么是位运算？

简单来说，位运算是把数字转换为机器语言，也就是二进制来进行计算的一种运算形式。

首先，我们要明白一点，**位运算符之对整数起作用**，如果一个操作数（如浮点数）不是整数，那它首先会自动转换为整数后再执行。另外[Python语言参考](https://docs.python.org/3/reference/expressions.html#binary-bitwise-operations)中也强烈表示只能是整数！

## 基础知识

计算机内部是如何用二进制表示这些整数的？计算机内用[定点数](https://baike.baidu.com/item/定点数)表示的。那问题又来了，什么是定点数？
在计算机内，定点数有3种表示法：**原码**、**反码**和**补码**。

### 原码

[原码](https://baike.baidu.com/item/原码)(true form)是一种计算机中对数字的二进制定点表示方法。原码表示法在数值前面增加了一位符号位（即最高位为符号位）：正数该位为0，负数该位为1（0有两种表示：+0和-0），其余位表示数值的大小。

口诀在此：**一个正数，转换为二进制位就是这个正数的原码**。**负数的绝对值转换成二进制位然后在高位补1就是这个负数的原码**。

比如说`int`类型的`3`的原码是`11B`（B表示二进制位，这里你可以多了解一些进制之间的转换），在32位机器上占4个字节，所以，高位补0就是：

```
00000000 00000000 00000000 00000011	 # 正数的反码就是原码，这么写没毛病
```

那么`int`类型的`-3`的绝对值的二进制位就是`11B`展开后最高位补1就是：

```
10000000 00000000 00000000 00000011
```

但是呢，原码也有缺点，原码中的0分为`+0`和`-0`。不仅如此，在进行不同符号的加法运算或者同符号的减法运算时，不能直接判断出结果的正负，我们必须要将两个值的绝对值进行比较，然后再进行加减操作，最后符号由绝对值大的决定。

### 反码

[反码](https://baike.baidu.com/item/反码)是数值存储的一种，多应用于系统环境设置，如linux平台的目录和文件的默认权限的设置umask，就是使用反码原理。

口诀不能忘：**正数的反码就是原码**，**负数的反码等于原码除符号位以外所有位取反**。
比如还是刚才的那个`int`类型的`3`的反码是：

```
00000000 00000000 00000000 00000011	 # 正数的反码就是原码，这么写没毛病
```

那`int`类型的`-3`的反码是，让我们默念公式：负数的反码等于原码除符号位以外所有位取反！

```
10000000 00000000 00000000 00000011	 # -3的原码
11111111 11111111 11111111 11111100	 # 最高位为符号位，不变，其余取反
```

这样，反码解决了加减法运算问题

### 补码

在计算机系统中，数值一律用[补码](https://baike.baidu.com/item/补码)来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路支持。

记住口诀：**正数的补码与原码相同**，**负数的补码为其原码除符号位外所有位取反**（这就是反码了），**然后最低位加1**。
还是那个`int`类型的`3`的补码是：

```
00000000 00000000 00000000 00000011	 # 正数的补码与原码一致
```

那么`int`类型的`-3`的补码就是，让我们手掐口诀：

```
10000000 00000000 00000000 00000011  # -3的原码
11111111 11111111 11111111 11111100	 # 负数的补码为其原码除符号位外所有位取反
11111111 11111111 11111111 11111101  # 然后最低位加1，完美！
```

### 原、反、补码小结

原、反、补码小结：

- **正数的反码和补码都与原码相同**
- **负数的反码为该数的原码除符号位外所有位取反**
- **负数的补码为该数的原码除符号位外所有位取反，然后最低位加1**

优缺点：

- 原码最好理解，但是存在加减法运算不方便的问题，还有俩零蛋捣乱（`+0`、`-0`）
- 反码稍微难点，但仅解决了加减法的问题。俩零继续捣乱（`+0`、`-0`）
- 补码理解相对困难，但解决了上面的俩问题

## 单、双、三目运算

根据操作数的个数，运算符可以分为单目、双目、三目运算符，也称为**一元**、**二元**、**三元**运算符等。**若完成一个操作需要两个操作数，则称该运算符为双目运算符**；若完成一个操作需要一个操作数，则称该运算符为单目运算符。

### Python中的按位运算

首先来看规则。Python中的按位运算规则如下表所示：

| 运算符 |                             描述                             |
| :----: | :----------------------------------------------------------: |
|   &    | **按位与运算符**，参与运算的两个值，如果相应位都为1，则该位的结果为1，否则为0 |
|   ^    |    **按位异或运算符**，当两个对应的二进位相异时，结果为1     |
|   ~    | **按位取反运算符**，对数据的每个二进制位取反，即把1变为0，把0变为1 |
|   \|   |  **按位或运算**，只要对应两个二进制位有一个为1时，结果就为1  |
|   <<   | **左移动运算符**：运算数的各二进制位全部左移若干位，由` <<` 右边的数字指定了移动的位数，高位丢弃，低位补0 |
|   >>   | **右移动运算符**：把`>>`左边的运算数的各二进制位全部右移若干位，`>>` 右边的数字指定了移动的位数 |

在Python的按位运算符中，**只有反转`~`运算符是单目运算**，其余都是双目运算。

### 按位与 &

按位与的规则是：**参与运算的两个值，如果相应位都为1，则该位的结果为1，否则为0**，也就是说：

- `1 & 1 = 1`
- `1 & 0 = 0`
- `0 & 1 = 0`
- `0 & 0 = 0`

我们首先来看一个示例：

```python
>>> 3 & 5
1
```

分析，我们首先来看它们各自的补码，我们接下来的演示只用一个字节8位表示就行，32位太长了（搞起来难受）：

```
0000 0011  # 3的补码
0000 0101  # 5的补码
0000 0001  # 根据按位与的规则，得出补码结果
```

得出的结果是补码类型的， 我们要先把补码转换为原码，再将二进制转换为十进制的结果。正数的补码等于原码，所以结果就是`1`。

再来个示例：

```python
>>> -2 & -3
-4
```

老套路，先找各自的补码，再求结果：

```
1111 1110	# -2的补码
1111 1101	# -3的补码
1111 1100	# 结果
```

我们将补码转换为原码，默念口诀：补码转原码，符号位不变，数值为按位取反，末位加1：

```
1111 1100	# 补码
1000 0011	# 符号位不变，数值位按位取反
1000 0100	# 末位加1
```

想着最高位的符号位为负，二进制`100`对应的十进制是`4`，最终结果就是`-4`。
再来个例子：

```python
>>> -2 & 3
2
```

老套路，拿到它们各自的补码，再求结果：

```
1111 1110	 # -2的补码
0000 0011	 # 3的补码
0000 0010	 # 结果
```

找到对应的十进制是`2`。

小结：**在按位与的结果中，只有是负数的情况下，才需要将补码转换为原码，然后再求对应的十进制数。**

### 按位或 |

先把口诀放这里：**按位或运算，只要对应两个二进制位有一个为1时，结果就为1**。也就是说：

- `1 | 1 = 1`
- `1 | 0 = 1`
- `0 | 1 = 1`
- `0 | 0 = 0`

再把例子拿过来：

```python
>>> 3 | 5
7
```

拿到补码：

```
0000 0011 	# 3的补码
0000 0101	# 5的补码
0000 0111	# 结果
```

二进制的`111`转为十进制是`7`。

再来个例子：

```python
>>> -2 | -3
-1
```

各自的补码是：

```
1111 1110	 # -2的补码
1111 1101	 # -3的补码
1111 1111	 # 结果
```

拿到了结果，我们还需要将补码转换为原码再转10进制：

```
1111 1111	# 结果
1000 0000	# 高位不变，其余取反
1000 0001	# 末位加1
```

最高位的是负号，最终的结果是`-1`。
再来个例子：

```python
>>> -2 | 3
-1
```

老套路，拿到它们各自的补码，再求结果：

```
1111 1110	# -2的补码
0000 0011	# 3的补码
1111 1111	# 结果
```

继续补码转原码再转十进制：

```
1111 1111	# 结果
1000 0000	# 高位不变，其余取反
1000 0001	# 末位加1
```

最高位为负号，找到对应的十进制是`-1`。

### 按位异或 ^

先把规则列出来：**按位异或运算符，当两个对应的二进位相异时，结果为1**，也就是说：

- `1 ^ 1 = 0`
- `1 ^ 0 = 1`
- `0 ^ 1 = 1`
- `0 ^ 0 = 0`

再把例子拿过来：

```python
>>> 3 ^ 5
6
```

拿到补码：

```
0000 0011 	# 3的补码
0000 0101	# 5的补码
0000 0110	# 结果，注意按照规则来
```

正整数的结果一目了然，二进制的`110`转为十进制是`6`。

再来个例子：

```python
>>> -2 ^ -3
3
```

各自的补码是：

```
1111 1110	# -2的补码
1111 1101	# -3的补码
0000 0011	# 结果
```

首先来看`011`对应的十进制是`3`，所以最终结果是`3`。

再来个例子：

```python
>>> -2 ^ 3
-3
```

老套路，拿到它们各自的补码，再求结果：

```
1111 1110	# -2的补码
0000 0011	# 3的补码
1111 1101	# 结果
```

结果是负数，只能将补码转原码再转10进制了：

```
1111 1101	# 结果
1000 0010	# 高位不变，其余取反
1000 0101	# 末位加1
```

最高位为负号，二进制的`101`是`3`， 所以对应的十进制是`-3`。

最后，来总结一下异或特点，**0异或任何数得这个数（0异或0得0），一个数与自己异或时结果为0**：

```
>>> 0 ^ 0
0
>>> 0 ^ 3
3
>>> 0 ^ -3
-3
>>> 3 ^ 3
0
```

### 按位取反 ~

首先来说，按位取反是单目运算。

规则列出来：**按位取反运算符，对数据的每个二进制位取反，即把1变为0，把0变为1**。

来个例子：

```python
>>> ~ 3
-4
```

拿到`-3`的补码：

```
0000 0011 	# 3的补码
```

按每个二进制位取反：

```
1111 1100	# 结果是负数，还要转为原码
1000 0011	# 高位不变，其余取反
1000 0100	# 末位加一
```

别忘了最高位的负号，二进制的`100`转为十进制是`-4`。

再来个例子：

```python
>>> ~ -2
1
```

`-2`的补码是：

```
1111 1110	 # -2的补码
```

按位取反：

```
0000 0001
```

得到的结果一目了然，是`1`。

### 按位左移 <<

先把规则列出来：**左移动运算符，运算数的各二进制位全部左移若干位，而 `<<` 右边的数字指定了移动的位数，高位丢弃，低位补0**
来个示例：

```python
>>> 2 << 3
16
```

先拿到2的补码：

```
0000 0010	# 2的补码
```

整体（这里也就是1）开始往左移动，移动的位数是3位，所以得的移动结果：

```
0001 0000
```

最终的十进制结果是`16`。

### 按位右移 >>

先把规则列出来：**右移动运算符，把`>>`左边的运算数的各二进制位全部右移若干位，`>>` 右边的数字指定了移动的位数**
来个示例：

```python
>>> 2 >> 3
0
```

先拿到2的补码：

```
0000 0010	# 2的补码
```

从1（从右往左数，第二位）开始往右移动，移动的位数是3位，所以得的移动结果：

```
0000 0000  
```

移动到第3位时，把1就移没了，剩下全是0最终的十进制结果是`0`

## 常见位运算问题

[地址](https://www.zhihu.com/question/38206659)

### 1. 位操作实现乘除法

- 数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2

```
int a = 2;
a >> 1; ---> 1
a << 1; ---> 4
```

### 2. 位操作交换两数

- 位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高

```text
//普通操作
void swap(int &a, int &b) {
  a = a + b;
  b = a - b;
  a = a - b;
}

//位与操作
void swap(int &a, int &b) {
  a ^= b;
  b ^= a;
  a ^= b;
}
```

位与操作解释：第一步：a ^= b ---> a = (a^b); 

第二步：b ^= a ---> b = b^ (a ^b) ---> b = (b^ b)^a = a

第三步：a ^= b ---> a = (a^ b)^a = (a^ a)^b = b

### 3. 位操作判断奇偶数

- 只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。

```
if(0 == (a & 1)) {
 //偶数
}
```

### 4. 位操作交换符号

- 交换符号将正数变成负数，负数变成正数

```
int reversal(int a) {
  return ~a + 1;
}
```

整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数

### 5. 位操作求绝对值

- 整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作

```
int abs(int a) {
  int i = a >> 31;
  return i == 0 ? a : (~a + 1);
}
```

上面的操作可以进行优化，可以将 i == 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)

```
int abs2(int a) {
  int i = a >> 31;
  return ((a^i) - i);
}
```

### 6. 位操作进行高低位交换

- 给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值，如：

```
34520的二进制表示：
10000110 11011000

将其高8位与低8位进行交换，得到一个新的二进制数：
11011000 10000110
其十进制为55430
```

从上面移位操作我们可以知道，只要将无符号数 a>>8 即可得到其高 8 位移到低 8 位，高位补 0；将 a<<8 即可将 低 8 位移到高 8 位，低 8 位补 0，然后将 a>>8 和 a<<8 进行或操作既可求得交换后的结果。

```
unsigned short a = 34520;
a = (a >> 8) | (a << 8);
```

### 7. 位操作进行二进制逆序

将无符号数的二进制表示进行逆序，求取逆序后的结果，如

```
数34520的二进制表示：
10000110 11011000

逆序后则为：
00011011 01100001
它的十进制为7009
```

在字符串逆序过程中，可以从字符串的首尾开始，依次交换两端的数据。在二进制中使用位的高低位交换会更方便进行处理，这里我们分组进行多步处理。

- 第一步:以每 2 位为一组，组内进行高低位交换

```text
交换前： 10 00 01 10 11 01 10 00
交换后： 01 00 10 01 11 10 01 00
```

- 第二步：在上面的基础上，以每 4 位为 1 组，组内高低位进行交换

```text
交换前： 0100 1001 1110 0100
交换后： 0001 0110 1011 0001
```

- 第三步：以每 8 位为一组，组内高低位进行交换

```text
交换前： 00010110 10110001
交换后： 01100001 00011011
```

- 第四步：以每16位为一组，组内高低位进行交换

```text
交换前： 0110000100011011
交换后： 0001101101100001
```

对于上面的第一步，依次以 2 位作为一组，再进行组内高低位交换，这样处理起来比较繁琐，下面介绍另外一种方法进行处理。先分别取原数 10000110 11011000 的奇数位和偶数位，将空余位用 0 填充：

```text
原数：  10000110 11011000
奇数位： 10000010 10001000
偶数位： 00000100 01010000
```

再将奇数位右移一位，偶数位左移一位，此时将两个数据相或即可以达到奇偶位上数据交换的效果：

```text
原数：  10000110 11011000
奇数位右移一位： 0 10000010 1000100
偶数位左移一位：0000100 01010000 0
两数相或得到： 01001001 11100100
```

上面的方法用位操作可以表示为：

- 取a的奇数位并用 0 进行填充可以表示为：a & 0xAAAA
- 取a的偶数为并用 0 进行填充可以表示为：a & 0x5555 因此，上面的第一步可以表示为：
  a = ((a & 0xAAAA) >> 1) | ((a & 0x5555) << 1)
  同理，可以得到其第二、三和四步为：
  a = ((a & 0xCCCC) >> 2) | ((a & 0x3333) << 2)
  a = ((a & 0xF0F0) >> 4) | ((a & 0x0F0F) << 4)
  a = ((a & 0xFF00) >> 8) | ((a & 0x00FF) << 8)
  因此整个操作为：

```
unsigned short a = 34520;

a = ((a & 0xAAAA) >> 1) | ((a & 0x5555) << 1);
a = ((a & 0xCCCC) >> 2) | ((a & 0x3333) << 2);
a = ((a & 0xF0F0) >> 4) | ((a & 0x0F0F) << 4);
a = ((a & 0xFF00) >> 8) | ((a & 0x00FF) << 8);
```



### 8. 位操作统计二进制中 1 的个数

统计二进制1的个数可以分别获取每个二进制位数，然后再统计其1的个数，此方法效率比较低。这里介绍另外一种高效的方法，同样以 34520 为例，我们计算其 a &= (a-1)的结果：

- 第一次：计算前：1000 0110 1101 1000 计算后：1000 0110 1101 0000
- 第二次：计算前：1000 0110 1101 0000 计算后：1000 0110 1100 0000
- 第二次：计算前：1000 0110 1100 0000 计算后：1000 0110 1000 0000 我们发现，没计算一次二进制中就少了一个 1，则我们可以通过下面方法去统计：

```text
count = 0  
while(a){  
  a = a & (a - 1);  
  count++;  
}  
```
