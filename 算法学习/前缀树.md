# 前缀树

字典树也叫前缀树、Trie。它本身就是一个树型结构，也就是一颗多叉树，学过树的朋友应该非常容易理解，它的核心操作是插入，查找。删除很少使用，因此这个讲义不包含删除操作。

 前缀树就是一个树。前缀树一般是将一系列的单词记录到树上， 如果这些单词没有公共前缀，则和直接用数组存没有任何区别。而如果有公共前缀， 则公共前缀仅会被存储一次。可以想象，如果一系列单词的公共前缀很多， 则会有效减少空间消耗。

## 基本概念

一个前缀树大概是这个样子：

[![img](https://camo.githubusercontent.com/5b86cef77f920d7943a350d4c623421262651de95afc9c5c4bbb9409aea6d1cc/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303753385a496c6c793167686c756738377679666a33306d7a3067713430362e6a7067)](https://camo.githubusercontent.com/5b86cef77f920d7943a350d4c623421262651de95afc9c5c4bbb9409aea6d1cc/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303753385a496c6c793167686c756738377679666a33306d7a3067713430362e6a7067)

如图每一个节点存储一个字符，然后外加一个控制信息表示是否是单词结尾，实际使用过程可能会有细微差别，不过变化不大。

接下来，我们看下 Trie 里面的概念。

### 节点：

- 根结点无实际意义
- 每一个节点代表一个字符
- 每个节点中的数据结构可以自定义，如 isWord(是否是单词)，count(该前缀出现的次数)等，需实际问题实际分析需要什么。

### Trie 的插入

- 假定给出几个单词如[she,he,her,good,god]构造出一个 Trie 如下图：

![Untitled](https://raw.githubusercontent.com/jiutiananshu/Picture/master/img/Trie_insert.png)

- 也就是说从根结点出发到某一粉色节点所经过的字符组成的单词，在单词列表中出现过，当然我们也可以给树的每个节点加个 count 属性，代表根结点到该节点所构成的字符串前缀出现的次数

![Untitled 1](https://raw.githubusercontent.com/jiutiananshu/Picture/master/img/Trie_count.png)

可以看出树的构造非常简单，插入新单词的时候就从根结点出发一个字符一个字符插入，有对应的字符节点就更新对应的属性，没有就创建一个！

### Trie 的查询

查询更简单了，给定一个 Trie 和一个单词，和插入的过程类似，一个字符一个字符找

- 若中途有个字符没有对应节点 →Trie 不含该单词
- 若字符串遍历完了，都有对应节点，但最后一个字符对应的节点并不是粉色的，也就不是一个单词 →Trie 不含该单词

## 代码：

[地址](https://github.com/leetcode-pp/91alg-2/blob/master/lecture/advanced-trie.md)

```
class TrieNode:
    def __init__(self):
        self.count = 0
        self.preCount = 0
        self.children = {}

class Trie:

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for ch in word:
            if ch not in node.children:
                node.children[ch] = TrieNode()
            node = node.children[ch]
            node.preCount += 1
        node.count += 1

    def search(self, word):
        node = self.root
        for ch in word:
            if ch not in node.children:
                return False
            node = node.children[ch]
        return node.count > 0

    def startsWith(self, prefix):
        node = self.root
        for ch in prefix:
            if ch not in node.children:
                return False
            node = node.children[ch]
        return node.preCount > 0

```

