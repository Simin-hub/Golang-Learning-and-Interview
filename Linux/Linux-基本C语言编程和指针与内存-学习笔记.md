# Linux-基本C语言编程和指针与内存-学习笔记

标签： 学习笔记 C语言 Linux编程

---

## C语言

    概念、特点、用处
    特点：简单、快速、高性能、兼容性好、功能强大、易于学习
    最适合做：Linux嵌入式--命令小工具
              和硬件相关的程序
              高性能程序
## Linux命令

环境：ubutun系统-18.04 lts

常用命令：

​    

```
软件安装命令:
    apt-get下载的软件目录：/var/cache/apt/archives
    安装后软件的默认存放位置：/var/cache/apt/archives
    可执行文件位置：/usr/bin
    配置文件位置：/etc
    lib文件位置：/usr/lib
    sudo apt-get update  更新软件列表，在文件/etc/apt/sources.list 列出
    sudo apt-get upgrade 更新软件
    sudo apt-get install gcc 安装gcc
    sudo apt-get install -f 修复安装依赖问题
    sudo apt-get autoremove 清除不必要的依赖
    sudo apt-get remove 卸载软件
    sudo dpkg -i *.deb 安装deb软件
    dpkg -l 查看所有安装的软件
    dpkg -l | grep softwae-name 配合grep命令查看具体的某一软件是否安装
    目录文件操作：
    cd 切换目录
    pwd 查看当前所在目录
    ls  查看当前目录下的文件夹和文件名 -a 显示所有文件， -l显示文件的详细信息
    mdkir test/ 新建test目录
    rmdir test/ 删除test目录，test目录必须为空
    rm main.c 删除main.c文件
    cp mian.c main2.c 复制main.c文件为main2.c文件
    mv main.c main2.c 移动main.c文件或更改main.c文件名为main2.c
    touch main.c 创建字符型文件main.c
    vim main.c 打开main.c文件。并进去vim编辑器
```




## vim命令

1.vim的集中模式：

​		命令行模式、插入模式、末行模式、可视模式、替换模式

2.启动vim

```
		vim -c cmd file 在打开文件前。先执行指定的命令
		vim + file 从文件的莫为开始
		vim +num file 从文件的第num行开始
```

3.命令行模式

    进入插入模式：
    	i 从光标开始位置开始插入
    	a 从光标开始的后一位开始输插入
    	I 从光标所在行的行首开始插入
    	A 从光标所在行的末尾开始插入
    	o 在下面插入一行
    	O 在上面插入一行
    	s 删除光标后的一个字符，进入插入模式
    	S 删除光标所在行，进入插入模式
    
    移动光标：
    	h或向左方向键（←）    光标向左移动一个字符
    	j或向下方向键（↓）    光标向下移动一个字符	
    	k或向上方向键（↑）     光标向上移动一个字符
    	l或向右方向键（→）     光标向右移动一个字符
    	[Ctrl]+[f] 屏幕“向下”移动一页，相当于[Page Down]按键
    	[Ctrl]+[b] 屏幕“向上”移动一页，相当于[Page Up]按键
    	[Ctrl]+[d] 屏幕“向下”移动半页
    	[Ctrl]+[u] 屏幕“向上”移动半页
    	n n表示“数字”，例如20.按下数字后再按空格键，光标会向右移动这一行n个字符。例如20则光标会向后面移动20个字符距离
    	G 移动到这个文件的最后一行（常用）
    	nG n为数字。移动到这个文件的第n行。例如20G则会移动到这个文件的第20行（可配合：set nu）
    	gg 移动到这个文件的第一行，相当于1G（常用）
    
    删除文字：
    	x 删除光标所在位置的后面的一个字符
    	nx 删除光标所在位置后的n个字符
    	X 删除光标前的一个字符
    	dd  删除光标所在行
    	ndd 删除从光标开始的n行
    
    复制：
    	yy 复制光标所在行到缓冲区
    	nyy 复制从光标所在位置开始的n行到缓冲区	
    	p 将缓冲区的内容写入到光标所在位置
    
    替换：
    	r 替换光标所在位置的字符
    	R 替换光标所到位置的字符，直到按ESC

4.末行模式：
    
    基本操作
    	:set nu 列出行号
    	:set nonu 取消列出行号
    	:n 跳到文件中的第n行
    	:!cmd 运行shell命令
    	:/关键字 查找关键字，n是下一个，N是上一个
    	:?关键字 查找关键字，？是下一个
    
    文件操作：
    	:e file 关闭当前编辑的文件，并开启新的文件。
    	:e! file 放弃对当前文件的修改，打开新文件
    	:e - 重新加载当前文档
    	:e! - 重新加载当前文档，放弃已做修改
    	:wq 保存并退出
    	:x 保存并退出
    
    分屏操作：
    	:sp 把当前窗口水平分割为两个窗口
    	:sp file1 file2 水平分割三个窗口，打开另外两个文件
    	:nsplit n为数字 ,分割为n个水平窗口
    	:vsp 垂直分割成两个窗口
    	其他操作同sp相同

## gcc

    gcc 与 g++ 分别是 gnu 的 c & c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：
    	1、预处理
    	2、将预处理后的文件转换成汇编语言
    	3、有汇编变为目标代码(机器代码)生成
    	4、连接目标代码, 生成可执行程序 
    	
    GCC最基本的用法是∶gcc [options] [filenames]
    	-c，只编译，不链接成为可执行文件，
    	-o filename，确定输出文件的名称为filename，
    	-g，产生符号调试工具（GNU的gdb）所必要的符号资讯，要想对源代码进行调试，我们就必须加入这个选项。
    	-O，对程序进行优化编译、链接
    	-O2，比-O更好的优化编译、链接，
    例子：
    gcc main.c
    gcc main.c -o main.out
    gcc -c max.c -o max.o
    gcc max.o main.c -o main.out

## 头文件与函数定义分离

    #include <stdio.h>
    #inlude "max.h"
    <>里面的是系统自带的库文件，max.h则是我们定义的文件。
    max.h文件包含对max.c文件的函数声明。
    多人协作的重点、解决文件过多的问题。
## make和makefile

​		make及其描述文件makefile.Makefile文件Make工具最主要也是最基本的功能就是通过makefile文件来描述源程序之间的相互关系并自动维护编译工作。而makefile文件需要按照某种语法进行编写，文件中需要说明如何编译各个源文件并连接生成可执行文件，并要求定义源文件之间的依赖关系。

​		首先源文件-> .o文件，再由.o文件->可执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的.o文件中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error）　
​		目标文件：命令 依赖文件 

​		依赖文件：命令 更低层次的依赖文件

​		依次类推

​		输入make执行makefile文件

## main函数的参数及返回值

​		main函数的作用：main()函数是c程序的入口，编译器在编译的时候把程序开始执行的地址设为main函数的地址，所有函数都从main函数开始执行。

```
    int main（int argc,char* argv[]）{
    	代码块
        return 0；
    }
    argc:表示输入的参数的数量
    argv:表示输入的参数的字符指针数组
    
    例如  ./main3.out -l -a
    则argc:3  argv[0]=ls argv[1]=-l argv[2]=-a
    
	返回值则是判断程序是否成功执行，规定0表示成功执行，其他表示为执行失败。
```



## 标准输入输出流和错误流
​    Linux系统将所有设备都当做文件处理
​        标准输入流文件：stdin 键盘
​        标准输出流文件：stdout 显示器
​        标准错误流文件：stderr
​        fprintf stdout 往屏幕写，stdout可以换成别的文件（如打印机）；
​        fscanf stdin 从键盘接受，stdin可以换成别的输入设备（如摄像头）；
​        fprintf stderr 往错误报告写，当程序运行失败时（return=1）时会向屏幕输出错误报告；
​        

### 标准输入输出流和错误流重定向

    重定向输出流
    ./a.out 1>>a.txt 2>>err.txt 双箭头>>不会覆盖文件内容，重定向的内容会在后面追加 单箭头>则会覆盖原来内容，只显示最新内容
    
    重定向输入流
    ./a.out <input.txt
    
    重定向错误流


​    

## 管道

​		管道的思想是，在内存中创建一个共享文件，从而使通信双方利用这个共享文件来传递信息。由于这种方式具有单向传递数据的特点，所以这个作为传递消息的共享文件就叫做“管道”。

​		由父进程创建的子进程将会赋值父进程包括文件在内的一些资源。如果父进程创建子进程之前创建了一个文件，那么这个文件的描述符就会被父进程在随后所创建的子进程所共享。也就是说，父、子进程可以通过这个文件进行通信。如果通信的双方一方只能进行读操作，而另一方只能进行写操作，那么这个文件就是一个只能单方向传送消息的管道。

​		在命令行的情况下主要体现为第一个命令的结果成为第二个命令的输入。且在命令行的情况下，只有前面的命令执行成功，后面的命令才会执行。

​			只有前面的命令执行成功，返回0时，后面的命令才会执行。
 <img src="F:\Markdown\workspace\Linux学习笔记\管道实例.png" style="zoom:80%;" />

​		

```
  具体含义：ls -a 该目录下的所有文件，grep m 则是查找包含m的文件
  ls -a | grep m 查看该目录下的所有文件，将查找的结果给grep过滤，显示包含m的文件
```



## 指针

​		指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。指针的值实质是内存单元（即字节）的编号，所以指针单独从数值上看，也是整数，他们一般用16进制表示。指针的值（虚拟地址值）使用一个机器字的大小来存储,也就是说,对于一个机器字为w位的电脑而言,它的虚拟地址空间是0~2^w － 1 ,程序最多能访问2^w个字节

​			指针存储的内容是地址，而这个地址是真正存储数据的地方。

指针的声明方式：

```
int* 变量名   整型指针 
float* 变量名   浮点型指针 
char* 变量名    字符型指针
object* 变量名  类指针
```



## gdb调试工具

GDB主要完成下面四个方面的功能： 
	(1)启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。 
	(2)可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式） 
	(3)当程序被停住时，可以检查此时你的程序中所发生的事。 
	(4)动态的改变你程序的执行环境。 

```
安装gdb：sudo apt-get install gdb
gdb的使用
    gcc -g main.c -o main.out生成可调试版本
    gdb ./main.out
    gdb调试的命令
    gdb -tui 这样,使用了'-tui'选项，启动可以直接将屏幕分成两个部分，上面显示源代码，比用list方便多了。这时候使用上下方向键可以查看源代码,想要命令行使用上下键就用[Ctrl]n和[Ctrl]p. 
    启动gdb gdb ./main.o
    或者gdb PID 在程序启动后使用进程ID
    
gdb命令：
    help 帮助信息
    l/list 查看程序代码
    break n 设置第n行为断点
    start开始调试
    n/next 执行下一步
    回车执行上一次的命令
    s/step 单步进入（进入函数中）
    finish/f n 返回编号函数
    bt 查看函数堆栈
    print/p 变量/函数名 打印变量或函数的值
    print/p *变量/函数名 打印变量或函数的地址
    p a 打印变量a的值
    p a 若a为指针，则打印的是a指向的地址
    p *a 若a为指针，则打印的是a指向的地址所存储的值
    p 函数名  打印函数的存储地址
    p &a 若a为变量，则打印的a的地址
    如果a是一个数组，10个元素，如果要显示则： print *a@10 
    q 退出
    u/until 指定程序直到退出当前循环体
    delete n 删除n号断点
    delete 删除所有断点
    kill 终止正在调试的程序
```



## 数据的表示方式

    计算机是使用二进制
    呈现给用户为十进制
    显示内存地址事，由于减少存储空间使用十六进制

## C语言的数据和函数在内存中的表现

### 内存空间的分配

 		内存地址用4位16进制和8位16进制表示的区别。内存地址只是一个编号，代表一个内存空间。32位的操作系统最多支持4GB的内存空间，也就是说CPU只能寻址2的32次方（4GB），注意这里的4GB是以Byte为单位的，不是bit。也就是说有4G=4*1024M（Byte）=4*1024*1024Kb(Byte)=4*1024*1024*1024bit(Byte)，1Byte = 8bit，即2的32次方个8bit单位。
		所以说用4位16进制表示的内存地址和用8位16进制表示的内存地址，其实都是代表一个8bit的存储空间而已。
		操作系统给内存编号、给内存做规划：
		用户能使用的内存只有前48位，之后为操作系统的内存---用户内存隔离
		内存空间从上到下分布：
   		系统内核：预留给系统的内存
   		栈：栈又称堆栈， 存放程序的 局部变量 （但不包括static声明的变量， static 意味着 在数据段中 存放变量）。除此以外，在函数被调用时，栈用来传递参数和返回值。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。
   		自由空间：用户可自由分配
   		堆：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc/free等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）/释放的内存从堆中被剔除（堆被缩减）。
   		数据段：通常是指用来存放程序中已初始化的全局变量的一块内存区域。
   		代码段：通常是指用来存放 程序执行代码 的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读。 

### 内存中数据和函数

​		全局变量主要存储在数据段。每个函数里面的局部变量则存储在栈里面，并且地址都是连续的，经过编译器的优化，相同类型的局部变量一起声明，其余按照声明顺序分配地址。

![](F:\Markdown\workspace\Linux学习笔记\数据内存.png)

​		函数在内存的先调用加载在栈内更高的地址，后加载的在更低的位置。栈体现先进后出。其他内存空间都是从低位开始存储。

## 数组

​	数组声明：

```
int array[n] n必须为数字。或者宏定义
```

​	数组的存储方式是连续存放。

​	当指针指向函数内的局部变量时，指针增加相当于指向了下一个地址

```
	int a = 3;
	int b = 2;
	int array[2];
	array[0] = 1;
	array[1] = 10;
	array[2] =100;
	int *p = &a;
	当p++时，p所指向下一个地址
	p++;
	这是p指向了b的地址
	p++;
	这次指向了array[0]的地址
	p+=2;
	p向下移两个地址
```

数组与指针:

​	数组名其实也是一个指针常量

```
	int *pa= array;//pa的运算相当于下标的运算
```

​		字符指针类型和整型指针类型

## 总结

​		虽然这是个四个小时的学习视频，但是花费的时间却是这几倍。在这几天中反复观看视频，每次观看都会有一些新的收获，每一次自己动手操作都会有一些新的感触。老师也不断地提醒我们需要深入理解视频里的知识。

​		在观看视频和自己搜集资料的时候不仅收获了知识，也还在不断慢慢改变我的学习方法和学习态度，以前看视频和学习是看到什么学什么，不会自己主动学习，不会去了解更加底层的知识。通过这次学习也认识到底层知识的重大意义，为以后的深入学习和学习其他编程语言打下了基础。

​		在Linux命令和vim命令这一块，我搜集了很多的文章，自己也去做了实验。这些命令是需要经常使用才会熟记于心，所以在考核的时候出错了。在搜集的过程中，还是主要以看为主，这一点还需要慢慢改正过来。在第二个视频中，讲到指针和内存的时候，第一次观看并没有自己动手去做，走马观花看完了，都没有什么映象。后来再次看视频的时候，自己动手去做了，就真正明白了指针和内存，数据之间的关系，不在是记住了而是理解了。视频里面的知识虽然看了很多次，但是自己没有认真去做，还是没有做到真正的理解，只是简单地停留在表面。

​		在写学习笔记的时候也遇到了较大的问题。对视频里面的内容以为自己已经懂了，结果在写笔记的时候感觉自己知道这是个什么东西，知道但是不会用语言表达，这还是没有全部弄懂的表现，所以写的内容粗糙。由于这是第一次写学习笔记，所以在内容和布局上也显得极为不合理。并且有些的内容还是参考了网上的文章，通过自己的语言写出来的内容很少也很浅显，表达能力和书写能力有待提高。

​		学习不仅仅是吸收别人的知识，也是需要自己动手去练习，多实践才能被自己转化吸收。在这次视频学习，我看到我学习方面的许多缺陷，但也收获了很多，不仅仅是知识的运用，还了解了现在的工作模式，也明白了学习编程需要夯实的基础。我也还需要多次观看视频，特别是指针和内存这部分知识，多练习多查资料，同时加强自己在理论和实践的能力。

