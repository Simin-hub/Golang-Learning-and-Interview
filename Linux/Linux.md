# Linux

### 文件类型

#### 几种常见的文件类型

另一方面，Linux 下的目录也是一种文件；但是文件也不只有目录和可执行文件两种。常见的文件类型有以下 7 种:

1. 普通文件（比如一个文本文件）；
2. 目录文件（目录也是一个特殊的文件，它用来存储文件清单，比如`/`也是一个文件）；
3. 可执行文件；
4. 管道文件；
5. Socket 文件；
6. 软链接文件（相当于指向另一个文件所在路径的符号）；
7. 硬链接文件（相当于指向另一个文件的指针）。

使用`ls -F`就可以看到当前目录下的文件和它的类型。比如下面这种图：

1. \* 结尾的是可执行文件；
2. = 结尾的是 Socket 文件；
3. @ 结尾的是软链接；
4. | 结尾的管道文件；
5. 没有符号结尾的是普通文件；
6. / 结尾的是目录。

![Drawing 2.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/Ciqc1F9rECOAaC4iAAEqYXENnnI551.png)

#### 设备文件

Socket 是网络插座，是客户端和服务器之间同步数据的接口。其实，Linux 不只把 Socket 抽象成了文件，设备基本也都被抽象成了文件。因为设备需要不断和操作系统交换数据。而交换方式只有两种——读和写。所以设备是可以抽象成文件的，因为文件也支持这两种操作。

**Linux 把所有的设备都抽象成了文件**，比如说打印机、USB、显卡等。这让整体的系统设计变得高度统一。

至此，我们了解了 Linux 对文件目录的抽象，接下来我们看看具体的增删改查指令。

#### 管道（Pipeline）

**管道（Pipeline）的作用是在命令和命令之间，传递数据**。比如说一个命令的结果，就可以作为另一个命令的输入。我们了解了进程，所以这里说的命令就是进程。更准确地说，**管道在进程间传递数据**。

##### 输入输出流

**每个进程拥有自己的标准输入流、标准输出流、标准错误流**。

这几个标准流说起来很复杂，但其实都是文件。

- 标准输入流（用 0 表示）可以作为进程执行的上下文（进程执行可以从输入流中获取数据）。
- 标准输出流（用 1 表示）中写入的结果会被打印到屏幕上。
- 如果进程在执行过程中发生异常，那么异常信息会被记录到标准错误流（用 2 表示）中。

**重定向**

我们执行一个指令，比如`ls -l`，**结果会写入标准输出流，进而被打印**。这时可以用重定向符将结果重定向到一个文件，比如说`ls -l > out`，这样`out`文件就会有`ls -l`的结果；而屏幕上也不会再打印`ls -l`的结果。

![Drawing 4.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/Ciqc1F9twOiAWhAGAAU25o5Gb_s323.png)

具体来说**`>`符号叫作覆盖重定向；`>>`叫作追加重定向**。`>`每次都会把目标文件覆盖，`>>`会在目标文件中追加。比如你每次启动一个程序日志都写入`/var/log/somelogfile`中，可以这样操作，如下所示：

```javascript
start.sh >> /var/log/somelogfile
```

经过这样的操作后，每次执行程序日志就不会被覆盖了。

另外还有一种情况，比如我们输入:

```csharp
ls1 > out
```

结果并不会存入`out`文件，因为`ls1`指令是不存在的。结果会输出到标准错误流中，仍然在屏幕上。这里我们可以把标准错误流也重定向到标准输出流，然后再重定向到文件。

```csharp
ls1 &> out
```

这个写法等价于：

```csharp
ls1 > out 2>&1
```

![Drawing 5.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/CgqCHl9twP2AefIFAAL1fMsTbHk961.png)

相当于把`ls1`的标准输出流重定向到`out`，因为`ls1 > out`出错了，所以标准错误流被定向到了标准输出流。**`&`代表一种引用关系**，具体代表的是`ls1 >out`的标准输出流。

##### 管道的作用和分类

有了进程和重定向的知识，接下来我们梳理下管道的作用。管道（Pipeline）将一个进程的输出流定向到另一个进程的输入流，就像水管一样，作用就是把这两个文件接起来。如果一个进程输出了一个字符 X，那么另一个进程就会获得 X 这个输入。

**管道和重定向很像，但是管道是一个连接一个进行计算，重定向是将一个文件的内容定向到另一个文件，这二者经常会结合使用**。

Linux 中的管道也是文件，有两种类型的管道：

1. 匿名管道（Unnamed Pipeline），这种管道也在文件系统中，但是它只是一个存储节点，不属于任何一个目录。说白了，就是没有路径。
2. 命名管道（Named Pipeline），这种管道就是一个文件，有自己的路径。

###### FIFO

管道具有 FIFO（First In First Out），FIFO 和排队场景一样，先排到的先获得。所以先流入管道文件的数据，也会先流出去传递给管道下游的进程。

##### 使用场景分析

接下来我们以多个场景举例帮助你深入学习管道。

###### 排序

比如我们用`ls`，希望按照文件名排序倒序，可以使用匿名管道，将`ls`的结果传递给`sort`指令去排序。你看，这样`ls`的开发者就不用关心排序问题了。

![Drawing 6.png](http://learn.lianglianglee.com/专栏/重学操作系统-完/assets/Ciqc1F9twQmAUpYzAADI43WGK9A660.png)

###### 去重

另一个比较常见的场景是去重，比如有一个字典文件，里面都是词语。如下所示：

```undefined
Apple

Banana

Apple

Banana

……
```

如果我们想要去重可以使用`uniq`指令，`uniq`指令**能够找到文件中相邻的重复行，然后去重**。但是我们上面的文件重复行是交替的，所以不可以直接用`uniq`，因此可以先`sort`这个文件，然后利用管道将`sort`的结果重定向到`uniq`指令。指令如下：

![Drawing 7.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/CgqCHl9twRGAXmhPAACPjv2JnVo451.png)

###### 筛选

有时候我们想根据正则模式筛选对应的内容。比如说我们想找到项目文件下所有文件名中含有`Spring`的文件。就可以利用`grep`指令，操作如下：

```lua
find ./ | grep Spring
```

`find ./`递归列出当前目录下所有目录中的文件。`grep`从`find`的输出流中找出含有`Spring`关键字的行。

如果我们希望包含`Spring`但不包含`MyBatis`就可以这样操作：

```perl
find ./ | grep Spring | grep -v MyBatis
```

`grep -v`是匹配不包含 MyBatis 的结果。

###### 数行数

还有一个比较常见的场景是数行数。比如你写了一个 Java 文件想知道里面有多少行，就可以使用`wc -l`指令，如下所示：

![Drawing 8.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/Ciqc1F9twRqAH6ezAAD5iEQBhxE628.png)

但是如果你想知道当前目录下有多少个文件，可以用`ls | wc -l`，如下所示：

![Drawing 9.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/Ciqc1F9twSCAN0h-AABgIcsEgKI655.png)

**接下来请你思考一个问题：我们如何知道当前**`java`**的项目目录下有多少行代码**？

提示一下。你可以使用下面这个指令：

```bash
find -i ".java" ./ | wc -l
```

快去自己动手写一写吧，你在尝试的过程中如果遇到什么问题，也可以写在留言区，我会逐一为你解答。

###### 中间结果

管道一个接着一个，是一个计算逻辑。有时候我们想要把中间的结果保存下来，这就需要用到`tee`指令。`tee`指令从标准输入流中读取数据到标准输出流。

这时候，你可能会问： 老师， 这不是什么都没做吗？

别急，`tee`还有一个能力，就是自己**利用这个过程把输入流中读取到的数据存到文件中**。比如下面这条指令：

```bash
find ./ -i "*.java" | tee JavaList | grep Spring
```

这句指令的意思是从当前目录中找到所有含有 Spring 关键字的 Java 文件。tee 本身不影响指令的执行，但是 tee 会把 find 指令的结果保存到 JavaList 文件中。

`tee`这个执行就像英文字母中的 T 一样，连通管道两端，下面又开了口。这个开口，在函数式编程里面叫作副作用。

###### xargs

上面我们学习的内容难度，已经由小学 1 年级攀升到了小学 6 年级，最后我们来看看初中难度的`xargs`指令。

`xargs`指令从标准数据流中构造并执行一行行的指令。`xargs`从输入流获取字符串，然后利用空白、换行符等切割字符串，在这些字符串的基础上构造指令，最后一行行执行这些指令。

举个例子，如果我们重命名当前目录下的所有 .a 的文件，想在这些文件前面加一个前缀`prefix_`。比如说`x.a`文件需要重命名成`prefix_x.a`，我们就可以用`xargs`指令构造模块化的指令。

现在我们有`x.a``y.a``z.a`三个文件，如下图所示：

![Drawing 10.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/CgqCHl9twTWALpuzAABnixlvrS8980.png)

然后使用下图中的指令构造我们需要的指令：

![Drawing 11.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/CgqCHl9twT-AOUALAAE5FDR8Tiw234.png)

- 我们用`ls`找到所有的文件；
- `-I`参数是查找替换符，这里我们用`GG`替代`ls`找到的结果；`-I GG`后面的字符串 GG 会被替换为`x.a``x.b`或`x.z`；
- `echo`是一个在命令行打印字符串的指令。使用`echo`主要是为了安全，帮助我们检查指令是否有错误。

我们用`xargs`构造了 3 条指令。这里我再多讲一个词，叫作样板代码。如果你没有用`xargs`指令，而是用一条条`mv`指令去敲，这样就构成了样板代码。

最后去掉 echo，就是我们想要的结果，如下所示：

![Drawing 12.png](http://learn.lianglianglee.com/专栏/重学操作系统-完/assets/Ciqc1F9twUiAOcNlAAEsaaMV4DI747.png)

##### 管道文件

上面我们花了较长的一段时间讨论匿名管道，用`|`就可以创造和使用。匿名管道也是利用了文件系统的能力，是一种文件结构。当你学到模块六文件系统的内容，会知道匿名管道拥有一个自己的`inode`，但不属于任何一个文件夹。

还有一种管道叫作命名管道（Named Pipeline）。**命名管道是要挂到文件夹中的，因此需要创建**。用`mkfifo`指令可以创建一个命名管道，下面我们来创建一个叫作`pipe1`的命名管道，如下图所示：

![Drawing 13.png](http://learn.lianglianglee.com/专栏/重学操作系统-完/assets/CgqCHl9twU-ASY8bAAC7_lc6Pr8814.png)

命名管道和匿名管道能力类似，可以连接一个输出流到另一个输入流，也是 First In First Out。

当执行`cat pipe1`的时候，你可以观察到，当前的终端处于等待状态。因为我们`cat pipe1`的时候`pipe1`中没有内容。

如果这个时候我们再找一个终端去写一点东西到`pipe`中，比如说:

```bash
echo "XXX" > pipe1
```

这个时候，`cat pipe1`就会返回，并打印出`xxx`，如下所示：

![Drawing 14.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/CgqCHl9twViAT-M2AADtPsSTV5c658.png)

我们可以像上图那样演示这段程序，在`cat pipe1`后面增加了一个`&`符号。这个`&`符号代表指令在后台执行，不会阻塞用户继续输入。然后我们通过`echo`指令往`pipe1`中写入东西，接着就会看到`xxx`被打印出来。

### 用户和权限管理

#### 权限抽象

一个完整的权限管理体系，要有合理的抽象。这里就包括对用户、进程、文件、内存、系统调用等抽象。下面我将带你一一了解。

**首先，我们先来说说用户和组**。Linux 是一个多用户平台，允许多个用户同时登录系统工作。Linux 将用户抽象成了账户，账户可以登录系统，比如通过输入登录名 + 密码的方式登录；也可以通过证书的方式登录。

但为了方便分配每个用户的权限，Linux 还支持组 **（Group）账户**。组账户是多个账户的集合，组可以为成员们分配某一类权限。每个用户可以在多个组，这样就可以利用组给用户快速分配权限。

组的概念有点像微信群。一个用户可以在多个群中。比如某个组中分配了 10 个目录的权限，那么新建用户的时候可以将这个用户增加到这个组中，这样新增的用户就不必再去一个个目录分配权限。

而每一个微信群都有一个群主，**Root 账户也叫作超级管理员**，就相当于微信群主，它对系统有着完全的掌控。一个超级管理员可以使用系统提供的全部能力。

此外，Linux 还对**文件**进行了权限抽象（**注意目录也是一种文件**）。Linux 中一个文件可以设置下面 3 种权限：

1. 读权限（r）：控制读取文件。
2. 写权限（w）：控制写入文件。
3. 执行权限（x）：控制将文件执行，比如脚本、应用程序等。

![1.png](http://learn.lianglianglee.com/专栏/重学操作系统-完/assets/Ciqc1F91G6qACantAAC4GIUeips460.png)

然后每个文件又可以从 3 个维度去配置上述的 3 种权限：

1. 用户维度。每个文件可以所属 1 个用户，用户维度配置的 rwx 在用户维度生效；
2. 组维度。每个文件可以所属 1 个分组，组维度配置的 rwx 在组维度生效；
3. 全部用户维度。设置对所有用户的权限。

![2.png](http://learn.lianglianglee.com/专栏/重学操作系统-完/assets/CgqCHl91G9aADTBZAADD7IOpjac809.png)

因此 Linux 中文件的权限可以用 9 个字符，3 组`rwx`描述：**第一组是用户权限，第二组是组权限，第三组是所有用户的权限**。然后用`-`代表没有权限。比如`rwxrwxrwx`代表所有维度可以读写执行。`rw--wxr-x`代表用户维度不可以执行，组维度不可以读取，所有用户维度不可以写入。

通常情况下，如果用`ls -l`查看一个文件的权限，会有 10 个字符，这是因为第一个字符代表的是文件类型。我们在 06 课时讲解“几种常见的文件类型”时提到过，有管道文件、目录文件、链接文件等等。`-`代表普通文件、`d`代表目录、`p`代表管道。

**学习了这套机制之后，请你跟着我的节奏一起思考以下 4 个问题**。

1. 文件被创建后，初始的权限如何设置？
2. 需要全部用户都可以执行的指令，比如`ls`，它们的权限如何分配？
3. 给一个文本文件分配了可执行权限会怎么样？
4. 可不可以多个用户都登录`root`，然后只用`root`账户？

你可以把以上 4 个问题作为本课时的小测验，把你的思考或者答案写在留言区，然后再来看我接下来的分析。

**问题一：初始权限问题**

一个文件创建后，文件的所属用户会被设置成创建文件的用户。谁创建谁拥有，这个逻辑很顺理成章。但是文件的组又是如何分配的呢？

这里 Linux 想到了一个很好的办法，就是**为每个用户创建一个同名分组**。

比如说`zhang`这个账户创建时，会创建一个叫作`zhang`的分组。`zhang`登录之后，工作分组就会默认使用它的同名分组`zhang`。如果`zhang`想要切换工作分组，可以使用`newgrp`指令切换到另一个工作分组。因此，被创建文件所属的分组是当时用户所在的工作分组，如果没有特别设置，那么就属于用户所在的同名分组。

再说下文件的权限如何？文件被创建后的权限通常是：

```lua
rw-rw-r--
```

也就是用户、组维度不可以执行，所有用户可读。

**问题二：公共执行文件的权限**

前面提到过可以用`which`指令查看`ls`指令所在的目录，我们发现在`/usr/bin`中。然后用`ls -l`查看`ls`的权限，可以看到下图所示：

![Drawing 2.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/Ciqc1F90SRuAAQCEAADdVOthCFw679.png)

第一个`-`代表这是一个普通文件，后面的 rwx 代表用户维度可读写和执行；第二个`r-x`代表组维度不可以写；第三个`r-x`代表所有用户可以读和执行。后面的两个`root`，第一个是所属用户，第二个是所属分组。

到这里你可能会有一个疑问：如果一个文件设置为不可读，但是可以执行，那么结果会怎样？

答案当然是不可以执行，无法读取文件内容自然不可以执行。

**问题三：执行文件**

在 Linux 中，如~~果~~一个文件可以被执行，则可以直接通过输入文件路径（相对路径或绝对路径）的方式执行。如果想执行一个不可以执行的文件，Linux 则会报错。

当用户输入一个文件名，如果没有指定完整路径，Linux 就会在一部分目录中查找这个文件。你可以通过`echo $PATH`看到 Linux 会在哪些目录中查找可执行文件，`PATH`是 Linux 的环境变量，关于环境变量，我将在 “12 | 高级技巧之集群部署中”和你详细讨论。

![Drawing 3.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/CgqCHl90SSSACa4WAAFIEUypWH4904.png)

**问题四：可不可以都 root**

最后一个问题是，可不可以都`root`？

答案当然是不行！这里先给你留个悬念，具体原因我们会在本课时最后来讨论。

**到这里，用户和组相关权限就介绍完了。接下来说说内核和系统调用权限。** 内核是操作系统连接硬件、提供最核心能力的程序。今天我们先简单了解一下，关于内核的详细知识，会在“14 |用户态和内核态：用户态线程和内核态线程有什么区别？”中介绍。

内核提供操作硬件、磁盘、内存分页、进程等最核心的能力，并拥有直接操作全部内存的权限，因此内核不能把自己的全部能力都提供给用户，而且也不能允许用户通过`shell`指令进行系统调用。Linux 下内核把部分进程需要的系统调用以 C 语言 API 的形式提供出来。部分系统调用会有权限检查，比如说设置系统时间的系统调用。

以上我们看到了 Linux 对系统权限的抽象。接下来我们再说说权限架构的思想。

#### 权限架构思想

优秀的权限架构主要目标是让系统安全、稳定且用户、程序之间相互制约、相互隔离。这要求权限系统中的权限划分足够清晰，分配权限的成本足够低。

因此，优秀的架构，应该**遵循最小权限原则（Least Privilege)**。权限设计需要保证系统的安全和稳定。比如：每一个成员拥有的权限应该足够的小，每一段特权程序执行的过程应该足够的短。对于安全级别较高的时候，还需要成员权限互相牵制。比如金融领域通常登录线上数据库需要两次登录，也就是需要两个密码，分别掌握在两个角色手中。这样即便一个成员出了问题，也可以保证整个系统安全。

同样的，每个程序也应该减少权限，比如说只拥有少量的目录读写权限，只可以进行少量的系统调用。

##### 权限划分

此外，权限架构思想还应遵循一个原则，权限划分边界应该足够清晰，尽量做到相互隔离。Linux 提供了用户和分组。当然 Linux 没有强迫你如何划分权限，这是为了应对更多的场景。通常我们服务器上重要的应用，会由不同的账户执行。比如说 Nginx、Web 服务器、数据库不会执行在一个账户下。现在随着容器化技术的发展，我们甚至希望每个应用独享一个虚拟的空间，就好像运行在一个单独的操作系统中一样，让它们互相不用干扰。

**到这里，你可能会问：为什么不用 root 账户执行程序？** 下面我们就来说说 root 的危害。

举个例子，你有一个 Mysql 进程执行在 root（最大权限）账户上，如果有黑客攻破了你的 Mysql 服务，获得了在 Mysql 上执行 Sql 的权限，那么，你的整个系统就都暴露在黑客眼前了。这会导致非常严重的后果。

黑客可以利用 Mysql 的 Copy From Prgram 指令为所欲为，比如先备份你的关键文件，然后再删除他们，并要挟你通过指定账户打款。如果执行最小权限原则，那么黑客即便攻破我们的 Mysql 服务，他也只能获得最小的权限。当然，黑客拿到 Mysql 权限也是非常可怕的，但是相比拿到所有权限，这个损失就小多了。

##### 分级保护

因为内核可以直接操作内存和 CPU，因此非常危险。驱动程序可以直接控制摄像头、显示屏等核心设备，也需要采取安全措施，比如防止恶意应用开启摄像头盗用隐私。通常操作系统都采取一种环状的保护模式。

![3.png](http://learn.lianglianglee.com/专栏/重学操作系统-完/assets/CgqCHl91HB2AdNsAAAEpE6rtlHM754.png)

如上图所示，内核在最里面，也就是 Ring 0。 应用在最外面也就是Ring 3。驱动在中间，也就是 Ring 1 和 Ring 2。对于相邻的两个 Ring，内层 Ring 会拥有较高的权限，可以改变外层的 Ring；而外层的 Ring 想要使用内层 Ring 的资源时，会有专门的程序（或者硬件）进行保护。

比如说一个 Ring3 的应用需要使用内核，就需要发送一个系统调用给内核。这个系统调用会由内核进行验证，比如验证用户有没有足够的权限，以及这个行为是否安全等等。

##### **权限包围（Privilege Bracking）**

之前我们讨论过，当 Mysql 跑在 root 权限时，如果 Mysql 被攻破，整个机器就被攻破了。因此我们所有应用都不要跑在 root 上。如果所有应用都跑在普通账户下，那么就会有临时提升权限的场景。比如说安装程序可能需要临时拥有管理员权限，将应用装到`/usr/bin`目录下。

Linux 提供了权限包围的能力。比如一个应用，临时需要高级权限，可以利用交互界面（比如让用户输入 root 账户密码）验证身份，然后执行需要高级权限的操作，然后马上恢复到普通权限工作。这样做可以减少应用在高级权限的时间，并做到专权专用，防止被恶意程序利用。

#### 用户分组指令

上面我们讨论了 Linux 权限的架构，接下来我们学习一些具体的指令。

##### 查看

如果想查看当前用户的分组可以使用`groups`指令。

![Drawing 5.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/CgqCHl90SU6AUJrLAADmRyiiAig313.png)

上面指令列出当前用户的所有分组。第一个是同名的主要分组，后面从`adm`开始是次级分组。

我先给你介绍两个分组，其他分组你可以去查资料：

- adm 分组用于系统监控，比如`/var/log`中的部分日志就是 adm 分组。
- sudo 分组用户可以通过 sudo 指令提升权限。

如果想查看当前用户，可以使用`id`指令，如下所示：

![Drawing 6.png](http://learn.lianglianglee.com/专栏/重学操作系统-完/assets/CgqCHl90SVSALssXAAGhSpF-cWY440.png)

- uid 是用户 id；
- gid 是组 id；
- groups 后面是每个分组和分组的 id。

如果想查看所有的用户，可以直接看`/etc/passwd`。

![Drawing 7.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/CgqCHl90SVqAIja7AAXBj3lebBQ651.png)

`/etc/passwd`这个文件存储了所有的用户信息，如下图所示：

![WechatIMG144.png](https://raw.githubusercontent.com/Simin-hub/Picture/master/img/CgqCHl91HIGAWXWVAACI9cgafaM295.png)

##### 创建用户

创建用户用`useradd`指令。

```undefined
sudo useradd foo
```

sudo 原意是 superuser do，后来演变成用另一个用户的身份去执行某个指令。**如果没有指定需要 sudo 的用户，就像上面那样，就是以超级管理员的身份**。因为 useradd 需要管理员身份。这句话执行后，会进行权限提升，并弹出输入管理员密码的输入界面。

##### **创建分组**

创建分组用`groupadd`指令。下面指令创建一个叫作`hello`的分组。

```undefined
sudo groupadd hello
```

##### 为用户增加次级分组

组分成主要分组（Primary Group）和次级分组（Secondary Group）。主要分组只有 1 个，次级分组可以有多个。如果想为用户添加一个次级分组，可以用`usermod`指令。下面指令将用户`foo`添加到`sudo`分组，从而`foo`拥有了`sudo`的权限。

```css
sudo usermod -a -G sudo foo
```

`-a`代表append，`-G`代表一个次级分组的清单， 最后一个`foo`是账户名。

##### 修改用户主要分组

修改主要分组还是使用`usermod`指令。只不过参数是小写的`-g`。

```undefined
sudo usermod -g somegroup foo
```

#### 文件权限管理指令

接下来我们学习文件管理相关的指令。

##### 查看

我们可以用`ls -l`查看文件的权限，相关内容在本课时前面已经介绍过了。

##### 修改文件权限

可以用`chmod`修改文件权限，`chmod`（ change file mode bits），也就是我们之前学习的 rwx，只不过 rwx 在 Linux 中是用三个连在一起的二进制位来表示。

```bash
# 设置foo可以执行

chmod +x ./foo

# 不允许foo执行

chmod -x ./foo

# 也可以同时设置多个权限

chmod +rwx ./foo
```

因为`rwx`在 Linux 中用相邻的 3 个位来表示。比如说`111`代表`rwx`，`101`代表`r-x`。而`rwx`总共有三组，分别是用户权限、组权限和全部用户权限。也就是可以用`111111111`9 个 1 代表`rwxrwxrwx`。又因为`111`10 进制是 7，因此当需要一次性设置用户权限、组权限和所有用户权限的时候，我们经常用数字表示。

```bash
# 设置rwxrwxrwx (111111111 -> 777)

chmod 777 ./foo

# 设置rw-rw-rw-(110110110 -> 666)

chmod 666 ./foo
```

##### 修改文件所属用户

有时候我们需要修改文件所属用户，这个时候会使用`chown`指令。 下面指令修改`foo`文件所属的用户为`bar`。

```bash
chown bar ./foo
```

还有一些情况下，我们需要同时修改文件所属的用户和分组，比如我们想修改`foo`的分组位`g`，用户为`u`，可以使用：

```bash
chown g.u ./foo
```