# Bash
[参考](https://www.ruanyifeng.com/blog/2020/04/bash-tutorial.html)

## 基本语法

### echo
echo命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。
```bash
$ echo hello world
hello world
```
如果想要输出的是多行文本，即包括换行符。这时就需要把多行文本放在引号里面。
```bash
$ echo "<HTML>
    <HEAD>
          <TITLE>Page Title</TITLE>
    </HEAD>
    <BODY>
          Page body.
    </BODY>
</HTML>"
```

### bash常用Linux命令

find：用于在指定目录下查找文件，可以按照文件名、文件类型、文件大小等条件进行搜索。比较常用的参数有 -name（按照文件名进行搜索），-type（按照文件类型进行搜索），-size（按照文件大小进行搜索）等

\> ：输出重定向符号。用于将命令的输出写入文件，例如 ls > file.txt 可以将 ls 命令输出的结果写入 file.txt 文件中。
* 0 是一个文件描述符，表示标准输入(stdin)
* 1 是一个文件描述符，表示标准输出(stdout)
* 2 是一个文件描述符，表示标准错误(stderr)

1>&2 正确返回值传递给2输出通道 &2表示2输出通道 
如果此处错写成 1>2, 就表示把1输出重定向到文件2中. 
2>&1 错误返回值传递给1输出通道, 同样&1表示1输出通道. 

\>前是可以加数字来说明把什么内容重定向到文件中，默认是把标准输出重定向到文件中，所以下面这个例子和上面那个是一样的（例2）：

echo "一些内容" 1> filename.txt
& 是一个描述符，如果1或2前不加&，会被当成一个普通文件。
1>&2 意思是把标准输出重定向到标准错误.
2>&1 意思是把标准错误输出重定向到标准输出。
&>filename 意思是把标准输出和标准错误输出都重定向到文件filename中

|：管道符号。用于将一个命令的输出传递给另一个命令进行处理。例如 ls -al | grep log 可以将 ls -al 的输出传递给 grep 命令进行过滤。

grep：用于在文件中查找字符串或匹配正则表达式。比较常用的参数有 -i（不区分大小写），-r（递归搜索），-v（反转匹配结果），-n（显示匹配行的行号）等。

ls：用于列出目录中的所有文件和子目录。

cd：用于切换当前目录。

pwd：用于显示当前目录的绝对路径名。

cat：用于打印文件内容。

cp：用于复制文件或目录。

mv：用于移动或重命名文件或目录。

mkdir：用于创建新目录。

rm：用于删除文件或目录。

awk：用于文本处理和数据分析。

sed：用于文本替换和转换。

tar：用于打包和解包文件。

chmod：用于修改文件或目录的权限。

ssh：用于连接远程计算机并在其中运行命令。

wget：用于从 Web 上下载文件。

#### 参数
**-n**
默认情况下，echo输出的文本末尾会有一个回车符。-n参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。

```
$ echo -n hello world
hello world$
```

**-e**
-e参数会解释引号（双引号和单引号）里面的特殊字符（比如换行符\n）。如果不使用-e参数，即默认情况下，引号会让特殊字符变成普通字符，echo不解释它们，原样输出。

```
$ echo "Hello\nWorld"
Hello\nWorld

# 双引号的情况
$ echo -e "Hello\nWorld"
Hello
World

# 单引号的情况
$ echo -e 'Hello\nWorld'
Hello
World
```

## 命令格式
命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。
```
$ command [ arg1 ... [ argN ]]
```
上面代码中，command是具体的命令或者一个可执行文件，`arg1` ... `argN`是传递给命令的参数，它们是可选的。

有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如上面的`-l`。同一个配置项往往有长和短两种形式，比如`-l`是短形式，`--list`是长形式，它们的作用完全相同。短形式便于手动输入，长形式一般用在脚本之中，可读性更好，利于解释自身的含义。

Bash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠`\`，Bash 就会将下一行跟当前行放在一起解释。

```
$ echo foo bar

# 等同于
$ echo foo \
bar
```

### 空格
Bash 使用空格（或 Tab 键）区分不同的参数。

```
$ command foo bar
```
上面命令中，foo和bar之间有一个空格，所以 Bash 认为它们是两个参数。

如果参数之间有多个空格，Bash 会自动忽略多余的空格。

```
$ echo this is a     test
this is a test
```
上面命令中，a和test之间有多个空格，Bash 会忽略多余的空格。

### 分号
分号（`;`）是**命令的结束符**，使得一行可以放置多个命令，上一个命令**执行结束后**，再执行第二个命令。

```
$ clear; ls
```
上面例子中，Bash 先执行clear命令，执行完成后，再执行ls命令。

注意，使用分号时，第二个命令总是接着第一个命令执行，**不管第一个命令执行成功或失败**。

### `&&`和`||`
除了分号，Bash 还提供两个命令组合符`&&`和`||`，允许更好地控制多个命令之间的继发关系。
```
Command1 && Command2
```
上面命令的意思是，如果Command1命令**运行成功，则继续运行**Command2命令。
```
Command1 || Command2
```
上面命令的意思是，如果Command1命令**运行失败，则继续运行**Command2命令。

下面是一些例子。
```
$ cat filelist.txt ; ls -l filelist.txt
```
上面例子中，只要cat命令执行结束，不管成功或失败，都会继续执行ls命令。
```
$ cat filelist.txt && ls -l filelist.txt
```
上面例子中，只有cat命令执行成功，才会继续执行ls命令。如果cat执行失败（比如不存在文件flielist.txt），那么ls命令就不会执行。
```
$ mkdir foo || mkdir bar
```
上面例子中，只有mkdir foo命令执行失败（比如foo目录已经存在），才会继续执行mkdir bar命令。如果mkdir foo命令执行成功，就不会创建bar目录了。

## type 命令
Bash 本身内置了很多命令，同时也可以执行外部程序。怎么知道一个命令是内置命令，还是外部程序呢？

type命令用来判断命令的来源。
```
$ type echo
echo is a shell builtin
$ type ls
ls is hashed (/bin/ls)
```

## 快捷键
Ctrl + L：清除屏幕并将当前行移到页面顶部。
Ctrl + C：中止当前正在执行的命令。
Shift + PageUp：向上滚动。
Shift + PageDown：向下滚动。
Ctrl + U：从光标位置删除到行首。
Ctrl + K：从光标位置删除到行尾。
Ctrl + W：删除光标位置前一个单词。
Ctrl + D：关闭 Shell 会话。
↑，↓：浏览已执行命令的历史记录。

自动补全 Tab

## 模式扩展
Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。
Bash 一共提供八种扩展。

* 波浪线扩展  
* ? 字符扩展
* \* 字符扩展
* 方括号扩展
* 大括号扩展
* 变量扩展
* 子命令扩展
* 算术扩展

### 波浪线扩展
当前用户的主目录 如 `/home/foo`
`~/dir`表示扩展成主目录的某个子目录，`dir`是主目录里面的一个子目录名。
```
# 进入 /home/me/foo 目录
$ cd ~/foo
```
`~user`表示扩展成用户user的主目录。
```
$ echo ~foo
/home/foo

$ echo ~root
/root
```

如果`~user`的`user`是不存在的用户名，则波浪号扩展不起作用。

### `?` 字符扩展
?字符代表文件路径里面的任意单个字符，不包括空字符。比如，Data???匹配所有Data后面跟着三个字符的文件名。
如果匹配多个字符，就需要多个?连用。
```
# 存在文件 a.txt、b.txt 和 ab.txt
$ ls ??.txt
ab.txt
```

### `*` 字符扩展
`*`字符代表文件路径里面的任意数量的**任意字符**，包括**零个字符**。
```
# 存在文件 a.txt、b.txt 和 ab.txt
$ ls *.txt
a.txt b.txt ab.txt
```
### 方括号扩展

方括号扩展的形式是[...]，只有文件确实存在的前提下才会扩展。如果文件不存在，就会**原样输出**。**括号之中的任意一个字符**。比如，[aeiou]可以匹配五个元音字母中的任意一个。
```
# 存在文件 a.txt 和 b.txt
$ ls [ab].txt
a.txt b.txt

# 只存在文件 a.txt
$ ls [ab].txt
a.txt

# 不存在文件 a.txt 和 b.txt
$ ls [ab].txt
ls: 无法访问'[ab].txt': 没有那个文件或目录
```
方括号扩展还有两种变体：`[^...]`和`[!...]`。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，`[^abc]`或`[!abc]`表示匹配除了a、b、c以外的字符。
```
# 存在 aaa、bbb、aba 三个文件
$ ls ?[!a]?
aba bbb
```

### `[start-end]` 扩展
方括号扩展有一个简写形式`[start-end]`，表示**匹配一个连续的范围**。比如，`[a-c]`等同于`[abc]`，`[0-9]`匹配`[0123456789]`。
```
# 存在文件 a.txt、b.txt 和 c.txt
$ ls [a-c].txt
a.txt
b.txt
c.txt

# 存在文件 report1.txt、report2.txt 和 report3.txt
$ ls report[0-9].txt
report1.txt
report2.txt
report3.txt
```
这种简写形式有一个否定形式[!start-end]，表示匹配不属于这个范围的字符。比如，[!a-zA-Z]表示匹配非英文字母的字符。
```
$ ls report[!1–3].txt
report4.txt report5.txt
```
### 大括号扩展
大括号扩展`{...}`表示**分别扩展成大括号里面的所有值**，各个值之间使用逗号分隔。比如，`{1,2,3}`扩展成`1 2 3`。
注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。
```
$ ls {a,b,c}.txt
ls: 无法访问'a.txt': 没有那个文件或目录
ls: 无法访问'b.txt': 没有那个文件或目录
ls: 无法访问'c.txt': 没有那个文件或目录
```

另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。
```
$ echo {1 , 2}
{1 , 2}
```
上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。

逗号前面可以没有值，表示扩展的第一项为空。
```
$ cp a.log{,.bak}

# 等同于
# cp a.log a.log.bak
```
大括号可以嵌套。
```
$ echo {j{p,pe}g,png}
jpg jpeg png

$ echo a{A{1,2},B{3,4}}b
aA1b aA2b aB3b aB4b
```
大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。

### {start..end} 扩展

大括号扩展有一个简写形式{start..end}，表示扩展成一个连续序列。比如，{a..z}可以扩展成26个小写英文字母。
```
$ echo {a..c}
a b c

$ echo d{a..d}g
dag dbg dcg ddg

$ echo {1..4}
1 2 3 4

$ echo Number_{1..5}
Number_1 Number_2 Number_3 Number_4 Number_5
```

这种简写形式支持逆序。
注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。

### 变量扩展

Bash 将美元符号$开头的词元视为变量，将其扩展成变量值
```
$ echo $SHELL
/bin/bash
```
变量名除了放在美元符号后面，也可以放在${}里面。
```
$ echo ${SHELL}
/bin/bash
# ${!string*}或${!string@}返回所有匹配给定字符串string的变量名。
$ echo ${!S*}
SECONDS SHELL SHELLOPTS SHLVL SSH_AGENT_PID SSH_AUTH_SOCK
```

### 子命令扩展
`$(...)`可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。
```
$ echo $(date)
Tue Jan 28 00:01:13 CST 2020
上面例子中，$(date)返回date命令的运行结果。
```

`$(...)`可以嵌套，比如`$(ls $(pwd))`。

### 转义

## 变量
Bash 变量分成环境变量和自定义变量两类。
### 环境变量
环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，可以直接使用。它们通常是系统定义好的，也可以由用户从父 Shell 传入子 Shell。

`env`命令或`printenv`命令，可以显示所有环境变量。

### 自定义变量
自定义变量是用户在当前 Shell 里面自己定义的变量，仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。

set命令可以显示所有变量（包括环境变量和自定义变量），以及所有的 Bash 函数。

### 创建变量
用户创建变量的时候，变量名必须遵守下面的规则。

* 字母、数字和下划线字符组成。
* 第一个字符必须是一个字母或一个下划线，不能是数字。
* 不允许出现空格和标点符号。

变量声明的语法如下。
```
variable=value
```
上面命令中，等号左边是变量名，右边是变量。注意，等号两边不能有空格。

如果变量的值包含空格，则必须将值放在引号中。
```
myvar="hello world"
```
Bash 没有数据类型的概念，**所有的变量值都是字符串**。

如果同一行定义多个变量，必须使用分号（;）分隔。
```
$ foo=1;bar=2
```

### 读取变量
读取变量的时候，直接在变量名前加上`$`就可以了。
```
$ foo=bar
$ echo $foo
bar
```
每当 Shell 看到以$开头的单词时，就会尝试读取这个变量名对应的值。

如果变量不存在，Bash 不会报错，而会输出空字符。

读取变量的时候，变量名也可以使用花括号{}包围，比如`$a`也可以写成`${a}`。这种写法可以用于变量名与其他字符连用的情况。
```
$ a=foo
$ echo $a_file

$ echo ${a}_file
foo_file
```
如果变量的值本身也是变量，可以使用`${!varname}`的语法，读取最终的值。

### 删除变量
`unset`命令用来删除一个变量。
```
unset NAME
```

### 输出变量，export 命令
用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用export命令。这样输出的变量，对于子 Shell 来说就是环境变量。

export命令用来向子 Shell 输出变量。
```
NAME=foo
export NAME
```

### 特殊变量
Bash 提供一些特殊变量。这些变量的值由 Shell 提供，用户不能进行赋值。

（1）`$?`

`$?`为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是0，表示上一个命令执行成功；如果不是零，表示上一个命令执行失败。
（2）`$$`
`$$`为当前 Shell 的进程 ID。

（3）`$_`
`$_`为上一个命令的最后一个参数。
（4）`$!`
`$!`为最近一个后台执行的异步命令的进程 ID。
（5）`$0`
`$0`为当前 Shell 的名称（在命令行直接执行时）或者脚本名（在脚本中执行时）。
（7）`$@`和`$#`
`$#`表示脚本的参数数量，`$@`表示脚本的参数值

### 变量的默认值

`${varname:-word}`
`${varname:-word}`
`${varname:+word}`
`${varname:?message}`

## 字符串操作

## 脚本
脚本（script）就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。
### Shebang 行
脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以#!字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。
`#!`后面就是脚本解释器的位置，Bash 脚本的解释器一般是`/bin/sh`或`/bin/bash`。
```
#!/bin/sh
# 或者
#!/bin/bash
```
### 执行权限和路径
前面说过，只要指定了 Shebang 行的脚本，可以直接执行。这有一个前提条件，就是脚本需要有执行权限。可以使用下面的命令，赋予脚本执行权限。
```
# 给所有用户执行权限
$ chmod +x script.sh

# 给所有用户读权限和执行权限
$ chmod +rx script.sh
# 或者
$ chmod 755 script.sh

# 只给脚本拥有者读权限和执行权限
$ chmod u+rx script.sh
```

### env 命令

### 注释
Bash 脚本中，`#`表示注释，可以放在行首，也可以放在行尾。

### 脚本参数
调用脚本的时候，脚本文件名后面可以带有参数。
```
$ script.sh word1 word2 word3
```
上面例子中，script.sh是一个脚本文件，word1、word2和word3是三个参数。

脚本文件内部，可以使用特殊变量，引用这些参数。

* `$0`：脚本文件名，即`script.sh`。
* `$1`~`$9`：对应脚本的第一个参数到第九个参数。
* `$#`：参数的总数。
* `$@`：全部的参数，参数之间使用空格分隔。
* `$*`：全部的参数，参数之间使用变量`$IFS`值的第一个字符分隔，默认为空格，但是可以自定义。

如果脚本的参数多于9个，那么第10个参数可以用${10}的形式引用，以此类推。

注意，如果命令是`command -o foo bar`，那么`-o`是`$1`，`foo`是`$2`，`bar`是`$3`。

下面是一个脚本内部读取命令行参数的例子。
```
#!/bin/bash
# script.sh

echo "全部参数：" $@
echo "命令行参数数量：" $#
echo '$0 = ' $0
echo '$1 = ' $1
echo '$2 = ' $2
echo '$3 = ' $3
```

### shift 命令

shift命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数（`$1`），使得后面的参数向前一位，即`$2`变成`$1`、`$3`变成`$2`、`$4`变成`$3`，以此类推。

### exit 命令
`exit`命令用于终止当前脚本的执行，并向 `Shell` 返回一个退出值。
exit命令后面可以跟参数，该参数就是退出状态。
```
# 退出值为0（成功）
$ exit 0

# 退出值为1（失败）
$ exit 1
```

### source 命令
source命令用于执行一个脚本，通常用于重新加载一个配置文件。
```
$ source .bashrc
```
source命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，source命令执行脚本时，不需要export变量。

### 别名，alias 命令

### read命令
用户的输入存入一个变量，方便后面的代码使用。用户按下回车键，就表示输入结束。

read命令的格式如下。

read [-options] [variable...]
上面语法中，options是参数选项，variable是用来保存输入数值的一个或多个变量名。如果没有提供变量名，环境变量REPLY会包含用户输入的一整行数据。

下面是一个例子demo.sh。
```
#!/bin/bash

echo -n "输入一些文本 > "
read text
echo "你的输入：$text"
```
如果用户的输入项少于read命令给出的变量数目，那么额外的变量值为空。如果用户的输入项多于定义的变量，那么多余的输入项会包含到最后一个变量中。

如果read命令之后没有定义变量名，那么环境变量REPLY会包含所有的输入。

read命令除了读取键盘输入，可以用来读取文件。

#### 参数
（1）-t 参数
read命令的-t参数，设置了超时的秒数。如果超过了指定时间，用户仍然没有输入，脚本将放弃等待，继续向下执行。
（2）-p 参数

-p参数指定用户输入的提示信息。
（3）-a 参数

-a参数把用户的输入赋值给一个数组，从零号位置开始。
（4）-n 参数

-n参数指定只读取若干个字符作为变量值，而不是整行读取。
（5）-e 参数

-e参数允许用户输入的时候，使用readline库提供的快捷键，比如自动补全。
（6）其他参数

* -d delimiter：定义字符串delimiter的第一个字符作为用户输入的结束，而不是一个换行符。
* -r：raw 模式，表示不把用户输入的反斜杠字符解释为转义字符。
* -s：使得用户的输入不显示在屏幕上，这常常用于输入密码或保密信息。
* -u fd：使用文件描述符fd作为输入。

### test命令
if结构的判断条件，一般使用test命令，有三种形式。
```
# 写法一
test expression

# 写法二
[ expression ]

# 写法三
[[ expression ]]
```

### 运算符

#### 文件运算符
```
-b file ：检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。
-c file ：检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。
-d file ：检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。
-f file ：检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。
-g file ：检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。
-k file ：检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。
-p file ：检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。
-u file ：检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。
-r file ：检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。
-w file ：检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。
-x file ：检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。
-s file ：检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。
-e file ：检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。
```
#### 数字关系运算符
关系运算符只支持数字，不支持字符串，除非字符串的值是数字。
下面假定变量 a 为 10，变量 b 为 20
```
-eq ：检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。
-ne： 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。
-gt： 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。
-lt ： 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。
-ge： 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。
-le ： 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。
```
#### 字符串运算符
下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：
```
= ：检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。
!= ：检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。
-z ：检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。
-n ：检测字符串长度是否为0，不为0返回 true。 [ -n "$a" ] 返回 true。
$ ：检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。
```
#### 布尔运算符
下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：
```
! ：非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。
-o ：或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。
-a ：与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。
```
#### 逻辑运算符
以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:
```
&& ：逻辑的 AND [[ $a -lt 100 && $b -gt 100 ]] 返回 false
|| ：逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] 返回 true
```
### 条件判断

### 循环

### 函数
函数（function）是可以重复使用的代码片段，有利于代码的复用。它与别名（alias）的区别是，别名只适合封装简单的单个命令，函数则可以封装复杂的多行命令。
Bash 函数定义的语法有两种。
```
# 第一种
fn() {
  # codes
}

# 第二种
function fn() {
  # codes
}
```
#### 参数变量
函数体内可以使用参数变量，获取函数参数。函数的参数变量，与脚本参数变量是一致的。

#### return 命令
return命令用于从函数返回一个值。函数执行到这条命令，就不再往下执行了，直接返回了。

#### 全局变量和局部变量，local 命令
Bash 函数体内直接声明的变量，属于全局变量。函数里面可以用local命令声明局部变量。

### set 命令，shopt 命令

## 脚本除错

## mktemp 命令，trap 命令
Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在/tmp目录里面创建文件或目录，这样做有很多弊端，使用mktemp命令是最安全的做法。

## 实例解析



